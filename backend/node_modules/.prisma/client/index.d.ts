
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Parent
 * 
 */
export type Parent = $Result.DefaultSelection<Prisma.$ParentPayload>
/**
 * Model SchoolNurse
 * 
 */
export type SchoolNurse = $Result.DefaultSelection<Prisma.$SchoolNursePayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Admin
 * 
 */
export type Admin = $Result.DefaultSelection<Prisma.$AdminPayload>
/**
 * Model StudentParent
 * 
 */
export type StudentParent = $Result.DefaultSelection<Prisma.$StudentParentPayload>
/**
 * Model HealthProfile
 * 
 */
export type HealthProfile = $Result.DefaultSelection<Prisma.$HealthProfilePayload>
/**
 * Model MedicalEvent
 * 
 */
export type MedicalEvent = $Result.DefaultSelection<Prisma.$MedicalEventPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model StudentMedication
 * 
 */
export type StudentMedication = $Result.DefaultSelection<Prisma.$StudentMedicationPayload>
/**
 * Model MedicalEventMedication
 * 
 */
export type MedicalEventMedication = $Result.DefaultSelection<Prisma.$MedicalEventMedicationPayload>
/**
 * Model StockMovement
 * 
 */
export type StockMovement = $Result.DefaultSelection<Prisma.$StockMovementPayload>
/**
 * Model VaccinationCampaign
 * 
 */
export type VaccinationCampaign = $Result.DefaultSelection<Prisma.$VaccinationCampaignPayload>
/**
 * Model Vaccination
 * 
 */
export type Vaccination = $Result.DefaultSelection<Prisma.$VaccinationPayload>
/**
 * Model MedicalCheckCampaign
 * 
 */
export type MedicalCheckCampaign = $Result.DefaultSelection<Prisma.$MedicalCheckCampaignPayload>
/**
 * Model MedicalCheck
 * 
 */
export type MedicalCheck = $Result.DefaultSelection<Prisma.$MedicalCheckPayload>
/**
 * Model MedicalDocument
 * 
 */
export type MedicalDocument = $Result.DefaultSelection<Prisma.$MedicalDocumentPayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model SchoolInfo
 * 
 */
export type SchoolInfo = $Result.DefaultSelection<Prisma.$SchoolInfoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  STUDENT: 'STUDENT',
  PARENT: 'PARENT',
  SCHOOL_NURSE: 'SCHOOL_NURSE',
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const MedicalEventType: {
  ACCIDENT: 'ACCIDENT',
  FEVER: 'FEVER',
  FALL: 'FALL',
  EPIDEMIC: 'EPIDEMIC',
  ALLERGY_REACTION: 'ALLERGY_REACTION',
  CHRONIC_DISEASE_EPISODE: 'CHRONIC_DISEASE_EPISODE',
  OTHER: 'OTHER'
};

export type MedicalEventType = (typeof MedicalEventType)[keyof typeof MedicalEventType]


export const MedicalEventStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  REFERRED: 'REFERRED'
};

export type MedicalEventStatus = (typeof MedicalEventStatus)[keyof typeof MedicalEventStatus]


export const VaccinationStatus: {
  SCHEDULED: 'SCHEDULED',
  COMPLETED: 'COMPLETED',
  POSTPONED: 'POSTPONED',
  CANCELLED: 'CANCELLED'
};

export type VaccinationStatus = (typeof VaccinationStatus)[keyof typeof VaccinationStatus]


export const MedicalCheckStatus: {
  SCHEDULED: 'SCHEDULED',
  COMPLETED: 'COMPLETED',
  RESCHEDULED: 'RESCHEDULED',
  CANCELLED: 'CANCELLED'
};

export type MedicalCheckStatus = (typeof MedicalCheckStatus)[keyof typeof MedicalCheckStatus]


export const MedicationStatus: {
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  ACTIVE: 'ACTIVE',
  EXPIRED: 'EXPIRED'
};

export type MedicationStatus = (typeof MedicationStatus)[keyof typeof MedicationStatus]


export const NotificationStatus: {
  SENT: 'SENT',
  DELIVERED: 'DELIVERED',
  READ: 'READ',
  EXPIRED: 'EXPIRED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type MedicalEventType = $Enums.MedicalEventType

export const MedicalEventType: typeof $Enums.MedicalEventType

export type MedicalEventStatus = $Enums.MedicalEventStatus

export const MedicalEventStatus: typeof $Enums.MedicalEventStatus

export type VaccinationStatus = $Enums.VaccinationStatus

export const VaccinationStatus: typeof $Enums.VaccinationStatus

export type MedicalCheckStatus = $Enums.MedicalCheckStatus

export const MedicalCheckStatus: typeof $Enums.MedicalCheckStatus

export type MedicationStatus = $Enums.MedicationStatus

export const MedicationStatus: typeof $Enums.MedicationStatus

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.parent`: Exposes CRUD operations for the **Parent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parents
    * const parents = await prisma.parent.findMany()
    * ```
    */
  get parent(): Prisma.ParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolNurse`: Exposes CRUD operations for the **SchoolNurse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolNurses
    * const schoolNurses = await prisma.schoolNurse.findMany()
    * ```
    */
  get schoolNurse(): Prisma.SchoolNurseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.admin`: Exposes CRUD operations for the **Admin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Admins
    * const admins = await prisma.admin.findMany()
    * ```
    */
  get admin(): Prisma.AdminDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentParent`: Exposes CRUD operations for the **StudentParent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentParents
    * const studentParents = await prisma.studentParent.findMany()
    * ```
    */
  get studentParent(): Prisma.StudentParentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.healthProfile`: Exposes CRUD operations for the **HealthProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthProfiles
    * const healthProfiles = await prisma.healthProfile.findMany()
    * ```
    */
  get healthProfile(): Prisma.HealthProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalEvent`: Exposes CRUD operations for the **MedicalEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalEvents
    * const medicalEvents = await prisma.medicalEvent.findMany()
    * ```
    */
  get medicalEvent(): Prisma.MedicalEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentMedication`: Exposes CRUD operations for the **StudentMedication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentMedications
    * const studentMedications = await prisma.studentMedication.findMany()
    * ```
    */
  get studentMedication(): Prisma.StudentMedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalEventMedication`: Exposes CRUD operations for the **MedicalEventMedication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalEventMedications
    * const medicalEventMedications = await prisma.medicalEventMedication.findMany()
    * ```
    */
  get medicalEventMedication(): Prisma.MedicalEventMedicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stockMovement`: Exposes CRUD operations for the **StockMovement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StockMovements
    * const stockMovements = await prisma.stockMovement.findMany()
    * ```
    */
  get stockMovement(): Prisma.StockMovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccinationCampaign`: Exposes CRUD operations for the **VaccinationCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VaccinationCampaigns
    * const vaccinationCampaigns = await prisma.vaccinationCampaign.findMany()
    * ```
    */
  get vaccinationCampaign(): Prisma.VaccinationCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vaccination`: Exposes CRUD operations for the **Vaccination** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vaccinations
    * const vaccinations = await prisma.vaccination.findMany()
    * ```
    */
  get vaccination(): Prisma.VaccinationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalCheckCampaign`: Exposes CRUD operations for the **MedicalCheckCampaign** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalCheckCampaigns
    * const medicalCheckCampaigns = await prisma.medicalCheckCampaign.findMany()
    * ```
    */
  get medicalCheckCampaign(): Prisma.MedicalCheckCampaignDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalCheck`: Exposes CRUD operations for the **MedicalCheck** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalChecks
    * const medicalChecks = await prisma.medicalCheck.findMany()
    * ```
    */
  get medicalCheck(): Prisma.MedicalCheckDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medicalDocument`: Exposes CRUD operations for the **MedicalDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicalDocuments
    * const medicalDocuments = await prisma.medicalDocument.findMany()
    * ```
    */
  get medicalDocument(): Prisma.MedicalDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolInfo`: Exposes CRUD operations for the **SchoolInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolInfos
    * const schoolInfos = await prisma.schoolInfo.findMany()
    * ```
    */
  get schoolInfo(): Prisma.SchoolInfoDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.9.0
   * Query Engine version: 81e4af48011447c3cc503a190e86995b66d2a28e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    Student: 'Student',
    Parent: 'Parent',
    SchoolNurse: 'SchoolNurse',
    Manager: 'Manager',
    Admin: 'Admin',
    StudentParent: 'StudentParent',
    HealthProfile: 'HealthProfile',
    MedicalEvent: 'MedicalEvent',
    Medication: 'Medication',
    StudentMedication: 'StudentMedication',
    MedicalEventMedication: 'MedicalEventMedication',
    StockMovement: 'StockMovement',
    VaccinationCampaign: 'VaccinationCampaign',
    Vaccination: 'Vaccination',
    MedicalCheckCampaign: 'MedicalCheckCampaign',
    MedicalCheck: 'MedicalCheck',
    MedicalDocument: 'MedicalDocument',
    Post: 'Post',
    Notification: 'Notification',
    AuditLog: 'AuditLog',
    SchoolInfo: 'SchoolInfo'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "student" | "parent" | "schoolNurse" | "manager" | "admin" | "studentParent" | "healthProfile" | "medicalEvent" | "medication" | "studentMedication" | "medicalEventMedication" | "stockMovement" | "vaccinationCampaign" | "vaccination" | "medicalCheckCampaign" | "medicalCheck" | "medicalDocument" | "post" | "notification" | "auditLog" | "schoolInfo"
      txIsolationLevel: never
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Parent: {
        payload: Prisma.$ParentPayload<ExtArgs>
        fields: Prisma.ParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findFirst: {
            args: Prisma.ParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          findMany: {
            args: Prisma.ParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>[]
          }
          create: {
            args: Prisma.ParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          createMany: {
            args: Prisma.ParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          update: {
            args: Prisma.ParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          deleteMany: {
            args: Prisma.ParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParentPayload>
          }
          aggregate: {
            args: Prisma.ParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParent>
          }
          groupBy: {
            args: Prisma.ParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ParentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ParentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ParentCountArgs<ExtArgs>
            result: $Utils.Optional<ParentCountAggregateOutputType> | number
          }
        }
      }
      SchoolNurse: {
        payload: Prisma.$SchoolNursePayload<ExtArgs>
        fields: Prisma.SchoolNurseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolNurseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolNurseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          findFirst: {
            args: Prisma.SchoolNurseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolNurseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          findMany: {
            args: Prisma.SchoolNurseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>[]
          }
          create: {
            args: Prisma.SchoolNurseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          createMany: {
            args: Prisma.SchoolNurseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SchoolNurseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          update: {
            args: Prisma.SchoolNurseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          deleteMany: {
            args: Prisma.SchoolNurseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolNurseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolNurseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolNursePayload>
          }
          aggregate: {
            args: Prisma.SchoolNurseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolNurse>
          }
          groupBy: {
            args: Prisma.SchoolNurseGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolNurseGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SchoolNurseFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SchoolNurseAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SchoolNurseCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolNurseCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ManagerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ManagerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Admin: {
        payload: Prisma.$AdminPayload<ExtArgs>
        fields: Prisma.AdminFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findFirst: {
            args: Prisma.AdminFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          findMany: {
            args: Prisma.AdminFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>[]
          }
          create: {
            args: Prisma.AdminCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          createMany: {
            args: Prisma.AdminCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AdminDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          update: {
            args: Prisma.AdminUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          deleteMany: {
            args: Prisma.AdminDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminPayload>
          }
          aggregate: {
            args: Prisma.AdminAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdmin>
          }
          groupBy: {
            args: Prisma.AdminGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AdminFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AdminAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AdminCountArgs<ExtArgs>
            result: $Utils.Optional<AdminCountAggregateOutputType> | number
          }
        }
      }
      StudentParent: {
        payload: Prisma.$StudentParentPayload<ExtArgs>
        fields: Prisma.StudentParentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentParentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentParentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findFirst: {
            args: Prisma.StudentParentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentParentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          findMany: {
            args: Prisma.StudentParentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>[]
          }
          create: {
            args: Prisma.StudentParentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          createMany: {
            args: Prisma.StudentParentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentParentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          update: {
            args: Prisma.StudentParentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          deleteMany: {
            args: Prisma.StudentParentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentParentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentParentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentParentPayload>
          }
          aggregate: {
            args: Prisma.StudentParentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentParent>
          }
          groupBy: {
            args: Prisma.StudentParentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentParentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentParentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentParentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentParentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentParentCountAggregateOutputType> | number
          }
        }
      }
      HealthProfile: {
        payload: Prisma.$HealthProfilePayload<ExtArgs>
        fields: Prisma.HealthProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          findFirst: {
            args: Prisma.HealthProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          findMany: {
            args: Prisma.HealthProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>[]
          }
          create: {
            args: Prisma.HealthProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          createMany: {
            args: Prisma.HealthProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HealthProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          update: {
            args: Prisma.HealthProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          deleteMany: {
            args: Prisma.HealthProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          aggregate: {
            args: Prisma.HealthProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthProfile>
          }
          groupBy: {
            args: Prisma.HealthProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthProfileGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.HealthProfileFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.HealthProfileAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.HealthProfileCountArgs<ExtArgs>
            result: $Utils.Optional<HealthProfileCountAggregateOutputType> | number
          }
        }
      }
      MedicalEvent: {
        payload: Prisma.$MedicalEventPayload<ExtArgs>
        fields: Prisma.MedicalEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          findFirst: {
            args: Prisma.MedicalEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          findMany: {
            args: Prisma.MedicalEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>[]
          }
          create: {
            args: Prisma.MedicalEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          createMany: {
            args: Prisma.MedicalEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          update: {
            args: Prisma.MedicalEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          deleteMany: {
            args: Prisma.MedicalEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventPayload>
          }
          aggregate: {
            args: Prisma.MedicalEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalEvent>
          }
          groupBy: {
            args: Prisma.MedicalEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicalEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicalEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicalEventCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalEventCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      StudentMedication: {
        payload: Prisma.$StudentMedicationPayload<ExtArgs>
        fields: Prisma.StudentMedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentMedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentMedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          findFirst: {
            args: Prisma.StudentMedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentMedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          findMany: {
            args: Prisma.StudentMedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>[]
          }
          create: {
            args: Prisma.StudentMedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          createMany: {
            args: Prisma.StudentMedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StudentMedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          update: {
            args: Prisma.StudentMedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          deleteMany: {
            args: Prisma.StudentMedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentMedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentMedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentMedicationPayload>
          }
          aggregate: {
            args: Prisma.StudentMedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentMedication>
          }
          groupBy: {
            args: Prisma.StudentMedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentMedicationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StudentMedicationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StudentMedicationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StudentMedicationCountArgs<ExtArgs>
            result: $Utils.Optional<StudentMedicationCountAggregateOutputType> | number
          }
        }
      }
      MedicalEventMedication: {
        payload: Prisma.$MedicalEventMedicationPayload<ExtArgs>
        fields: Prisma.MedicalEventMedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalEventMedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalEventMedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicalEventMedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalEventMedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          findMany: {
            args: Prisma.MedicalEventMedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>[]
          }
          create: {
            args: Prisma.MedicalEventMedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          createMany: {
            args: Prisma.MedicalEventMedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalEventMedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          update: {
            args: Prisma.MedicalEventMedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicalEventMedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalEventMedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalEventMedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalEventMedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicalEventMedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalEventMedication>
          }
          groupBy: {
            args: Prisma.MedicalEventMedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalEventMedicationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicalEventMedicationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicalEventMedicationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicalEventMedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalEventMedicationCountAggregateOutputType> | number
          }
        }
      }
      StockMovement: {
        payload: Prisma.$StockMovementPayload<ExtArgs>
        fields: Prisma.StockMovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StockMovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StockMovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findFirst: {
            args: Prisma.StockMovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StockMovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          findMany: {
            args: Prisma.StockMovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>[]
          }
          create: {
            args: Prisma.StockMovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          createMany: {
            args: Prisma.StockMovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StockMovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          update: {
            args: Prisma.StockMovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          deleteMany: {
            args: Prisma.StockMovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StockMovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StockMovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StockMovementPayload>
          }
          aggregate: {
            args: Prisma.StockMovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStockMovement>
          }
          groupBy: {
            args: Prisma.StockMovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<StockMovementGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.StockMovementFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.StockMovementAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.StockMovementCountArgs<ExtArgs>
            result: $Utils.Optional<StockMovementCountAggregateOutputType> | number
          }
        }
      }
      VaccinationCampaign: {
        payload: Prisma.$VaccinationCampaignPayload<ExtArgs>
        fields: Prisma.VaccinationCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          findFirst: {
            args: Prisma.VaccinationCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          findMany: {
            args: Prisma.VaccinationCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>[]
          }
          create: {
            args: Prisma.VaccinationCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          createMany: {
            args: Prisma.VaccinationCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VaccinationCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          update: {
            args: Prisma.VaccinationCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VaccinationCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationCampaignPayload>
          }
          aggregate: {
            args: Prisma.VaccinationCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccinationCampaign>
          }
          groupBy: {
            args: Prisma.VaccinationCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationCampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VaccinationCampaignFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VaccinationCampaignAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VaccinationCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationCampaignCountAggregateOutputType> | number
          }
        }
      }
      Vaccination: {
        payload: Prisma.$VaccinationPayload<ExtArgs>
        fields: Prisma.VaccinationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VaccinationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VaccinationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findFirst: {
            args: Prisma.VaccinationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VaccinationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          findMany: {
            args: Prisma.VaccinationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>[]
          }
          create: {
            args: Prisma.VaccinationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          createMany: {
            args: Prisma.VaccinationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VaccinationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          update: {
            args: Prisma.VaccinationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          deleteMany: {
            args: Prisma.VaccinationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VaccinationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VaccinationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VaccinationPayload>
          }
          aggregate: {
            args: Prisma.VaccinationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVaccination>
          }
          groupBy: {
            args: Prisma.VaccinationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VaccinationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.VaccinationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.VaccinationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.VaccinationCountArgs<ExtArgs>
            result: $Utils.Optional<VaccinationCountAggregateOutputType> | number
          }
        }
      }
      MedicalCheckCampaign: {
        payload: Prisma.$MedicalCheckCampaignPayload<ExtArgs>
        fields: Prisma.MedicalCheckCampaignFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalCheckCampaignFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalCheckCampaignFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          findFirst: {
            args: Prisma.MedicalCheckCampaignFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalCheckCampaignFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          findMany: {
            args: Prisma.MedicalCheckCampaignFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>[]
          }
          create: {
            args: Prisma.MedicalCheckCampaignCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          createMany: {
            args: Prisma.MedicalCheckCampaignCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalCheckCampaignDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          update: {
            args: Prisma.MedicalCheckCampaignUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          deleteMany: {
            args: Prisma.MedicalCheckCampaignDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalCheckCampaignUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalCheckCampaignUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckCampaignPayload>
          }
          aggregate: {
            args: Prisma.MedicalCheckCampaignAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalCheckCampaign>
          }
          groupBy: {
            args: Prisma.MedicalCheckCampaignGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalCheckCampaignGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicalCheckCampaignFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicalCheckCampaignAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicalCheckCampaignCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalCheckCampaignCountAggregateOutputType> | number
          }
        }
      }
      MedicalCheck: {
        payload: Prisma.$MedicalCheckPayload<ExtArgs>
        fields: Prisma.MedicalCheckFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalCheckFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalCheckFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          findFirst: {
            args: Prisma.MedicalCheckFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalCheckFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          findMany: {
            args: Prisma.MedicalCheckFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>[]
          }
          create: {
            args: Prisma.MedicalCheckCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          createMany: {
            args: Prisma.MedicalCheckCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalCheckDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          update: {
            args: Prisma.MedicalCheckUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          deleteMany: {
            args: Prisma.MedicalCheckDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalCheckUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalCheckUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalCheckPayload>
          }
          aggregate: {
            args: Prisma.MedicalCheckAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalCheck>
          }
          groupBy: {
            args: Prisma.MedicalCheckGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalCheckGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicalCheckFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicalCheckAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicalCheckCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalCheckCountAggregateOutputType> | number
          }
        }
      }
      MedicalDocument: {
        payload: Prisma.$MedicalDocumentPayload<ExtArgs>
        fields: Prisma.MedicalDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicalDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicalDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          findFirst: {
            args: Prisma.MedicalDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicalDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          findMany: {
            args: Prisma.MedicalDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>[]
          }
          create: {
            args: Prisma.MedicalDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          createMany: {
            args: Prisma.MedicalDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MedicalDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          update: {
            args: Prisma.MedicalDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          deleteMany: {
            args: Prisma.MedicalDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicalDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicalDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicalDocumentPayload>
          }
          aggregate: {
            args: Prisma.MedicalDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicalDocument>
          }
          groupBy: {
            args: Prisma.MedicalDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicalDocumentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.MedicalDocumentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.MedicalDocumentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.MedicalDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<MedicalDocumentCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PostFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PostAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AuditLogFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AuditLogAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      SchoolInfo: {
        payload: Prisma.$SchoolInfoPayload<ExtArgs>
        fields: Prisma.SchoolInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          findFirst: {
            args: Prisma.SchoolInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          findMany: {
            args: Prisma.SchoolInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>[]
          }
          create: {
            args: Prisma.SchoolInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          createMany: {
            args: Prisma.SchoolInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SchoolInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          update: {
            args: Prisma.SchoolInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          deleteMany: {
            args: Prisma.SchoolInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SchoolInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolInfoPayload>
          }
          aggregate: {
            args: Prisma.SchoolInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolInfo>
          }
          groupBy: {
            args: Prisma.SchoolInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolInfoGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SchoolInfoFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SchoolInfoAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SchoolInfoCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolInfoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    student?: StudentOmit
    parent?: ParentOmit
    schoolNurse?: SchoolNurseOmit
    manager?: ManagerOmit
    admin?: AdminOmit
    studentParent?: StudentParentOmit
    healthProfile?: HealthProfileOmit
    medicalEvent?: MedicalEventOmit
    medication?: MedicationOmit
    studentMedication?: StudentMedicationOmit
    medicalEventMedication?: MedicalEventMedicationOmit
    stockMovement?: StockMovementOmit
    vaccinationCampaign?: VaccinationCampaignOmit
    vaccination?: VaccinationOmit
    medicalCheckCampaign?: MedicalCheckCampaignOmit
    medicalCheck?: MedicalCheckOmit
    medicalDocument?: MedicalDocumentOmit
    post?: PostOmit
    notification?: NotificationOmit
    auditLog?: AuditLogOmit
    schoolInfo?: SchoolInfoOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    createdPosts: number
    createdEvents: number
    notifications: number
    auditLogs: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdPosts?: boolean | UsersCountOutputTypeCountCreatedPostsArgs
    createdEvents?: boolean | UsersCountOutputTypeCountCreatedEventsArgs
    notifications?: boolean | UsersCountOutputTypeCountNotificationsArgs
    auditLogs?: boolean | UsersCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCreatedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    parents: number
    medicalEvents: number
    vaccinations: number
    medicalChecks: number
    medications: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parents?: boolean | StudentCountOutputTypeCountParentsArgs
    medicalEvents?: boolean | StudentCountOutputTypeCountMedicalEventsArgs
    vaccinations?: boolean | StudentCountOutputTypeCountVaccinationsArgs
    medicalChecks?: boolean | StudentCountOutputTypeCountMedicalChecksArgs
    medications?: boolean | StudentCountOutputTypeCountMedicationsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountParentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMedicalEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMedicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCheckWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMedicationWhereInput
  }


  /**
   * Count Type ParentCountOutputType
   */

  export type ParentCountOutputType = {
    children: number
    medications: number
  }

  export type ParentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | ParentCountOutputTypeCountChildrenArgs
    medications?: boolean | ParentCountOutputTypeCountMedicationsArgs
  }

  // Custom InputTypes
  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParentCountOutputType
     */
    select?: ParentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
  }

  /**
   * ParentCountOutputType without action
   */
  export type ParentCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMedicationWhereInput
  }


  /**
   * Count Type SchoolNurseCountOutputType
   */

  export type SchoolNurseCountOutputType = {
    handledEvents: number
    vaccinations: number
    medicalChecks: number
  }

  export type SchoolNurseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    handledEvents?: boolean | SchoolNurseCountOutputTypeCountHandledEventsArgs
    vaccinations?: boolean | SchoolNurseCountOutputTypeCountVaccinationsArgs
    medicalChecks?: boolean | SchoolNurseCountOutputTypeCountMedicalChecksArgs
  }

  // Custom InputTypes
  /**
   * SchoolNurseCountOutputType without action
   */
  export type SchoolNurseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurseCountOutputType
     */
    select?: SchoolNurseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SchoolNurseCountOutputType without action
   */
  export type SchoolNurseCountOutputTypeCountHandledEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventWhereInput
  }

  /**
   * SchoolNurseCountOutputType without action
   */
  export type SchoolNurseCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }

  /**
   * SchoolNurseCountOutputType without action
   */
  export type SchoolNurseCountOutputTypeCountMedicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCheckWhereInput
  }


  /**
   * Count Type MedicalEventCountOutputType
   */

  export type MedicalEventCountOutputType = {
    medicationsUsed: number
    documents: number
  }

  export type MedicalEventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicationsUsed?: boolean | MedicalEventCountOutputTypeCountMedicationsUsedArgs
    documents?: boolean | MedicalEventCountOutputTypeCountDocumentsArgs
  }

  // Custom InputTypes
  /**
   * MedicalEventCountOutputType without action
   */
  export type MedicalEventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventCountOutputType
     */
    select?: MedicalEventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalEventCountOutputType without action
   */
  export type MedicalEventCountOutputTypeCountMedicationsUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventMedicationWhereInput
  }

  /**
   * MedicalEventCountOutputType without action
   */
  export type MedicalEventCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalDocumentWhereInput
  }


  /**
   * Count Type MedicationCountOutputType
   */

  export type MedicationCountOutputType = {
    studentMedications: number
    medicalEventMedications: number
    stockMovements: number
  }

  export type MedicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentMedications?: boolean | MedicationCountOutputTypeCountStudentMedicationsArgs
    medicalEventMedications?: boolean | MedicationCountOutputTypeCountMedicalEventMedicationsArgs
    stockMovements?: boolean | MedicationCountOutputTypeCountStockMovementsArgs
  }

  // Custom InputTypes
  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationCountOutputType
     */
    select?: MedicationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountStudentMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMedicationWhereInput
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountMedicalEventMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventMedicationWhereInput
  }

  /**
   * MedicationCountOutputType without action
   */
  export type MedicationCountOutputTypeCountStockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
  }


  /**
   * Count Type VaccinationCampaignCountOutputType
   */

  export type VaccinationCampaignCountOutputType = {
    vaccinations: number
    notifications: number
  }

  export type VaccinationCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinations?: boolean | VaccinationCampaignCountOutputTypeCountVaccinationsArgs
    notifications?: boolean | VaccinationCampaignCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * VaccinationCampaignCountOutputType without action
   */
  export type VaccinationCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaignCountOutputType
     */
    select?: VaccinationCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VaccinationCampaignCountOutputType without action
   */
  export type VaccinationCampaignCountOutputTypeCountVaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
  }

  /**
   * VaccinationCampaignCountOutputType without action
   */
  export type VaccinationCampaignCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type MedicalCheckCampaignCountOutputType
   */

  export type MedicalCheckCampaignCountOutputType = {
    medicalChecks: number
    notifications: number
  }

  export type MedicalCheckCampaignCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalChecks?: boolean | MedicalCheckCampaignCountOutputTypeCountMedicalChecksArgs
    notifications?: boolean | MedicalCheckCampaignCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MedicalCheckCampaignCountOutputType without action
   */
  export type MedicalCheckCampaignCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaignCountOutputType
     */
    select?: MedicalCheckCampaignCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicalCheckCampaignCountOutputType without action
   */
  export type MedicalCheckCampaignCountOutputTypeCountMedicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCheckWhereInput
  }

  /**
   * MedicalCheckCampaignCountOutputType without action
   */
  export type MedicalCheckCampaignCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    password: string | null
    email: string | null
    role: $Enums.UserRole | null
    phone: string | null
    address: string | null
    avatar: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    password: string | null
    email: string | null
    role: $Enums.UserRole | null
    phone: string | null
    address: string | null
    avatar: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    fullName: number
    password: number
    email: number
    role: number
    phone: number
    address: number
    avatar: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    fullName?: true
    password?: true
    email?: true
    role?: true
    phone?: true
    address?: true
    avatar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    fullName?: true
    password?: true
    email?: true
    role?: true
    phone?: true
    address?: true
    avatar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    fullName?: true
    password?: true
    email?: true
    role?: true
    phone?: true
    address?: true
    avatar?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    fullName: string
    password: string
    email: string
    role: $Enums.UserRole
    phone: string | null
    address: string | null
    avatar: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    avatar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentProfile?: boolean | users$studentProfileArgs<ExtArgs>
    parentProfile?: boolean | users$parentProfileArgs<ExtArgs>
    nurseProfile?: boolean | users$nurseProfileArgs<ExtArgs>
    managerProfile?: boolean | users$managerProfileArgs<ExtArgs>
    adminProfile?: boolean | users$adminProfileArgs<ExtArgs>
    createdPosts?: boolean | users$createdPostsArgs<ExtArgs>
    createdEvents?: boolean | users$createdEventsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    auditLogs?: boolean | users$auditLogsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    fullName?: boolean
    password?: boolean
    email?: boolean
    role?: boolean
    phone?: boolean
    address?: boolean
    avatar?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "password" | "email" | "role" | "phone" | "address" | "avatar" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentProfile?: boolean | users$studentProfileArgs<ExtArgs>
    parentProfile?: boolean | users$parentProfileArgs<ExtArgs>
    nurseProfile?: boolean | users$nurseProfileArgs<ExtArgs>
    managerProfile?: boolean | users$managerProfileArgs<ExtArgs>
    adminProfile?: boolean | users$adminProfileArgs<ExtArgs>
    createdPosts?: boolean | users$createdPostsArgs<ExtArgs>
    createdEvents?: boolean | users$createdEventsArgs<ExtArgs>
    notifications?: boolean | users$notificationsArgs<ExtArgs>
    auditLogs?: boolean | users$auditLogsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      studentProfile: Prisma.$StudentPayload<ExtArgs> | null
      parentProfile: Prisma.$ParentPayload<ExtArgs> | null
      nurseProfile: Prisma.$SchoolNursePayload<ExtArgs> | null
      managerProfile: Prisma.$ManagerPayload<ExtArgs> | null
      adminProfile: Prisma.$AdminPayload<ExtArgs> | null
      createdPosts: Prisma.$PostPayload<ExtArgs>[]
      createdEvents: Prisma.$MedicalEventPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      password: string
      email: string
      role: $Enums.UserRole
      phone: string | null
      address: string | null
      avatar: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentProfile<T extends users$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$studentProfileArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parentProfile<T extends users$parentProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$parentProfileArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    nurseProfile<T extends users$nurseProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$nurseProfileArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    managerProfile<T extends users$managerProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$managerProfileArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    adminProfile<T extends users$adminProfileArgs<ExtArgs> = {}>(args?: Subset<T, users$adminProfileArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdPosts<T extends users$createdPostsArgs<ExtArgs> = {}>(args?: Subset<T, users$createdPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdEvents<T extends users$createdEventsArgs<ExtArgs> = {}>(args?: Subset<T, users$createdEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends users$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends users$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, users$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly fullName: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'UserRole'>
    readonly phone: FieldRef<"users", 'String'>
    readonly address: FieldRef<"users", 'String'>
    readonly avatar: FieldRef<"users", 'String'>
    readonly isActive: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users.studentProfile
   */
  export type users$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * users.parentProfile
   */
  export type users$parentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    where?: ParentWhereInput
  }

  /**
   * users.nurseProfile
   */
  export type users$nurseProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    where?: SchoolNurseWhereInput
  }

  /**
   * users.managerProfile
   */
  export type users$managerProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * users.adminProfile
   */
  export type users$adminProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    where?: AdminWhereInput
  }

  /**
   * users.createdPosts
   */
  export type users$createdPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * users.createdEvents
   */
  export type users$createdEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    where?: MedicalEventWhereInput
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    cursor?: MedicalEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * users.notifications
   */
  export type users$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * users.auditLogs
   */
  export type users$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    studentCode: string | null
    dateOfBirth: Date | null
    gender: string | null
    class: string | null
    grade: string | null
    bloodType: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    studentCode: string | null
    dateOfBirth: Date | null
    gender: string | null
    class: string | null
    grade: string | null
    bloodType: string | null
    emergencyContact: string | null
    emergencyPhone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    studentCode: number
    dateOfBirth: number
    gender: number
    class: number
    grade: number
    bloodType: number
    emergencyContact: number
    emergencyPhone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    studentCode?: true
    dateOfBirth?: true
    gender?: true
    class?: true
    grade?: true
    bloodType?: true
    emergencyContact?: true
    emergencyPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    studentCode?: true
    dateOfBirth?: true
    gender?: true
    class?: true
    grade?: true
    bloodType?: true
    emergencyContact?: true
    emergencyPhone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    studentCode?: true
    dateOfBirth?: true
    gender?: true
    class?: true
    grade?: true
    bloodType?: true
    emergencyContact?: true
    emergencyPhone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    studentCode: string
    dateOfBirth: Date
    gender: string
    class: string
    grade: string
    bloodType: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    studentCode?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    class?: boolean
    grade?: boolean
    bloodType?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    healthProfile?: boolean | Student$healthProfileArgs<ExtArgs>
    medicalEvents?: boolean | Student$medicalEventsArgs<ExtArgs>
    vaccinations?: boolean | Student$vaccinationsArgs<ExtArgs>
    medicalChecks?: boolean | Student$medicalChecksArgs<ExtArgs>
    medications?: boolean | Student$medicationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>



  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    studentCode?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    class?: boolean
    grade?: boolean
    bloodType?: boolean
    emergencyContact?: boolean
    emergencyPhone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "studentCode" | "dateOfBirth" | "gender" | "class" | "grade" | "bloodType" | "emergencyContact" | "emergencyPhone" | "createdAt" | "updatedAt", ExtArgs["result"]["student"]>
  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    parents?: boolean | Student$parentsArgs<ExtArgs>
    healthProfile?: boolean | Student$healthProfileArgs<ExtArgs>
    medicalEvents?: boolean | Student$medicalEventsArgs<ExtArgs>
    vaccinations?: boolean | Student$vaccinationsArgs<ExtArgs>
    medicalChecks?: boolean | Student$medicalChecksArgs<ExtArgs>
    medications?: boolean | Student$medicationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      parents: Prisma.$StudentParentPayload<ExtArgs>[]
      healthProfile: Prisma.$HealthProfilePayload<ExtArgs> | null
      medicalEvents: Prisma.$MedicalEventPayload<ExtArgs>[]
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
      medicalChecks: Prisma.$MedicalCheckPayload<ExtArgs>[]
      medications: Prisma.$StudentMedicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      studentCode: string
      dateOfBirth: Date
      gender: string
      class: string
      grade: string
      bloodType: string | null
      emergencyContact: string
      emergencyPhone: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Students that matches the filter.
     * @param {StudentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const student = await prisma.student.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Student.
     * @param {StudentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const student = await prisma.student.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parents<T extends Student$parentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$parentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    healthProfile<T extends Student$healthProfileArgs<ExtArgs> = {}>(args?: Subset<T, Student$healthProfileArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medicalEvents<T extends Student$medicalEventsArgs<ExtArgs> = {}>(args?: Subset<T, Student$medicalEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vaccinations<T extends Student$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalChecks<T extends Student$medicalChecksArgs<ExtArgs> = {}>(args?: Subset<T, Student$medicalChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Student$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly studentCode: FieldRef<"Student", 'String'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly gender: FieldRef<"Student", 'String'>
    readonly class: FieldRef<"Student", 'String'>
    readonly grade: FieldRef<"Student", 'String'>
    readonly bloodType: FieldRef<"Student", 'String'>
    readonly emergencyContact: FieldRef<"Student", 'String'>
    readonly emergencyPhone: FieldRef<"Student", 'String'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to update.
     */
    limit?: number
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
    /**
     * Limit how many Students to delete.
     */
    limit?: number
  }

  /**
   * Student findRaw
   */
  export type StudentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student aggregateRaw
   */
  export type StudentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Student.parents
   */
  export type Student$parentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Student.healthProfile
   */
  export type Student$healthProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    where?: HealthProfileWhereInput
  }

  /**
   * Student.medicalEvents
   */
  export type Student$medicalEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    where?: MedicalEventWhereInput
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    cursor?: MedicalEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * Student.vaccinations
   */
  export type Student$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Student.medicalChecks
   */
  export type Student$medicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    where?: MedicalCheckWhereInput
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    cursor?: MedicalCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * Student.medications
   */
  export type Student$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    where?: StudentMedicationWhereInput
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    cursor?: StudentMedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Student
     */
    omit?: StudentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Parent
   */

  export type AggregateParent = {
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  export type ParentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    workplace: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    occupation: string | null
    workplace: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParentCountAggregateOutputType = {
    id: number
    userId: number
    occupation: number
    workplace: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParentMinAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    workplace?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentMaxAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    workplace?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParentCountAggregateInputType = {
    id?: true
    userId?: true
    occupation?: true
    workplace?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parent to aggregate.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Parents
    **/
    _count?: true | ParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParentMaxAggregateInputType
  }

  export type GetParentAggregateType<T extends ParentAggregateArgs> = {
        [P in keyof T & keyof AggregateParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParent[P]>
      : GetScalarType<T[P], AggregateParent[P]>
  }




  export type ParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParentWhereInput
    orderBy?: ParentOrderByWithAggregationInput | ParentOrderByWithAggregationInput[]
    by: ParentScalarFieldEnum[] | ParentScalarFieldEnum
    having?: ParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParentCountAggregateInputType | true
    _min?: ParentMinAggregateInputType
    _max?: ParentMaxAggregateInputType
  }

  export type ParentGroupByOutputType = {
    id: string
    userId: string
    occupation: string | null
    workplace: string | null
    createdAt: Date
    updatedAt: Date
    _count: ParentCountAggregateOutputType | null
    _min: ParentMinAggregateOutputType | null
    _max: ParentMaxAggregateOutputType | null
  }

  type GetParentGroupByPayload<T extends ParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParentGroupByOutputType[P]>
            : GetScalarType<T[P], ParentGroupByOutputType[P]>
        }
      >
    >


  export type ParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    occupation?: boolean
    workplace?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    medications?: boolean | Parent$medicationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["parent"]>



  export type ParentSelectScalar = {
    id?: boolean
    userId?: boolean
    occupation?: boolean
    workplace?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "occupation" | "workplace" | "createdAt" | "updatedAt", ExtArgs["result"]["parent"]>
  export type ParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    children?: boolean | Parent$childrenArgs<ExtArgs>
    medications?: boolean | Parent$medicationsArgs<ExtArgs>
    _count?: boolean | ParentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Parent"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      children: Prisma.$StudentParentPayload<ExtArgs>[]
      medications: Prisma.$StudentMedicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      occupation: string | null
      workplace: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["parent"]>
    composites: {}
  }

  type ParentGetPayload<S extends boolean | null | undefined | ParentDefaultArgs> = $Result.GetResult<Prisma.$ParentPayload, S>

  type ParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParentCountAggregateInputType | true
    }

  export interface ParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Parent'], meta: { name: 'Parent' } }
    /**
     * Find zero or one Parent that matches the filter.
     * @param {ParentFindUniqueArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParentFindUniqueArgs>(args: SelectSubset<T, ParentFindUniqueArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Parent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParentFindUniqueOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParentFindUniqueOrThrowArgs>(args: SelectSubset<T, ParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParentFindFirstArgs>(args?: SelectSubset<T, ParentFindFirstArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Parent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindFirstOrThrowArgs} args - Arguments to find a Parent
     * @example
     * // Get one Parent
     * const parent = await prisma.parent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParentFindFirstOrThrowArgs>(args?: SelectSubset<T, ParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parents
     * const parents = await prisma.parent.findMany()
     * 
     * // Get first 10 Parents
     * const parents = await prisma.parent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parentWithIdOnly = await prisma.parent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParentFindManyArgs>(args?: SelectSubset<T, ParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Parent.
     * @param {ParentCreateArgs} args - Arguments to create a Parent.
     * @example
     * // Create one Parent
     * const Parent = await prisma.parent.create({
     *   data: {
     *     // ... data to create a Parent
     *   }
     * })
     * 
     */
    create<T extends ParentCreateArgs>(args: SelectSubset<T, ParentCreateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Parents.
     * @param {ParentCreateManyArgs} args - Arguments to create many Parents.
     * @example
     * // Create many Parents
     * const parent = await prisma.parent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParentCreateManyArgs>(args?: SelectSubset<T, ParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Parent.
     * @param {ParentDeleteArgs} args - Arguments to delete one Parent.
     * @example
     * // Delete one Parent
     * const Parent = await prisma.parent.delete({
     *   where: {
     *     // ... filter to delete one Parent
     *   }
     * })
     * 
     */
    delete<T extends ParentDeleteArgs>(args: SelectSubset<T, ParentDeleteArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Parent.
     * @param {ParentUpdateArgs} args - Arguments to update one Parent.
     * @example
     * // Update one Parent
     * const parent = await prisma.parent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParentUpdateArgs>(args: SelectSubset<T, ParentUpdateArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Parents.
     * @param {ParentDeleteManyArgs} args - Arguments to filter Parents to delete.
     * @example
     * // Delete a few Parents
     * const { count } = await prisma.parent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParentDeleteManyArgs>(args?: SelectSubset<T, ParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parents
     * const parent = await prisma.parent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParentUpdateManyArgs>(args: SelectSubset<T, ParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parent.
     * @param {ParentUpsertArgs} args - Arguments to update or create a Parent.
     * @example
     * // Update or create a Parent
     * const parent = await prisma.parent.upsert({
     *   create: {
     *     // ... data to create a Parent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parent we want to update
     *   }
     * })
     */
    upsert<T extends ParentUpsertArgs>(args: SelectSubset<T, ParentUpsertArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Parents that matches the filter.
     * @param {ParentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const parent = await prisma.parent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ParentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Parent.
     * @param {ParentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const parent = await prisma.parent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ParentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Parents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentCountArgs} args - Arguments to filter Parents to count.
     * @example
     * // Count the number of Parents
     * const count = await prisma.parent.count({
     *   where: {
     *     // ... the filter for the Parents we want to count
     *   }
     * })
    **/
    count<T extends ParentCountArgs>(
      args?: Subset<T, ParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParentAggregateArgs>(args: Subset<T, ParentAggregateArgs>): Prisma.PrismaPromise<GetParentAggregateType<T>>

    /**
     * Group by Parent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParentGroupByArgs['orderBy'] }
        : { orderBy?: ParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Parent model
   */
  readonly fields: ParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Parent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    children<T extends Parent$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Parent$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medications<T extends Parent$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Parent$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Parent model
   */
  interface ParentFieldRefs {
    readonly id: FieldRef<"Parent", 'String'>
    readonly userId: FieldRef<"Parent", 'String'>
    readonly occupation: FieldRef<"Parent", 'String'>
    readonly workplace: FieldRef<"Parent", 'String'>
    readonly createdAt: FieldRef<"Parent", 'DateTime'>
    readonly updatedAt: FieldRef<"Parent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Parent findUnique
   */
  export type ParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findUniqueOrThrow
   */
  export type ParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent findFirst
   */
  export type ParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findFirstOrThrow
   */
  export type ParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parent to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Parents.
     */
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent findMany
   */
  export type ParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter, which Parents to fetch.
     */
    where?: ParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Parents to fetch.
     */
    orderBy?: ParentOrderByWithRelationInput | ParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Parents.
     */
    cursor?: ParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Parents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Parents.
     */
    skip?: number
    distinct?: ParentScalarFieldEnum | ParentScalarFieldEnum[]
  }

  /**
   * Parent create
   */
  export type ParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to create a Parent.
     */
    data: XOR<ParentCreateInput, ParentUncheckedCreateInput>
  }

  /**
   * Parent createMany
   */
  export type ParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Parents.
     */
    data: ParentCreateManyInput | ParentCreateManyInput[]
  }

  /**
   * Parent update
   */
  export type ParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The data needed to update a Parent.
     */
    data: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
    /**
     * Choose, which Parent to update.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent updateMany
   */
  export type ParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Parents.
     */
    data: XOR<ParentUpdateManyMutationInput, ParentUncheckedUpdateManyInput>
    /**
     * Filter which Parents to update
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to update.
     */
    limit?: number
  }

  /**
   * Parent upsert
   */
  export type ParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * The filter to search for the Parent to update in case it exists.
     */
    where: ParentWhereUniqueInput
    /**
     * In case the Parent found by the `where` argument doesn't exist, create a new Parent with this data.
     */
    create: XOR<ParentCreateInput, ParentUncheckedCreateInput>
    /**
     * In case the Parent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParentUpdateInput, ParentUncheckedUpdateInput>
  }

  /**
   * Parent delete
   */
  export type ParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
    /**
     * Filter which Parent to delete.
     */
    where: ParentWhereUniqueInput
  }

  /**
   * Parent deleteMany
   */
  export type ParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Parents to delete
     */
    where?: ParentWhereInput
    /**
     * Limit how many Parents to delete.
     */
    limit?: number
  }

  /**
   * Parent findRaw
   */
  export type ParentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parent aggregateRaw
   */
  export type ParentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Parent.children
   */
  export type Parent$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    cursor?: StudentParentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * Parent.medications
   */
  export type Parent$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    where?: StudentMedicationWhereInput
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    cursor?: StudentMedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * Parent without action
   */
  export type ParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Parent
     */
    select?: ParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Parent
     */
    omit?: ParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParentInclude<ExtArgs> | null
  }


  /**
   * Model SchoolNurse
   */

  export type AggregateSchoolNurse = {
    _count: SchoolNurseCountAggregateOutputType | null
    _avg: SchoolNurseAvgAggregateOutputType | null
    _sum: SchoolNurseSumAggregateOutputType | null
    _min: SchoolNurseMinAggregateOutputType | null
    _max: SchoolNurseMaxAggregateOutputType | null
  }

  export type SchoolNurseAvgAggregateOutputType = {
    experience: number | null
  }

  export type SchoolNurseSumAggregateOutputType = {
    experience: number | null
  }

  export type SchoolNurseMinAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseNumber: string | null
    specialization: string | null
    experience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolNurseMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    licenseNumber: string | null
    specialization: string | null
    experience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolNurseCountAggregateOutputType = {
    id: number
    userId: number
    licenseNumber: number
    specialization: number
    experience: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolNurseAvgAggregateInputType = {
    experience?: true
  }

  export type SchoolNurseSumAggregateInputType = {
    experience?: true
  }

  export type SchoolNurseMinAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    specialization?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolNurseMaxAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    specialization?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolNurseCountAggregateInputType = {
    id?: true
    userId?: true
    licenseNumber?: true
    specialization?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolNurseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolNurse to aggregate.
     */
    where?: SchoolNurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolNurses to fetch.
     */
    orderBy?: SchoolNurseOrderByWithRelationInput | SchoolNurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolNurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolNurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolNurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolNurses
    **/
    _count?: true | SchoolNurseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolNurseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolNurseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolNurseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolNurseMaxAggregateInputType
  }

  export type GetSchoolNurseAggregateType<T extends SchoolNurseAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolNurse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolNurse[P]>
      : GetScalarType<T[P], AggregateSchoolNurse[P]>
  }




  export type SchoolNurseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolNurseWhereInput
    orderBy?: SchoolNurseOrderByWithAggregationInput | SchoolNurseOrderByWithAggregationInput[]
    by: SchoolNurseScalarFieldEnum[] | SchoolNurseScalarFieldEnum
    having?: SchoolNurseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolNurseCountAggregateInputType | true
    _avg?: SchoolNurseAvgAggregateInputType
    _sum?: SchoolNurseSumAggregateInputType
    _min?: SchoolNurseMinAggregateInputType
    _max?: SchoolNurseMaxAggregateInputType
  }

  export type SchoolNurseGroupByOutputType = {
    id: string
    userId: string
    licenseNumber: string
    specialization: string | null
    experience: number | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolNurseCountAggregateOutputType | null
    _avg: SchoolNurseAvgAggregateOutputType | null
    _sum: SchoolNurseSumAggregateOutputType | null
    _min: SchoolNurseMinAggregateOutputType | null
    _max: SchoolNurseMaxAggregateOutputType | null
  }

  type GetSchoolNurseGroupByPayload<T extends SchoolNurseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolNurseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolNurseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolNurseGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolNurseGroupByOutputType[P]>
        }
      >
    >


  export type SchoolNurseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    specialization?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    handledEvents?: boolean | SchoolNurse$handledEventsArgs<ExtArgs>
    vaccinations?: boolean | SchoolNurse$vaccinationsArgs<ExtArgs>
    medicalChecks?: boolean | SchoolNurse$medicalChecksArgs<ExtArgs>
    _count?: boolean | SchoolNurseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolNurse"]>



  export type SchoolNurseSelectScalar = {
    id?: boolean
    userId?: boolean
    licenseNumber?: boolean
    specialization?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolNurseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "licenseNumber" | "specialization" | "experience" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolNurse"]>
  export type SchoolNurseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    handledEvents?: boolean | SchoolNurse$handledEventsArgs<ExtArgs>
    vaccinations?: boolean | SchoolNurse$vaccinationsArgs<ExtArgs>
    medicalChecks?: boolean | SchoolNurse$medicalChecksArgs<ExtArgs>
    _count?: boolean | SchoolNurseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SchoolNursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolNurse"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      handledEvents: Prisma.$MedicalEventPayload<ExtArgs>[]
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
      medicalChecks: Prisma.$MedicalCheckPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      licenseNumber: string
      specialization: string | null
      experience: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolNurse"]>
    composites: {}
  }

  type SchoolNurseGetPayload<S extends boolean | null | undefined | SchoolNurseDefaultArgs> = $Result.GetResult<Prisma.$SchoolNursePayload, S>

  type SchoolNurseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolNurseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolNurseCountAggregateInputType | true
    }

  export interface SchoolNurseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolNurse'], meta: { name: 'SchoolNurse' } }
    /**
     * Find zero or one SchoolNurse that matches the filter.
     * @param {SchoolNurseFindUniqueArgs} args - Arguments to find a SchoolNurse
     * @example
     * // Get one SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolNurseFindUniqueArgs>(args: SelectSubset<T, SchoolNurseFindUniqueArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolNurse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolNurseFindUniqueOrThrowArgs} args - Arguments to find a SchoolNurse
     * @example
     * // Get one SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolNurseFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolNurseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolNurse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseFindFirstArgs} args - Arguments to find a SchoolNurse
     * @example
     * // Get one SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolNurseFindFirstArgs>(args?: SelectSubset<T, SchoolNurseFindFirstArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolNurse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseFindFirstOrThrowArgs} args - Arguments to find a SchoolNurse
     * @example
     * // Get one SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolNurseFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolNurseFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolNurses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolNurses
     * const schoolNurses = await prisma.schoolNurse.findMany()
     * 
     * // Get first 10 SchoolNurses
     * const schoolNurses = await prisma.schoolNurse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolNurseWithIdOnly = await prisma.schoolNurse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolNurseFindManyArgs>(args?: SelectSubset<T, SchoolNurseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolNurse.
     * @param {SchoolNurseCreateArgs} args - Arguments to create a SchoolNurse.
     * @example
     * // Create one SchoolNurse
     * const SchoolNurse = await prisma.schoolNurse.create({
     *   data: {
     *     // ... data to create a SchoolNurse
     *   }
     * })
     * 
     */
    create<T extends SchoolNurseCreateArgs>(args: SelectSubset<T, SchoolNurseCreateArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolNurses.
     * @param {SchoolNurseCreateManyArgs} args - Arguments to create many SchoolNurses.
     * @example
     * // Create many SchoolNurses
     * const schoolNurse = await prisma.schoolNurse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolNurseCreateManyArgs>(args?: SelectSubset<T, SchoolNurseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolNurse.
     * @param {SchoolNurseDeleteArgs} args - Arguments to delete one SchoolNurse.
     * @example
     * // Delete one SchoolNurse
     * const SchoolNurse = await prisma.schoolNurse.delete({
     *   where: {
     *     // ... filter to delete one SchoolNurse
     *   }
     * })
     * 
     */
    delete<T extends SchoolNurseDeleteArgs>(args: SelectSubset<T, SchoolNurseDeleteArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolNurse.
     * @param {SchoolNurseUpdateArgs} args - Arguments to update one SchoolNurse.
     * @example
     * // Update one SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolNurseUpdateArgs>(args: SelectSubset<T, SchoolNurseUpdateArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolNurses.
     * @param {SchoolNurseDeleteManyArgs} args - Arguments to filter SchoolNurses to delete.
     * @example
     * // Delete a few SchoolNurses
     * const { count } = await prisma.schoolNurse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolNurseDeleteManyArgs>(args?: SelectSubset<T, SchoolNurseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolNurses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolNurses
     * const schoolNurse = await prisma.schoolNurse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolNurseUpdateManyArgs>(args: SelectSubset<T, SchoolNurseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolNurse.
     * @param {SchoolNurseUpsertArgs} args - Arguments to update or create a SchoolNurse.
     * @example
     * // Update or create a SchoolNurse
     * const schoolNurse = await prisma.schoolNurse.upsert({
     *   create: {
     *     // ... data to create a SchoolNurse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolNurse we want to update
     *   }
     * })
     */
    upsert<T extends SchoolNurseUpsertArgs>(args: SelectSubset<T, SchoolNurseUpsertArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolNurses that matches the filter.
     * @param {SchoolNurseFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schoolNurse = await prisma.schoolNurse.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SchoolNurseFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SchoolNurse.
     * @param {SchoolNurseAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schoolNurse = await prisma.schoolNurse.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SchoolNurseAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SchoolNurses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseCountArgs} args - Arguments to filter SchoolNurses to count.
     * @example
     * // Count the number of SchoolNurses
     * const count = await prisma.schoolNurse.count({
     *   where: {
     *     // ... the filter for the SchoolNurses we want to count
     *   }
     * })
    **/
    count<T extends SchoolNurseCountArgs>(
      args?: Subset<T, SchoolNurseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolNurseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolNurse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolNurseAggregateArgs>(args: Subset<T, SchoolNurseAggregateArgs>): Prisma.PrismaPromise<GetSchoolNurseAggregateType<T>>

    /**
     * Group by SchoolNurse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolNurseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolNurseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolNurseGroupByArgs['orderBy'] }
        : { orderBy?: SchoolNurseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolNurseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolNurseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolNurse model
   */
  readonly fields: SchoolNurseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolNurse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolNurseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    handledEvents<T extends SchoolNurse$handledEventsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolNurse$handledEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vaccinations<T extends SchoolNurse$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, SchoolNurse$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalChecks<T extends SchoolNurse$medicalChecksArgs<ExtArgs> = {}>(args?: Subset<T, SchoolNurse$medicalChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolNurse model
   */
  interface SchoolNurseFieldRefs {
    readonly id: FieldRef<"SchoolNurse", 'String'>
    readonly userId: FieldRef<"SchoolNurse", 'String'>
    readonly licenseNumber: FieldRef<"SchoolNurse", 'String'>
    readonly specialization: FieldRef<"SchoolNurse", 'String'>
    readonly experience: FieldRef<"SchoolNurse", 'Int'>
    readonly createdAt: FieldRef<"SchoolNurse", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolNurse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolNurse findUnique
   */
  export type SchoolNurseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter, which SchoolNurse to fetch.
     */
    where: SchoolNurseWhereUniqueInput
  }

  /**
   * SchoolNurse findUniqueOrThrow
   */
  export type SchoolNurseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter, which SchoolNurse to fetch.
     */
    where: SchoolNurseWhereUniqueInput
  }

  /**
   * SchoolNurse findFirst
   */
  export type SchoolNurseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter, which SchoolNurse to fetch.
     */
    where?: SchoolNurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolNurses to fetch.
     */
    orderBy?: SchoolNurseOrderByWithRelationInput | SchoolNurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolNurses.
     */
    cursor?: SchoolNurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolNurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolNurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolNurses.
     */
    distinct?: SchoolNurseScalarFieldEnum | SchoolNurseScalarFieldEnum[]
  }

  /**
   * SchoolNurse findFirstOrThrow
   */
  export type SchoolNurseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter, which SchoolNurse to fetch.
     */
    where?: SchoolNurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolNurses to fetch.
     */
    orderBy?: SchoolNurseOrderByWithRelationInput | SchoolNurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolNurses.
     */
    cursor?: SchoolNurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolNurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolNurses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolNurses.
     */
    distinct?: SchoolNurseScalarFieldEnum | SchoolNurseScalarFieldEnum[]
  }

  /**
   * SchoolNurse findMany
   */
  export type SchoolNurseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter, which SchoolNurses to fetch.
     */
    where?: SchoolNurseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolNurses to fetch.
     */
    orderBy?: SchoolNurseOrderByWithRelationInput | SchoolNurseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolNurses.
     */
    cursor?: SchoolNurseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolNurses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolNurses.
     */
    skip?: number
    distinct?: SchoolNurseScalarFieldEnum | SchoolNurseScalarFieldEnum[]
  }

  /**
   * SchoolNurse create
   */
  export type SchoolNurseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolNurse.
     */
    data: XOR<SchoolNurseCreateInput, SchoolNurseUncheckedCreateInput>
  }

  /**
   * SchoolNurse createMany
   */
  export type SchoolNurseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolNurses.
     */
    data: SchoolNurseCreateManyInput | SchoolNurseCreateManyInput[]
  }

  /**
   * SchoolNurse update
   */
  export type SchoolNurseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolNurse.
     */
    data: XOR<SchoolNurseUpdateInput, SchoolNurseUncheckedUpdateInput>
    /**
     * Choose, which SchoolNurse to update.
     */
    where: SchoolNurseWhereUniqueInput
  }

  /**
   * SchoolNurse updateMany
   */
  export type SchoolNurseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolNurses.
     */
    data: XOR<SchoolNurseUpdateManyMutationInput, SchoolNurseUncheckedUpdateManyInput>
    /**
     * Filter which SchoolNurses to update
     */
    where?: SchoolNurseWhereInput
    /**
     * Limit how many SchoolNurses to update.
     */
    limit?: number
  }

  /**
   * SchoolNurse upsert
   */
  export type SchoolNurseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolNurse to update in case it exists.
     */
    where: SchoolNurseWhereUniqueInput
    /**
     * In case the SchoolNurse found by the `where` argument doesn't exist, create a new SchoolNurse with this data.
     */
    create: XOR<SchoolNurseCreateInput, SchoolNurseUncheckedCreateInput>
    /**
     * In case the SchoolNurse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolNurseUpdateInput, SchoolNurseUncheckedUpdateInput>
  }

  /**
   * SchoolNurse delete
   */
  export type SchoolNurseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    /**
     * Filter which SchoolNurse to delete.
     */
    where: SchoolNurseWhereUniqueInput
  }

  /**
   * SchoolNurse deleteMany
   */
  export type SchoolNurseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolNurses to delete
     */
    where?: SchoolNurseWhereInput
    /**
     * Limit how many SchoolNurses to delete.
     */
    limit?: number
  }

  /**
   * SchoolNurse findRaw
   */
  export type SchoolNurseFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SchoolNurse aggregateRaw
   */
  export type SchoolNurseAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SchoolNurse.handledEvents
   */
  export type SchoolNurse$handledEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    where?: MedicalEventWhereInput
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    cursor?: MedicalEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * SchoolNurse.vaccinations
   */
  export type SchoolNurse$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * SchoolNurse.medicalChecks
   */
  export type SchoolNurse$medicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    where?: MedicalCheckWhereInput
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    cursor?: MedicalCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * SchoolNurse without action
   */
  export type SchoolNurseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerMinAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    department: string | null
    position: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    userId: number
    department: number
    position: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ManagerMinAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    position?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    position?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: string
    userId: string
    department: string | null
    position: string | null
    createdAt: Date
    updatedAt: Date
    _count: ManagerCountAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>



  export type ManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    department?: boolean
    position?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ManagerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "department" | "position" | "createdAt" | "updatedAt", ExtArgs["result"]["manager"]>
  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      department: string | null
      position: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Managers that matches the filter.
     * @param {ManagerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const manager = await prisma.manager.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ManagerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Manager.
     * @param {ManagerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const manager = await prisma.manager.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ManagerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'String'>
    readonly userId: FieldRef<"Manager", 'String'>
    readonly department: FieldRef<"Manager", 'String'>
    readonly position: FieldRef<"Manager", 'String'>
    readonly createdAt: FieldRef<"Manager", 'DateTime'>
    readonly updatedAt: FieldRef<"Manager", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to update.
     */
    limit?: number
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
    /**
     * Limit how many Managers to delete.
     */
    limit?: number
  }

  /**
   * Manager findRaw
   */
  export type ManagerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Manager aggregateRaw
   */
  export type ManagerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Manager
     */
    omit?: ManagerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Admin
   */

  export type AggregateAdmin = {
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  export type AdminMinAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminCountAggregateOutputType = {
    id: number
    userId: number
    permissions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminMinAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminMaxAggregateInputType = {
    id?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminCountAggregateInputType = {
    id?: true
    userId?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admin to aggregate.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Admins
    **/
    _count?: true | AdminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminMaxAggregateInputType
  }

  export type GetAdminAggregateType<T extends AdminAggregateArgs> = {
        [P in keyof T & keyof AggregateAdmin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdmin[P]>
      : GetScalarType<T[P], AggregateAdmin[P]>
  }




  export type AdminGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminWhereInput
    orderBy?: AdminOrderByWithAggregationInput | AdminOrderByWithAggregationInput[]
    by: AdminScalarFieldEnum[] | AdminScalarFieldEnum
    having?: AdminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminCountAggregateInputType | true
    _min?: AdminMinAggregateInputType
    _max?: AdminMaxAggregateInputType
  }

  export type AdminGroupByOutputType = {
    id: string
    userId: string
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    _count: AdminCountAggregateOutputType | null
    _min: AdminMinAggregateOutputType | null
    _max: AdminMaxAggregateOutputType | null
  }

  type GetAdminGroupByPayload<T extends AdminGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminGroupByOutputType[P]>
            : GetScalarType<T[P], AdminGroupByOutputType[P]>
        }
      >
    >


  export type AdminSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["admin"]>



  export type AdminSelectScalar = {
    id?: boolean
    userId?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "permissions" | "createdAt" | "updatedAt", ExtArgs["result"]["admin"]>
  export type AdminInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $AdminPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Admin"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      permissions: string[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["admin"]>
    composites: {}
  }

  type AdminGetPayload<S extends boolean | null | undefined | AdminDefaultArgs> = $Result.GetResult<Prisma.$AdminPayload, S>

  type AdminCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminCountAggregateInputType | true
    }

  export interface AdminDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Admin'], meta: { name: 'Admin' } }
    /**
     * Find zero or one Admin that matches the filter.
     * @param {AdminFindUniqueArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminFindUniqueArgs>(args: SelectSubset<T, AdminFindUniqueArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Admin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminFindUniqueOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminFindFirstArgs>(args?: SelectSubset<T, AdminFindFirstArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Admin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindFirstOrThrowArgs} args - Arguments to find a Admin
     * @example
     * // Get one Admin
     * const admin = await prisma.admin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Admins
     * const admins = await prisma.admin.findMany()
     * 
     * // Get first 10 Admins
     * const admins = await prisma.admin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminWithIdOnly = await prisma.admin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminFindManyArgs>(args?: SelectSubset<T, AdminFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Admin.
     * @param {AdminCreateArgs} args - Arguments to create a Admin.
     * @example
     * // Create one Admin
     * const Admin = await prisma.admin.create({
     *   data: {
     *     // ... data to create a Admin
     *   }
     * })
     * 
     */
    create<T extends AdminCreateArgs>(args: SelectSubset<T, AdminCreateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Admins.
     * @param {AdminCreateManyArgs} args - Arguments to create many Admins.
     * @example
     * // Create many Admins
     * const admin = await prisma.admin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminCreateManyArgs>(args?: SelectSubset<T, AdminCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Admin.
     * @param {AdminDeleteArgs} args - Arguments to delete one Admin.
     * @example
     * // Delete one Admin
     * const Admin = await prisma.admin.delete({
     *   where: {
     *     // ... filter to delete one Admin
     *   }
     * })
     * 
     */
    delete<T extends AdminDeleteArgs>(args: SelectSubset<T, AdminDeleteArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Admin.
     * @param {AdminUpdateArgs} args - Arguments to update one Admin.
     * @example
     * // Update one Admin
     * const admin = await prisma.admin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUpdateArgs>(args: SelectSubset<T, AdminUpdateArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Admins.
     * @param {AdminDeleteManyArgs} args - Arguments to filter Admins to delete.
     * @example
     * // Delete a few Admins
     * const { count } = await prisma.admin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminDeleteManyArgs>(args?: SelectSubset<T, AdminDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Admins
     * const admin = await prisma.admin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUpdateManyArgs>(args: SelectSubset<T, AdminUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Admin.
     * @param {AdminUpsertArgs} args - Arguments to update or create a Admin.
     * @example
     * // Update or create a Admin
     * const admin = await prisma.admin.upsert({
     *   create: {
     *     // ... data to create a Admin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Admin we want to update
     *   }
     * })
     */
    upsert<T extends AdminUpsertArgs>(args: SelectSubset<T, AdminUpsertArgs<ExtArgs>>): Prisma__AdminClient<$Result.GetResult<Prisma.$AdminPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Admins that matches the filter.
     * @param {AdminFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const admin = await prisma.admin.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AdminFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Admin.
     * @param {AdminAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const admin = await prisma.admin.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AdminAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Admins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminCountArgs} args - Arguments to filter Admins to count.
     * @example
     * // Count the number of Admins
     * const count = await prisma.admin.count({
     *   where: {
     *     // ... the filter for the Admins we want to count
     *   }
     * })
    **/
    count<T extends AdminCountArgs>(
      args?: Subset<T, AdminCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAggregateArgs>(args: Subset<T, AdminAggregateArgs>): Prisma.PrismaPromise<GetAdminAggregateType<T>>

    /**
     * Group by Admin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminGroupByArgs['orderBy'] }
        : { orderBy?: AdminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Admin model
   */
  readonly fields: AdminFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Admin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Admin model
   */
  interface AdminFieldRefs {
    readonly id: FieldRef<"Admin", 'String'>
    readonly userId: FieldRef<"Admin", 'String'>
    readonly permissions: FieldRef<"Admin", 'String[]'>
    readonly createdAt: FieldRef<"Admin", 'DateTime'>
    readonly updatedAt: FieldRef<"Admin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Admin findUnique
   */
  export type AdminFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findUniqueOrThrow
   */
  export type AdminFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin findFirst
   */
  export type AdminFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findFirstOrThrow
   */
  export type AdminFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admin to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Admins.
     */
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin findMany
   */
  export type AdminFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter, which Admins to fetch.
     */
    where?: AdminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Admins to fetch.
     */
    orderBy?: AdminOrderByWithRelationInput | AdminOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Admins.
     */
    cursor?: AdminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Admins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Admins.
     */
    skip?: number
    distinct?: AdminScalarFieldEnum | AdminScalarFieldEnum[]
  }

  /**
   * Admin create
   */
  export type AdminCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to create a Admin.
     */
    data: XOR<AdminCreateInput, AdminUncheckedCreateInput>
  }

  /**
   * Admin createMany
   */
  export type AdminCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Admins.
     */
    data: AdminCreateManyInput | AdminCreateManyInput[]
  }

  /**
   * Admin update
   */
  export type AdminUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The data needed to update a Admin.
     */
    data: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
    /**
     * Choose, which Admin to update.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin updateMany
   */
  export type AdminUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Admins.
     */
    data: XOR<AdminUpdateManyMutationInput, AdminUncheckedUpdateManyInput>
    /**
     * Filter which Admins to update
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to update.
     */
    limit?: number
  }

  /**
   * Admin upsert
   */
  export type AdminUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * The filter to search for the Admin to update in case it exists.
     */
    where: AdminWhereUniqueInput
    /**
     * In case the Admin found by the `where` argument doesn't exist, create a new Admin with this data.
     */
    create: XOR<AdminCreateInput, AdminUncheckedCreateInput>
    /**
     * In case the Admin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUpdateInput, AdminUncheckedUpdateInput>
  }

  /**
   * Admin delete
   */
  export type AdminDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
    /**
     * Filter which Admin to delete.
     */
    where: AdminWhereUniqueInput
  }

  /**
   * Admin deleteMany
   */
  export type AdminDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Admins to delete
     */
    where?: AdminWhereInput
    /**
     * Limit how many Admins to delete.
     */
    limit?: number
  }

  /**
   * Admin findRaw
   */
  export type AdminFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Admin aggregateRaw
   */
  export type AdminAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Admin without action
   */
  export type AdminDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Admin
     */
    select?: AdminSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Admin
     */
    omit?: AdminOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminInclude<ExtArgs> | null
  }


  /**
   * Model StudentParent
   */

  export type AggregateStudentParent = {
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  export type StudentParentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationship: string | null
    isPrimary: boolean | null
  }

  export type StudentParentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    relationship: string | null
    isPrimary: boolean | null
  }

  export type StudentParentCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    relationship: number
    isPrimary: number
    _all: number
  }


  export type StudentParentMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
  }

  export type StudentParentMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
  }

  export type StudentParentCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    relationship?: true
    isPrimary?: true
    _all?: true
  }

  export type StudentParentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParent to aggregate.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentParents
    **/
    _count?: true | StudentParentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentParentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentParentMaxAggregateInputType
  }

  export type GetStudentParentAggregateType<T extends StudentParentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentParent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentParent[P]>
      : GetScalarType<T[P], AggregateStudentParent[P]>
  }




  export type StudentParentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentParentWhereInput
    orderBy?: StudentParentOrderByWithAggregationInput | StudentParentOrderByWithAggregationInput[]
    by: StudentParentScalarFieldEnum[] | StudentParentScalarFieldEnum
    having?: StudentParentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentParentCountAggregateInputType | true
    _min?: StudentParentMinAggregateInputType
    _max?: StudentParentMaxAggregateInputType
  }

  export type StudentParentGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    relationship: string
    isPrimary: boolean
    _count: StudentParentCountAggregateOutputType | null
    _min: StudentParentMinAggregateOutputType | null
    _max: StudentParentMaxAggregateOutputType | null
  }

  type GetStudentParentGroupByPayload<T extends StudentParentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentParentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentParentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentParentGroupByOutputType[P]>
        }
      >
    >


  export type StudentParentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentParent"]>



  export type StudentParentSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    relationship?: boolean
    isPrimary?: boolean
  }

  export type StudentParentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "parentId" | "relationship" | "isPrimary", ExtArgs["result"]["studentParent"]>
  export type StudentParentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
  }

  export type $StudentParentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentParent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      relationship: string
      isPrimary: boolean
    }, ExtArgs["result"]["studentParent"]>
    composites: {}
  }

  type StudentParentGetPayload<S extends boolean | null | undefined | StudentParentDefaultArgs> = $Result.GetResult<Prisma.$StudentParentPayload, S>

  type StudentParentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentParentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentParentCountAggregateInputType | true
    }

  export interface StudentParentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentParent'], meta: { name: 'StudentParent' } }
    /**
     * Find zero or one StudentParent that matches the filter.
     * @param {StudentParentFindUniqueArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentParentFindUniqueArgs>(args: SelectSubset<T, StudentParentFindUniqueArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentParent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentParentFindUniqueOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentParentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentParentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentParentFindFirstArgs>(args?: SelectSubset<T, StudentParentFindFirstArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentParent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindFirstOrThrowArgs} args - Arguments to find a StudentParent
     * @example
     * // Get one StudentParent
     * const studentParent = await prisma.studentParent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentParentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentParentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentParents
     * const studentParents = await prisma.studentParent.findMany()
     * 
     * // Get first 10 StudentParents
     * const studentParents = await prisma.studentParent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentParentWithIdOnly = await prisma.studentParent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentParentFindManyArgs>(args?: SelectSubset<T, StudentParentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentParent.
     * @param {StudentParentCreateArgs} args - Arguments to create a StudentParent.
     * @example
     * // Create one StudentParent
     * const StudentParent = await prisma.studentParent.create({
     *   data: {
     *     // ... data to create a StudentParent
     *   }
     * })
     * 
     */
    create<T extends StudentParentCreateArgs>(args: SelectSubset<T, StudentParentCreateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentParents.
     * @param {StudentParentCreateManyArgs} args - Arguments to create many StudentParents.
     * @example
     * // Create many StudentParents
     * const studentParent = await prisma.studentParent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentParentCreateManyArgs>(args?: SelectSubset<T, StudentParentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentParent.
     * @param {StudentParentDeleteArgs} args - Arguments to delete one StudentParent.
     * @example
     * // Delete one StudentParent
     * const StudentParent = await prisma.studentParent.delete({
     *   where: {
     *     // ... filter to delete one StudentParent
     *   }
     * })
     * 
     */
    delete<T extends StudentParentDeleteArgs>(args: SelectSubset<T, StudentParentDeleteArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentParent.
     * @param {StudentParentUpdateArgs} args - Arguments to update one StudentParent.
     * @example
     * // Update one StudentParent
     * const studentParent = await prisma.studentParent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentParentUpdateArgs>(args: SelectSubset<T, StudentParentUpdateArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentParents.
     * @param {StudentParentDeleteManyArgs} args - Arguments to filter StudentParents to delete.
     * @example
     * // Delete a few StudentParents
     * const { count } = await prisma.studentParent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentParentDeleteManyArgs>(args?: SelectSubset<T, StudentParentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentParents
     * const studentParent = await prisma.studentParent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentParentUpdateManyArgs>(args: SelectSubset<T, StudentParentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentParent.
     * @param {StudentParentUpsertArgs} args - Arguments to update or create a StudentParent.
     * @example
     * // Update or create a StudentParent
     * const studentParent = await prisma.studentParent.upsert({
     *   create: {
     *     // ... data to create a StudentParent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentParent we want to update
     *   }
     * })
     */
    upsert<T extends StudentParentUpsertArgs>(args: SelectSubset<T, StudentParentUpsertArgs<ExtArgs>>): Prisma__StudentParentClient<$Result.GetResult<Prisma.$StudentParentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentParents that matches the filter.
     * @param {StudentParentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const studentParent = await prisma.studentParent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentParentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a StudentParent.
     * @param {StudentParentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const studentParent = await prisma.studentParent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentParentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of StudentParents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentCountArgs} args - Arguments to filter StudentParents to count.
     * @example
     * // Count the number of StudentParents
     * const count = await prisma.studentParent.count({
     *   where: {
     *     // ... the filter for the StudentParents we want to count
     *   }
     * })
    **/
    count<T extends StudentParentCountArgs>(
      args?: Subset<T, StudentParentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentParentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentParentAggregateArgs>(args: Subset<T, StudentParentAggregateArgs>): Prisma.PrismaPromise<GetStudentParentAggregateType<T>>

    /**
     * Group by StudentParent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentParentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentParentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentParentGroupByArgs['orderBy'] }
        : { orderBy?: StudentParentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentParentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentParentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentParent model
   */
  readonly fields: StudentParentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentParent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentParentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentParent model
   */
  interface StudentParentFieldRefs {
    readonly id: FieldRef<"StudentParent", 'String'>
    readonly studentId: FieldRef<"StudentParent", 'String'>
    readonly parentId: FieldRef<"StudentParent", 'String'>
    readonly relationship: FieldRef<"StudentParent", 'String'>
    readonly isPrimary: FieldRef<"StudentParent", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * StudentParent findUnique
   */
  export type StudentParentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findUniqueOrThrow
   */
  export type StudentParentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent findFirst
   */
  export type StudentParentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findFirstOrThrow
   */
  export type StudentParentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParent to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentParents.
     */
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent findMany
   */
  export type StudentParentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter, which StudentParents to fetch.
     */
    where?: StudentParentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentParents to fetch.
     */
    orderBy?: StudentParentOrderByWithRelationInput | StudentParentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentParents.
     */
    cursor?: StudentParentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentParents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentParents.
     */
    skip?: number
    distinct?: StudentParentScalarFieldEnum | StudentParentScalarFieldEnum[]
  }

  /**
   * StudentParent create
   */
  export type StudentParentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentParent.
     */
    data: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
  }

  /**
   * StudentParent createMany
   */
  export type StudentParentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentParents.
     */
    data: StudentParentCreateManyInput | StudentParentCreateManyInput[]
  }

  /**
   * StudentParent update
   */
  export type StudentParentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentParent.
     */
    data: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
    /**
     * Choose, which StudentParent to update.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent updateMany
   */
  export type StudentParentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentParents.
     */
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyInput>
    /**
     * Filter which StudentParents to update
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to update.
     */
    limit?: number
  }

  /**
   * StudentParent upsert
   */
  export type StudentParentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentParent to update in case it exists.
     */
    where: StudentParentWhereUniqueInput
    /**
     * In case the StudentParent found by the `where` argument doesn't exist, create a new StudentParent with this data.
     */
    create: XOR<StudentParentCreateInput, StudentParentUncheckedCreateInput>
    /**
     * In case the StudentParent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentParentUpdateInput, StudentParentUncheckedUpdateInput>
  }

  /**
   * StudentParent delete
   */
  export type StudentParentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
    /**
     * Filter which StudentParent to delete.
     */
    where: StudentParentWhereUniqueInput
  }

  /**
   * StudentParent deleteMany
   */
  export type StudentParentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentParents to delete
     */
    where?: StudentParentWhereInput
    /**
     * Limit how many StudentParents to delete.
     */
    limit?: number
  }

  /**
   * StudentParent findRaw
   */
  export type StudentParentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentParent aggregateRaw
   */
  export type StudentParentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentParent without action
   */
  export type StudentParentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentParent
     */
    select?: StudentParentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentParent
     */
    omit?: StudentParentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentParentInclude<ExtArgs> | null
  }


  /**
   * Model HealthProfile
   */

  export type AggregateHealthProfile = {
    _count: HealthProfileCountAggregateOutputType | null
    _avg: HealthProfileAvgAggregateOutputType | null
    _sum: HealthProfileSumAggregateOutputType | null
    _min: HealthProfileMinAggregateOutputType | null
    _max: HealthProfileMaxAggregateOutputType | null
  }

  export type HealthProfileAvgAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type HealthProfileSumAggregateOutputType = {
    height: number | null
    weight: number | null
  }

  export type HealthProfileMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    treatmentHistory: string | null
    vision: string | null
    hearing: string | null
    height: number | null
    weight: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthProfileMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    treatmentHistory: string | null
    vision: string | null
    hearing: string | null
    height: number | null
    weight: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthProfileCountAggregateOutputType = {
    id: number
    studentId: number
    allergies: number
    chronicDiseases: number
    medications: number
    treatmentHistory: number
    vision: number
    hearing: number
    height: number
    weight: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthProfileAvgAggregateInputType = {
    height?: true
    weight?: true
  }

  export type HealthProfileSumAggregateInputType = {
    height?: true
    weight?: true
  }

  export type HealthProfileMinAggregateInputType = {
    id?: true
    studentId?: true
    treatmentHistory?: true
    vision?: true
    hearing?: true
    height?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthProfileMaxAggregateInputType = {
    id?: true
    studentId?: true
    treatmentHistory?: true
    vision?: true
    hearing?: true
    height?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthProfileCountAggregateInputType = {
    id?: true
    studentId?: true
    allergies?: true
    chronicDiseases?: true
    medications?: true
    treatmentHistory?: true
    vision?: true
    hearing?: true
    height?: true
    weight?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthProfile to aggregate.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthProfiles
    **/
    _count?: true | HealthProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthProfileMaxAggregateInputType
  }

  export type GetHealthProfileAggregateType<T extends HealthProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthProfile[P]>
      : GetScalarType<T[P], AggregateHealthProfile[P]>
  }




  export type HealthProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthProfileWhereInput
    orderBy?: HealthProfileOrderByWithAggregationInput | HealthProfileOrderByWithAggregationInput[]
    by: HealthProfileScalarFieldEnum[] | HealthProfileScalarFieldEnum
    having?: HealthProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthProfileCountAggregateInputType | true
    _avg?: HealthProfileAvgAggregateInputType
    _sum?: HealthProfileSumAggregateInputType
    _min?: HealthProfileMinAggregateInputType
    _max?: HealthProfileMaxAggregateInputType
  }

  export type HealthProfileGroupByOutputType = {
    id: string
    studentId: string
    allergies: string[]
    chronicDiseases: string[]
    medications: string[]
    treatmentHistory: string | null
    vision: string | null
    hearing: string | null
    height: number | null
    weight: number | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: HealthProfileCountAggregateOutputType | null
    _avg: HealthProfileAvgAggregateOutputType | null
    _sum: HealthProfileSumAggregateOutputType | null
    _min: HealthProfileMinAggregateOutputType | null
    _max: HealthProfileMaxAggregateOutputType | null
  }

  type GetHealthProfileGroupByPayload<T extends HealthProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthProfileGroupByOutputType[P]>
            : GetScalarType<T[P], HealthProfileGroupByOutputType[P]>
        }
      >
    >


  export type HealthProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    medications?: boolean
    treatmentHistory?: boolean
    vision?: boolean
    hearing?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthProfile"]>



  export type HealthProfileSelectScalar = {
    id?: boolean
    studentId?: boolean
    allergies?: boolean
    chronicDiseases?: boolean
    medications?: boolean
    treatmentHistory?: boolean
    vision?: boolean
    hearing?: boolean
    height?: boolean
    weight?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "allergies" | "chronicDiseases" | "medications" | "treatmentHistory" | "vision" | "hearing" | "height" | "weight" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["healthProfile"]>
  export type HealthProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $HealthProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthProfile"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      allergies: string[]
      chronicDiseases: string[]
      medications: string[]
      treatmentHistory: string | null
      vision: string | null
      hearing: string | null
      height: number | null
      weight: number | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthProfile"]>
    composites: {}
  }

  type HealthProfileGetPayload<S extends boolean | null | undefined | HealthProfileDefaultArgs> = $Result.GetResult<Prisma.$HealthProfilePayload, S>

  type HealthProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HealthProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HealthProfileCountAggregateInputType | true
    }

  export interface HealthProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthProfile'], meta: { name: 'HealthProfile' } }
    /**
     * Find zero or one HealthProfile that matches the filter.
     * @param {HealthProfileFindUniqueArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthProfileFindUniqueArgs>(args: SelectSubset<T, HealthProfileFindUniqueArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HealthProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HealthProfileFindUniqueOrThrowArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindFirstArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthProfileFindFirstArgs>(args?: SelectSubset<T, HealthProfileFindFirstArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HealthProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindFirstOrThrowArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthProfiles
     * const healthProfiles = await prisma.healthProfile.findMany()
     * 
     * // Get first 10 HealthProfiles
     * const healthProfiles = await prisma.healthProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthProfileWithIdOnly = await prisma.healthProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthProfileFindManyArgs>(args?: SelectSubset<T, HealthProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HealthProfile.
     * @param {HealthProfileCreateArgs} args - Arguments to create a HealthProfile.
     * @example
     * // Create one HealthProfile
     * const HealthProfile = await prisma.healthProfile.create({
     *   data: {
     *     // ... data to create a HealthProfile
     *   }
     * })
     * 
     */
    create<T extends HealthProfileCreateArgs>(args: SelectSubset<T, HealthProfileCreateArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HealthProfiles.
     * @param {HealthProfileCreateManyArgs} args - Arguments to create many HealthProfiles.
     * @example
     * // Create many HealthProfiles
     * const healthProfile = await prisma.healthProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthProfileCreateManyArgs>(args?: SelectSubset<T, HealthProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HealthProfile.
     * @param {HealthProfileDeleteArgs} args - Arguments to delete one HealthProfile.
     * @example
     * // Delete one HealthProfile
     * const HealthProfile = await prisma.healthProfile.delete({
     *   where: {
     *     // ... filter to delete one HealthProfile
     *   }
     * })
     * 
     */
    delete<T extends HealthProfileDeleteArgs>(args: SelectSubset<T, HealthProfileDeleteArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HealthProfile.
     * @param {HealthProfileUpdateArgs} args - Arguments to update one HealthProfile.
     * @example
     * // Update one HealthProfile
     * const healthProfile = await prisma.healthProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthProfileUpdateArgs>(args: SelectSubset<T, HealthProfileUpdateArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HealthProfiles.
     * @param {HealthProfileDeleteManyArgs} args - Arguments to filter HealthProfiles to delete.
     * @example
     * // Delete a few HealthProfiles
     * const { count } = await prisma.healthProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthProfileDeleteManyArgs>(args?: SelectSubset<T, HealthProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthProfiles
     * const healthProfile = await prisma.healthProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthProfileUpdateManyArgs>(args: SelectSubset<T, HealthProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthProfile.
     * @param {HealthProfileUpsertArgs} args - Arguments to update or create a HealthProfile.
     * @example
     * // Update or create a HealthProfile
     * const healthProfile = await prisma.healthProfile.upsert({
     *   create: {
     *     // ... data to create a HealthProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthProfile we want to update
     *   }
     * })
     */
    upsert<T extends HealthProfileUpsertArgs>(args: SelectSubset<T, HealthProfileUpsertArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HealthProfiles that matches the filter.
     * @param {HealthProfileFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const healthProfile = await prisma.healthProfile.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: HealthProfileFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a HealthProfile.
     * @param {HealthProfileAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const healthProfile = await prisma.healthProfile.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: HealthProfileAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of HealthProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileCountArgs} args - Arguments to filter HealthProfiles to count.
     * @example
     * // Count the number of HealthProfiles
     * const count = await prisma.healthProfile.count({
     *   where: {
     *     // ... the filter for the HealthProfiles we want to count
     *   }
     * })
    **/
    count<T extends HealthProfileCountArgs>(
      args?: Subset<T, HealthProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthProfileAggregateArgs>(args: Subset<T, HealthProfileAggregateArgs>): Prisma.PrismaPromise<GetHealthProfileAggregateType<T>>

    /**
     * Group by HealthProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthProfileGroupByArgs['orderBy'] }
        : { orderBy?: HealthProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthProfile model
   */
  readonly fields: HealthProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthProfile model
   */
  interface HealthProfileFieldRefs {
    readonly id: FieldRef<"HealthProfile", 'String'>
    readonly studentId: FieldRef<"HealthProfile", 'String'>
    readonly allergies: FieldRef<"HealthProfile", 'String[]'>
    readonly chronicDiseases: FieldRef<"HealthProfile", 'String[]'>
    readonly medications: FieldRef<"HealthProfile", 'String[]'>
    readonly treatmentHistory: FieldRef<"HealthProfile", 'String'>
    readonly vision: FieldRef<"HealthProfile", 'String'>
    readonly hearing: FieldRef<"HealthProfile", 'String'>
    readonly height: FieldRef<"HealthProfile", 'Float'>
    readonly weight: FieldRef<"HealthProfile", 'Float'>
    readonly notes: FieldRef<"HealthProfile", 'String'>
    readonly createdAt: FieldRef<"HealthProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthProfile findUnique
   */
  export type HealthProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile findUniqueOrThrow
   */
  export type HealthProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile findFirst
   */
  export type HealthProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthProfiles.
     */
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile findFirstOrThrow
   */
  export type HealthProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthProfiles.
     */
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile findMany
   */
  export type HealthProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfiles to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile create
   */
  export type HealthProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthProfile.
     */
    data: XOR<HealthProfileCreateInput, HealthProfileUncheckedCreateInput>
  }

  /**
   * HealthProfile createMany
   */
  export type HealthProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthProfiles.
     */
    data: HealthProfileCreateManyInput | HealthProfileCreateManyInput[]
  }

  /**
   * HealthProfile update
   */
  export type HealthProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthProfile.
     */
    data: XOR<HealthProfileUpdateInput, HealthProfileUncheckedUpdateInput>
    /**
     * Choose, which HealthProfile to update.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile updateMany
   */
  export type HealthProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthProfiles.
     */
    data: XOR<HealthProfileUpdateManyMutationInput, HealthProfileUncheckedUpdateManyInput>
    /**
     * Filter which HealthProfiles to update
     */
    where?: HealthProfileWhereInput
    /**
     * Limit how many HealthProfiles to update.
     */
    limit?: number
  }

  /**
   * HealthProfile upsert
   */
  export type HealthProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthProfile to update in case it exists.
     */
    where: HealthProfileWhereUniqueInput
    /**
     * In case the HealthProfile found by the `where` argument doesn't exist, create a new HealthProfile with this data.
     */
    create: XOR<HealthProfileCreateInput, HealthProfileUncheckedCreateInput>
    /**
     * In case the HealthProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthProfileUpdateInput, HealthProfileUncheckedUpdateInput>
  }

  /**
   * HealthProfile delete
   */
  export type HealthProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter which HealthProfile to delete.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile deleteMany
   */
  export type HealthProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthProfiles to delete
     */
    where?: HealthProfileWhereInput
    /**
     * Limit how many HealthProfiles to delete.
     */
    limit?: number
  }

  /**
   * HealthProfile findRaw
   */
  export type HealthProfileFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HealthProfile aggregateRaw
   */
  export type HealthProfileAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * HealthProfile without action
   */
  export type HealthProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HealthProfile
     */
    omit?: HealthProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
  }


  /**
   * Model MedicalEvent
   */

  export type AggregateMedicalEvent = {
    _count: MedicalEventCountAggregateOutputType | null
    _min: MedicalEventMinAggregateOutputType | null
    _max: MedicalEventMaxAggregateOutputType | null
  }

  export type MedicalEventMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    nurseId: string | null
    createdById: string | null
    title: string | null
    description: string | null
    type: $Enums.MedicalEventType | null
    status: $Enums.MedicalEventStatus | null
    severity: string | null
    location: string | null
    treatment: string | null
    outcome: string | null
    occurredAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalEventMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    nurseId: string | null
    createdById: string | null
    title: string | null
    description: string | null
    type: $Enums.MedicalEventType | null
    status: $Enums.MedicalEventStatus | null
    severity: string | null
    location: string | null
    treatment: string | null
    outcome: string | null
    occurredAt: Date | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalEventCountAggregateOutputType = {
    id: number
    studentId: number
    nurseId: number
    createdById: number
    title: number
    description: number
    type: number
    status: number
    severity: number
    location: number
    symptoms: number
    treatment: number
    outcome: number
    occurredAt: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalEventMinAggregateInputType = {
    id?: true
    studentId?: true
    nurseId?: true
    createdById?: true
    title?: true
    description?: true
    type?: true
    status?: true
    severity?: true
    location?: true
    treatment?: true
    outcome?: true
    occurredAt?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalEventMaxAggregateInputType = {
    id?: true
    studentId?: true
    nurseId?: true
    createdById?: true
    title?: true
    description?: true
    type?: true
    status?: true
    severity?: true
    location?: true
    treatment?: true
    outcome?: true
    occurredAt?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalEventCountAggregateInputType = {
    id?: true
    studentId?: true
    nurseId?: true
    createdById?: true
    title?: true
    description?: true
    type?: true
    status?: true
    severity?: true
    location?: true
    symptoms?: true
    treatment?: true
    outcome?: true
    occurredAt?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalEvent to aggregate.
     */
    where?: MedicalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEvents to fetch.
     */
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalEvents
    **/
    _count?: true | MedicalEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalEventMaxAggregateInputType
  }

  export type GetMedicalEventAggregateType<T extends MedicalEventAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalEvent[P]>
      : GetScalarType<T[P], AggregateMedicalEvent[P]>
  }




  export type MedicalEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventWhereInput
    orderBy?: MedicalEventOrderByWithAggregationInput | MedicalEventOrderByWithAggregationInput[]
    by: MedicalEventScalarFieldEnum[] | MedicalEventScalarFieldEnum
    having?: MedicalEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalEventCountAggregateInputType | true
    _min?: MedicalEventMinAggregateInputType
    _max?: MedicalEventMaxAggregateInputType
  }

  export type MedicalEventGroupByOutputType = {
    id: string
    studentId: string
    nurseId: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status: $Enums.MedicalEventStatus
    severity: string
    location: string | null
    symptoms: string[]
    treatment: string | null
    outcome: string | null
    occurredAt: Date
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalEventCountAggregateOutputType | null
    _min: MedicalEventMinAggregateOutputType | null
    _max: MedicalEventMaxAggregateOutputType | null
  }

  type GetMedicalEventGroupByPayload<T extends MedicalEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalEventGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalEventGroupByOutputType[P]>
        }
      >
    >


  export type MedicalEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    nurseId?: boolean
    createdById?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    severity?: boolean
    location?: boolean
    symptoms?: boolean
    treatment?: boolean
    outcome?: boolean
    occurredAt?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    nurse?: boolean | MedicalEvent$nurseArgs<ExtArgs>
    createdBy?: boolean | usersDefaultArgs<ExtArgs>
    medicationsUsed?: boolean | MedicalEvent$medicationsUsedArgs<ExtArgs>
    documents?: boolean | MedicalEvent$documentsArgs<ExtArgs>
    _count?: boolean | MedicalEventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalEvent"]>



  export type MedicalEventSelectScalar = {
    id?: boolean
    studentId?: boolean
    nurseId?: boolean
    createdById?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    severity?: boolean
    location?: boolean
    symptoms?: boolean
    treatment?: boolean
    outcome?: boolean
    occurredAt?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "nurseId" | "createdById" | "title" | "description" | "type" | "status" | "severity" | "location" | "symptoms" | "treatment" | "outcome" | "occurredAt" | "resolvedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalEvent"]>
  export type MedicalEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    nurse?: boolean | MedicalEvent$nurseArgs<ExtArgs>
    createdBy?: boolean | usersDefaultArgs<ExtArgs>
    medicationsUsed?: boolean | MedicalEvent$medicationsUsedArgs<ExtArgs>
    documents?: boolean | MedicalEvent$documentsArgs<ExtArgs>
    _count?: boolean | MedicalEventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicalEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalEvent"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      nurse: Prisma.$SchoolNursePayload<ExtArgs> | null
      createdBy: Prisma.$usersPayload<ExtArgs>
      medicationsUsed: Prisma.$MedicalEventMedicationPayload<ExtArgs>[]
      documents: Prisma.$MedicalDocumentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      nurseId: string | null
      createdById: string
      title: string
      description: string
      type: $Enums.MedicalEventType
      status: $Enums.MedicalEventStatus
      severity: string
      location: string | null
      symptoms: string[]
      treatment: string | null
      outcome: string | null
      occurredAt: Date
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalEvent"]>
    composites: {}
  }

  type MedicalEventGetPayload<S extends boolean | null | undefined | MedicalEventDefaultArgs> = $Result.GetResult<Prisma.$MedicalEventPayload, S>

  type MedicalEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalEventCountAggregateInputType | true
    }

  export interface MedicalEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalEvent'], meta: { name: 'MedicalEvent' } }
    /**
     * Find zero or one MedicalEvent that matches the filter.
     * @param {MedicalEventFindUniqueArgs} args - Arguments to find a MedicalEvent
     * @example
     * // Get one MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalEventFindUniqueArgs>(args: SelectSubset<T, MedicalEventFindUniqueArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalEventFindUniqueOrThrowArgs} args - Arguments to find a MedicalEvent
     * @example
     * // Get one MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalEventFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventFindFirstArgs} args - Arguments to find a MedicalEvent
     * @example
     * // Get one MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalEventFindFirstArgs>(args?: SelectSubset<T, MedicalEventFindFirstArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventFindFirstOrThrowArgs} args - Arguments to find a MedicalEvent
     * @example
     * // Get one MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalEventFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalEvents
     * const medicalEvents = await prisma.medicalEvent.findMany()
     * 
     * // Get first 10 MedicalEvents
     * const medicalEvents = await prisma.medicalEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalEventWithIdOnly = await prisma.medicalEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalEventFindManyArgs>(args?: SelectSubset<T, MedicalEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalEvent.
     * @param {MedicalEventCreateArgs} args - Arguments to create a MedicalEvent.
     * @example
     * // Create one MedicalEvent
     * const MedicalEvent = await prisma.medicalEvent.create({
     *   data: {
     *     // ... data to create a MedicalEvent
     *   }
     * })
     * 
     */
    create<T extends MedicalEventCreateArgs>(args: SelectSubset<T, MedicalEventCreateArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalEvents.
     * @param {MedicalEventCreateManyArgs} args - Arguments to create many MedicalEvents.
     * @example
     * // Create many MedicalEvents
     * const medicalEvent = await prisma.medicalEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalEventCreateManyArgs>(args?: SelectSubset<T, MedicalEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalEvent.
     * @param {MedicalEventDeleteArgs} args - Arguments to delete one MedicalEvent.
     * @example
     * // Delete one MedicalEvent
     * const MedicalEvent = await prisma.medicalEvent.delete({
     *   where: {
     *     // ... filter to delete one MedicalEvent
     *   }
     * })
     * 
     */
    delete<T extends MedicalEventDeleteArgs>(args: SelectSubset<T, MedicalEventDeleteArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalEvent.
     * @param {MedicalEventUpdateArgs} args - Arguments to update one MedicalEvent.
     * @example
     * // Update one MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalEventUpdateArgs>(args: SelectSubset<T, MedicalEventUpdateArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalEvents.
     * @param {MedicalEventDeleteManyArgs} args - Arguments to filter MedicalEvents to delete.
     * @example
     * // Delete a few MedicalEvents
     * const { count } = await prisma.medicalEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalEventDeleteManyArgs>(args?: SelectSubset<T, MedicalEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalEvents
     * const medicalEvent = await prisma.medicalEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalEventUpdateManyArgs>(args: SelectSubset<T, MedicalEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalEvent.
     * @param {MedicalEventUpsertArgs} args - Arguments to update or create a MedicalEvent.
     * @example
     * // Update or create a MedicalEvent
     * const medicalEvent = await prisma.medicalEvent.upsert({
     *   create: {
     *     // ... data to create a MedicalEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalEvent we want to update
     *   }
     * })
     */
    upsert<T extends MedicalEventUpsertArgs>(args: SelectSubset<T, MedicalEventUpsertArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalEvents that matches the filter.
     * @param {MedicalEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medicalEvent = await prisma.medicalEvent.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicalEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MedicalEvent.
     * @param {MedicalEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medicalEvent = await prisma.medicalEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicalEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MedicalEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventCountArgs} args - Arguments to filter MedicalEvents to count.
     * @example
     * // Count the number of MedicalEvents
     * const count = await prisma.medicalEvent.count({
     *   where: {
     *     // ... the filter for the MedicalEvents we want to count
     *   }
     * })
    **/
    count<T extends MedicalEventCountArgs>(
      args?: Subset<T, MedicalEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalEventAggregateArgs>(args: Subset<T, MedicalEventAggregateArgs>): Prisma.PrismaPromise<GetMedicalEventAggregateType<T>>

    /**
     * Group by MedicalEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalEventGroupByArgs['orderBy'] }
        : { orderBy?: MedicalEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalEvent model
   */
  readonly fields: MedicalEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nurse<T extends MedicalEvent$nurseArgs<ExtArgs> = {}>(args?: Subset<T, MedicalEvent$nurseArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medicationsUsed<T extends MedicalEvent$medicationsUsedArgs<ExtArgs> = {}>(args?: Subset<T, MedicalEvent$medicationsUsedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends MedicalEvent$documentsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalEvent$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalEvent model
   */
  interface MedicalEventFieldRefs {
    readonly id: FieldRef<"MedicalEvent", 'String'>
    readonly studentId: FieldRef<"MedicalEvent", 'String'>
    readonly nurseId: FieldRef<"MedicalEvent", 'String'>
    readonly createdById: FieldRef<"MedicalEvent", 'String'>
    readonly title: FieldRef<"MedicalEvent", 'String'>
    readonly description: FieldRef<"MedicalEvent", 'String'>
    readonly type: FieldRef<"MedicalEvent", 'MedicalEventType'>
    readonly status: FieldRef<"MedicalEvent", 'MedicalEventStatus'>
    readonly severity: FieldRef<"MedicalEvent", 'String'>
    readonly location: FieldRef<"MedicalEvent", 'String'>
    readonly symptoms: FieldRef<"MedicalEvent", 'String[]'>
    readonly treatment: FieldRef<"MedicalEvent", 'String'>
    readonly outcome: FieldRef<"MedicalEvent", 'String'>
    readonly occurredAt: FieldRef<"MedicalEvent", 'DateTime'>
    readonly resolvedAt: FieldRef<"MedicalEvent", 'DateTime'>
    readonly createdAt: FieldRef<"MedicalEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalEvent findUnique
   */
  export type MedicalEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEvent to fetch.
     */
    where: MedicalEventWhereUniqueInput
  }

  /**
   * MedicalEvent findUniqueOrThrow
   */
  export type MedicalEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEvent to fetch.
     */
    where: MedicalEventWhereUniqueInput
  }

  /**
   * MedicalEvent findFirst
   */
  export type MedicalEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEvent to fetch.
     */
    where?: MedicalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEvents to fetch.
     */
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalEvents.
     */
    cursor?: MedicalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalEvents.
     */
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * MedicalEvent findFirstOrThrow
   */
  export type MedicalEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEvent to fetch.
     */
    where?: MedicalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEvents to fetch.
     */
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalEvents.
     */
    cursor?: MedicalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalEvents.
     */
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * MedicalEvent findMany
   */
  export type MedicalEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEvents to fetch.
     */
    where?: MedicalEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEvents to fetch.
     */
    orderBy?: MedicalEventOrderByWithRelationInput | MedicalEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalEvents.
     */
    cursor?: MedicalEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEvents.
     */
    skip?: number
    distinct?: MedicalEventScalarFieldEnum | MedicalEventScalarFieldEnum[]
  }

  /**
   * MedicalEvent create
   */
  export type MedicalEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalEvent.
     */
    data: XOR<MedicalEventCreateInput, MedicalEventUncheckedCreateInput>
  }

  /**
   * MedicalEvent createMany
   */
  export type MedicalEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalEvents.
     */
    data: MedicalEventCreateManyInput | MedicalEventCreateManyInput[]
  }

  /**
   * MedicalEvent update
   */
  export type MedicalEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalEvent.
     */
    data: XOR<MedicalEventUpdateInput, MedicalEventUncheckedUpdateInput>
    /**
     * Choose, which MedicalEvent to update.
     */
    where: MedicalEventWhereUniqueInput
  }

  /**
   * MedicalEvent updateMany
   */
  export type MedicalEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalEvents.
     */
    data: XOR<MedicalEventUpdateManyMutationInput, MedicalEventUncheckedUpdateManyInput>
    /**
     * Filter which MedicalEvents to update
     */
    where?: MedicalEventWhereInput
    /**
     * Limit how many MedicalEvents to update.
     */
    limit?: number
  }

  /**
   * MedicalEvent upsert
   */
  export type MedicalEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalEvent to update in case it exists.
     */
    where: MedicalEventWhereUniqueInput
    /**
     * In case the MedicalEvent found by the `where` argument doesn't exist, create a new MedicalEvent with this data.
     */
    create: XOR<MedicalEventCreateInput, MedicalEventUncheckedCreateInput>
    /**
     * In case the MedicalEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalEventUpdateInput, MedicalEventUncheckedUpdateInput>
  }

  /**
   * MedicalEvent delete
   */
  export type MedicalEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    /**
     * Filter which MedicalEvent to delete.
     */
    where: MedicalEventWhereUniqueInput
  }

  /**
   * MedicalEvent deleteMany
   */
  export type MedicalEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalEvents to delete
     */
    where?: MedicalEventWhereInput
    /**
     * Limit how many MedicalEvents to delete.
     */
    limit?: number
  }

  /**
   * MedicalEvent findRaw
   */
  export type MedicalEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalEvent aggregateRaw
   */
  export type MedicalEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalEvent.nurse
   */
  export type MedicalEvent$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    where?: SchoolNurseWhereInput
  }

  /**
   * MedicalEvent.medicationsUsed
   */
  export type MedicalEvent$medicationsUsedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    where?: MedicalEventMedicationWhereInput
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    cursor?: MedicalEventMedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalEventMedicationScalarFieldEnum | MedicalEventMedicationScalarFieldEnum[]
  }

  /**
   * MedicalEvent.documents
   */
  export type MedicalEvent$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    where?: MedicalDocumentWhereInput
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    cursor?: MedicalDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }

  /**
   * MedicalEvent without action
   */
  export type MedicalEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _avg: MedicationAvgAggregateOutputType | null
    _sum: MedicationSumAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationAvgAggregateOutputType = {
    stockQuantity: number | null
    minStockLevel: number | null
  }

  export type MedicationSumAggregateOutputType = {
    stockQuantity: number | null
    minStockLevel: number | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dosage: string | null
    unit: string | null
    manufacturer: string | null
    expiryDate: Date | null
    stockQuantity: number | null
    minStockLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    dosage: string | null
    unit: string | null
    manufacturer: string | null
    expiryDate: Date | null
    stockQuantity: number | null
    minStockLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    name: number
    description: number
    dosage: number
    unit: number
    manufacturer: number
    expiryDate: number
    stockQuantity: number
    minStockLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationAvgAggregateInputType = {
    stockQuantity?: true
    minStockLevel?: true
  }

  export type MedicationSumAggregateInputType = {
    stockQuantity?: true
    minStockLevel?: true
  }

  export type MedicationMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dosage?: true
    unit?: true
    manufacturer?: true
    expiryDate?: true
    stockQuantity?: true
    minStockLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dosage?: true
    unit?: true
    manufacturer?: true
    expiryDate?: true
    stockQuantity?: true
    minStockLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    dosage?: true
    unit?: true
    manufacturer?: true
    expiryDate?: true
    stockQuantity?: true
    minStockLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _avg?: MedicationAvgAggregateInputType
    _sum?: MedicationSumAggregateInputType
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    name: string
    description: string | null
    dosage: string
    unit: string
    manufacturer: string | null
    expiryDate: Date | null
    stockQuantity: number
    minStockLevel: number
    createdAt: Date
    updatedAt: Date
    _count: MedicationCountAggregateOutputType | null
    _avg: MedicationAvgAggregateOutputType | null
    _sum: MedicationSumAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    dosage?: boolean
    unit?: boolean
    manufacturer?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    minStockLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    studentMedications?: boolean | Medication$studentMedicationsArgs<ExtArgs>
    medicalEventMedications?: boolean | Medication$medicalEventMedicationsArgs<ExtArgs>
    stockMovements?: boolean | Medication$stockMovementsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>



  export type MedicationSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    dosage?: boolean
    unit?: boolean
    manufacturer?: boolean
    expiryDate?: boolean
    stockQuantity?: boolean
    minStockLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "dosage" | "unit" | "manufacturer" | "expiryDate" | "stockQuantity" | "minStockLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["medication"]>
  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentMedications?: boolean | Medication$studentMedicationsArgs<ExtArgs>
    medicalEventMedications?: boolean | Medication$medicalEventMedicationsArgs<ExtArgs>
    stockMovements?: boolean | Medication$stockMovementsArgs<ExtArgs>
    _count?: boolean | MedicationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      studentMedications: Prisma.$StudentMedicationPayload<ExtArgs>[]
      medicalEventMedications: Prisma.$MedicalEventMedicationPayload<ExtArgs>[]
      stockMovements: Prisma.$StockMovementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      dosage: string
      unit: string
      manufacturer: string | null
      expiryDate: Date | null
      stockQuantity: number
      minStockLevel: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medications that matches the filter.
     * @param {MedicationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medication = await prisma.medication.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Medication.
     * @param {MedicationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medication = await prisma.medication.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentMedications<T extends Medication$studentMedicationsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$studentMedicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medicalEventMedications<T extends Medication$medicalEventMedicationsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$medicalEventMedicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stockMovements<T extends Medication$stockMovementsArgs<ExtArgs> = {}>(args?: Subset<T, Medication$stockMovementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly name: FieldRef<"Medication", 'String'>
    readonly description: FieldRef<"Medication", 'String'>
    readonly dosage: FieldRef<"Medication", 'String'>
    readonly unit: FieldRef<"Medication", 'String'>
    readonly manufacturer: FieldRef<"Medication", 'String'>
    readonly expiryDate: FieldRef<"Medication", 'DateTime'>
    readonly stockQuantity: FieldRef<"Medication", 'Int'>
    readonly minStockLevel: FieldRef<"Medication", 'Int'>
    readonly createdAt: FieldRef<"Medication", 'DateTime'>
    readonly updatedAt: FieldRef<"Medication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to update.
     */
    limit?: number
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
    /**
     * Limit how many Medications to delete.
     */
    limit?: number
  }

  /**
   * Medication findRaw
   */
  export type MedicationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Medication aggregateRaw
   */
  export type MedicationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Medication.studentMedications
   */
  export type Medication$studentMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    where?: StudentMedicationWhereInput
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    cursor?: StudentMedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * Medication.medicalEventMedications
   */
  export type Medication$medicalEventMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    where?: MedicalEventMedicationWhereInput
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    cursor?: MedicalEventMedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalEventMedicationScalarFieldEnum | MedicalEventMedicationScalarFieldEnum[]
  }

  /**
   * Medication.stockMovements
   */
  export type Medication$stockMovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    cursor?: StockMovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Medication
     */
    omit?: MedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model StudentMedication
   */

  export type AggregateStudentMedication = {
    _count: StudentMedicationCountAggregateOutputType | null
    _min: StudentMedicationMinAggregateOutputType | null
    _max: StudentMedicationMaxAggregateOutputType | null
  }

  export type StudentMedicationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    medicationId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    status: $Enums.MedicationStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMedicationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    parentId: string | null
    medicationId: string | null
    dosage: string | null
    frequency: string | null
    duration: string | null
    instructions: string | null
    status: $Enums.MedicationStatus | null
    startDate: Date | null
    endDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMedicationCountAggregateOutputType = {
    id: number
    studentId: number
    parentId: number
    medicationId: number
    dosage: number
    frequency: number
    duration: number
    instructions: number
    status: number
    startDate: number
    endDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentMedicationMinAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    medicationId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMedicationMaxAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    medicationId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMedicationCountAggregateInputType = {
    id?: true
    studentId?: true
    parentId?: true
    medicationId?: true
    dosage?: true
    frequency?: true
    duration?: true
    instructions?: true
    status?: true
    startDate?: true
    endDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentMedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentMedication to aggregate.
     */
    where?: StudentMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMedications to fetch.
     */
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentMedications
    **/
    _count?: true | StudentMedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMedicationMaxAggregateInputType
  }

  export type GetStudentMedicationAggregateType<T extends StudentMedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentMedication[P]>
      : GetScalarType<T[P], AggregateStudentMedication[P]>
  }




  export type StudentMedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentMedicationWhereInput
    orderBy?: StudentMedicationOrderByWithAggregationInput | StudentMedicationOrderByWithAggregationInput[]
    by: StudentMedicationScalarFieldEnum[] | StudentMedicationScalarFieldEnum
    having?: StudentMedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentMedicationCountAggregateInputType | true
    _min?: StudentMedicationMinAggregateInputType
    _max?: StudentMedicationMaxAggregateInputType
  }

  export type StudentMedicationGroupByOutputType = {
    id: string
    studentId: string
    parentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration: string | null
    instructions: string | null
    status: $Enums.MedicationStatus
    startDate: Date
    endDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StudentMedicationCountAggregateOutputType | null
    _min: StudentMedicationMinAggregateOutputType | null
    _max: StudentMedicationMaxAggregateOutputType | null
  }

  type GetStudentMedicationGroupByPayload<T extends StudentMedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentMedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentMedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentMedicationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentMedicationGroupByOutputType[P]>
        }
      >
    >


  export type StudentMedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    medicationId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentMedication"]>



  export type StudentMedicationSelectScalar = {
    id?: boolean
    studentId?: boolean
    parentId?: boolean
    medicationId?: boolean
    dosage?: boolean
    frequency?: boolean
    duration?: boolean
    instructions?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentMedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "parentId" | "medicationId" | "dosage" | "frequency" | "duration" | "instructions" | "status" | "startDate" | "endDate" | "createdAt" | "updatedAt", ExtArgs["result"]["studentMedication"]>
  export type StudentMedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    parent?: boolean | ParentDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }

  export type $StudentMedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentMedication"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      parent: Prisma.$ParentPayload<ExtArgs>
      medication: Prisma.$MedicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      parentId: string
      medicationId: string
      dosage: string
      frequency: string
      duration: string | null
      instructions: string | null
      status: $Enums.MedicationStatus
      startDate: Date
      endDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentMedication"]>
    composites: {}
  }

  type StudentMedicationGetPayload<S extends boolean | null | undefined | StudentMedicationDefaultArgs> = $Result.GetResult<Prisma.$StudentMedicationPayload, S>

  type StudentMedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentMedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentMedicationCountAggregateInputType | true
    }

  export interface StudentMedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentMedication'], meta: { name: 'StudentMedication' } }
    /**
     * Find zero or one StudentMedication that matches the filter.
     * @param {StudentMedicationFindUniqueArgs} args - Arguments to find a StudentMedication
     * @example
     * // Get one StudentMedication
     * const studentMedication = await prisma.studentMedication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentMedicationFindUniqueArgs>(args: SelectSubset<T, StudentMedicationFindUniqueArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentMedication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentMedicationFindUniqueOrThrowArgs} args - Arguments to find a StudentMedication
     * @example
     * // Get one StudentMedication
     * const studentMedication = await prisma.studentMedication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentMedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentMedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentMedication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationFindFirstArgs} args - Arguments to find a StudentMedication
     * @example
     * // Get one StudentMedication
     * const studentMedication = await prisma.studentMedication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentMedicationFindFirstArgs>(args?: SelectSubset<T, StudentMedicationFindFirstArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentMedication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationFindFirstOrThrowArgs} args - Arguments to find a StudentMedication
     * @example
     * // Get one StudentMedication
     * const studentMedication = await prisma.studentMedication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentMedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentMedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentMedications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentMedications
     * const studentMedications = await prisma.studentMedication.findMany()
     * 
     * // Get first 10 StudentMedications
     * const studentMedications = await prisma.studentMedication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentMedicationWithIdOnly = await prisma.studentMedication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentMedicationFindManyArgs>(args?: SelectSubset<T, StudentMedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentMedication.
     * @param {StudentMedicationCreateArgs} args - Arguments to create a StudentMedication.
     * @example
     * // Create one StudentMedication
     * const StudentMedication = await prisma.studentMedication.create({
     *   data: {
     *     // ... data to create a StudentMedication
     *   }
     * })
     * 
     */
    create<T extends StudentMedicationCreateArgs>(args: SelectSubset<T, StudentMedicationCreateArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentMedications.
     * @param {StudentMedicationCreateManyArgs} args - Arguments to create many StudentMedications.
     * @example
     * // Create many StudentMedications
     * const studentMedication = await prisma.studentMedication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentMedicationCreateManyArgs>(args?: SelectSubset<T, StudentMedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StudentMedication.
     * @param {StudentMedicationDeleteArgs} args - Arguments to delete one StudentMedication.
     * @example
     * // Delete one StudentMedication
     * const StudentMedication = await prisma.studentMedication.delete({
     *   where: {
     *     // ... filter to delete one StudentMedication
     *   }
     * })
     * 
     */
    delete<T extends StudentMedicationDeleteArgs>(args: SelectSubset<T, StudentMedicationDeleteArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentMedication.
     * @param {StudentMedicationUpdateArgs} args - Arguments to update one StudentMedication.
     * @example
     * // Update one StudentMedication
     * const studentMedication = await prisma.studentMedication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentMedicationUpdateArgs>(args: SelectSubset<T, StudentMedicationUpdateArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentMedications.
     * @param {StudentMedicationDeleteManyArgs} args - Arguments to filter StudentMedications to delete.
     * @example
     * // Delete a few StudentMedications
     * const { count } = await prisma.studentMedication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentMedicationDeleteManyArgs>(args?: SelectSubset<T, StudentMedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentMedications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentMedications
     * const studentMedication = await prisma.studentMedication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentMedicationUpdateManyArgs>(args: SelectSubset<T, StudentMedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentMedication.
     * @param {StudentMedicationUpsertArgs} args - Arguments to update or create a StudentMedication.
     * @example
     * // Update or create a StudentMedication
     * const studentMedication = await prisma.studentMedication.upsert({
     *   create: {
     *     // ... data to create a StudentMedication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentMedication we want to update
     *   }
     * })
     */
    upsert<T extends StudentMedicationUpsertArgs>(args: SelectSubset<T, StudentMedicationUpsertArgs<ExtArgs>>): Prisma__StudentMedicationClient<$Result.GetResult<Prisma.$StudentMedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentMedications that matches the filter.
     * @param {StudentMedicationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const studentMedication = await prisma.studentMedication.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StudentMedicationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a StudentMedication.
     * @param {StudentMedicationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const studentMedication = await prisma.studentMedication.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StudentMedicationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of StudentMedications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationCountArgs} args - Arguments to filter StudentMedications to count.
     * @example
     * // Count the number of StudentMedications
     * const count = await prisma.studentMedication.count({
     *   where: {
     *     // ... the filter for the StudentMedications we want to count
     *   }
     * })
    **/
    count<T extends StudentMedicationCountArgs>(
      args?: Subset<T, StudentMedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentMedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentMedication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentMedicationAggregateArgs>(args: Subset<T, StudentMedicationAggregateArgs>): Prisma.PrismaPromise<GetStudentMedicationAggregateType<T>>

    /**
     * Group by StudentMedication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentMedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentMedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentMedicationGroupByArgs['orderBy'] }
        : { orderBy?: StudentMedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentMedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentMedication model
   */
  readonly fields: StudentMedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentMedication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentMedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends ParentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParentDefaultArgs<ExtArgs>>): Prisma__ParentClient<$Result.GetResult<Prisma.$ParentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentMedication model
   */
  interface StudentMedicationFieldRefs {
    readonly id: FieldRef<"StudentMedication", 'String'>
    readonly studentId: FieldRef<"StudentMedication", 'String'>
    readonly parentId: FieldRef<"StudentMedication", 'String'>
    readonly medicationId: FieldRef<"StudentMedication", 'String'>
    readonly dosage: FieldRef<"StudentMedication", 'String'>
    readonly frequency: FieldRef<"StudentMedication", 'String'>
    readonly duration: FieldRef<"StudentMedication", 'String'>
    readonly instructions: FieldRef<"StudentMedication", 'String'>
    readonly status: FieldRef<"StudentMedication", 'MedicationStatus'>
    readonly startDate: FieldRef<"StudentMedication", 'DateTime'>
    readonly endDate: FieldRef<"StudentMedication", 'DateTime'>
    readonly createdAt: FieldRef<"StudentMedication", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentMedication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentMedication findUnique
   */
  export type StudentMedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter, which StudentMedication to fetch.
     */
    where: StudentMedicationWhereUniqueInput
  }

  /**
   * StudentMedication findUniqueOrThrow
   */
  export type StudentMedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter, which StudentMedication to fetch.
     */
    where: StudentMedicationWhereUniqueInput
  }

  /**
   * StudentMedication findFirst
   */
  export type StudentMedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter, which StudentMedication to fetch.
     */
    where?: StudentMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMedications to fetch.
     */
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMedications.
     */
    cursor?: StudentMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMedications.
     */
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * StudentMedication findFirstOrThrow
   */
  export type StudentMedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter, which StudentMedication to fetch.
     */
    where?: StudentMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMedications to fetch.
     */
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentMedications.
     */
    cursor?: StudentMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentMedications.
     */
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * StudentMedication findMany
   */
  export type StudentMedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter, which StudentMedications to fetch.
     */
    where?: StudentMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentMedications to fetch.
     */
    orderBy?: StudentMedicationOrderByWithRelationInput | StudentMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentMedications.
     */
    cursor?: StudentMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentMedications.
     */
    skip?: number
    distinct?: StudentMedicationScalarFieldEnum | StudentMedicationScalarFieldEnum[]
  }

  /**
   * StudentMedication create
   */
  export type StudentMedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentMedication.
     */
    data: XOR<StudentMedicationCreateInput, StudentMedicationUncheckedCreateInput>
  }

  /**
   * StudentMedication createMany
   */
  export type StudentMedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentMedications.
     */
    data: StudentMedicationCreateManyInput | StudentMedicationCreateManyInput[]
  }

  /**
   * StudentMedication update
   */
  export type StudentMedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentMedication.
     */
    data: XOR<StudentMedicationUpdateInput, StudentMedicationUncheckedUpdateInput>
    /**
     * Choose, which StudentMedication to update.
     */
    where: StudentMedicationWhereUniqueInput
  }

  /**
   * StudentMedication updateMany
   */
  export type StudentMedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentMedications.
     */
    data: XOR<StudentMedicationUpdateManyMutationInput, StudentMedicationUncheckedUpdateManyInput>
    /**
     * Filter which StudentMedications to update
     */
    where?: StudentMedicationWhereInput
    /**
     * Limit how many StudentMedications to update.
     */
    limit?: number
  }

  /**
   * StudentMedication upsert
   */
  export type StudentMedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentMedication to update in case it exists.
     */
    where: StudentMedicationWhereUniqueInput
    /**
     * In case the StudentMedication found by the `where` argument doesn't exist, create a new StudentMedication with this data.
     */
    create: XOR<StudentMedicationCreateInput, StudentMedicationUncheckedCreateInput>
    /**
     * In case the StudentMedication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentMedicationUpdateInput, StudentMedicationUncheckedUpdateInput>
  }

  /**
   * StudentMedication delete
   */
  export type StudentMedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
    /**
     * Filter which StudentMedication to delete.
     */
    where: StudentMedicationWhereUniqueInput
  }

  /**
   * StudentMedication deleteMany
   */
  export type StudentMedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentMedications to delete
     */
    where?: StudentMedicationWhereInput
    /**
     * Limit how many StudentMedications to delete.
     */
    limit?: number
  }

  /**
   * StudentMedication findRaw
   */
  export type StudentMedicationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentMedication aggregateRaw
   */
  export type StudentMedicationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StudentMedication without action
   */
  export type StudentMedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentMedication
     */
    select?: StudentMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentMedication
     */
    omit?: StudentMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentMedicationInclude<ExtArgs> | null
  }


  /**
   * Model MedicalEventMedication
   */

  export type AggregateMedicalEventMedication = {
    _count: MedicalEventMedicationCountAggregateOutputType | null
    _avg: MedicalEventMedicationAvgAggregateOutputType | null
    _sum: MedicalEventMedicationSumAggregateOutputType | null
    _min: MedicalEventMedicationMinAggregateOutputType | null
    _max: MedicalEventMedicationMaxAggregateOutputType | null
  }

  export type MedicalEventMedicationAvgAggregateOutputType = {
    quantityUsed: number | null
  }

  export type MedicalEventMedicationSumAggregateOutputType = {
    quantityUsed: number | null
  }

  export type MedicalEventMedicationMinAggregateOutputType = {
    id: string | null
    medicalEventId: string | null
    medicationId: string | null
    quantityUsed: number | null
    dosageGiven: string | null
    administeredAt: Date | null
    notes: string | null
  }

  export type MedicalEventMedicationMaxAggregateOutputType = {
    id: string | null
    medicalEventId: string | null
    medicationId: string | null
    quantityUsed: number | null
    dosageGiven: string | null
    administeredAt: Date | null
    notes: string | null
  }

  export type MedicalEventMedicationCountAggregateOutputType = {
    id: number
    medicalEventId: number
    medicationId: number
    quantityUsed: number
    dosageGiven: number
    administeredAt: number
    notes: number
    _all: number
  }


  export type MedicalEventMedicationAvgAggregateInputType = {
    quantityUsed?: true
  }

  export type MedicalEventMedicationSumAggregateInputType = {
    quantityUsed?: true
  }

  export type MedicalEventMedicationMinAggregateInputType = {
    id?: true
    medicalEventId?: true
    medicationId?: true
    quantityUsed?: true
    dosageGiven?: true
    administeredAt?: true
    notes?: true
  }

  export type MedicalEventMedicationMaxAggregateInputType = {
    id?: true
    medicalEventId?: true
    medicationId?: true
    quantityUsed?: true
    dosageGiven?: true
    administeredAt?: true
    notes?: true
  }

  export type MedicalEventMedicationCountAggregateInputType = {
    id?: true
    medicalEventId?: true
    medicationId?: true
    quantityUsed?: true
    dosageGiven?: true
    administeredAt?: true
    notes?: true
    _all?: true
  }

  export type MedicalEventMedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalEventMedication to aggregate.
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEventMedications to fetch.
     */
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalEventMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEventMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEventMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalEventMedications
    **/
    _count?: true | MedicalEventMedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalEventMedicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalEventMedicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalEventMedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalEventMedicationMaxAggregateInputType
  }

  export type GetMedicalEventMedicationAggregateType<T extends MedicalEventMedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalEventMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalEventMedication[P]>
      : GetScalarType<T[P], AggregateMedicalEventMedication[P]>
  }




  export type MedicalEventMedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalEventMedicationWhereInput
    orderBy?: MedicalEventMedicationOrderByWithAggregationInput | MedicalEventMedicationOrderByWithAggregationInput[]
    by: MedicalEventMedicationScalarFieldEnum[] | MedicalEventMedicationScalarFieldEnum
    having?: MedicalEventMedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalEventMedicationCountAggregateInputType | true
    _avg?: MedicalEventMedicationAvgAggregateInputType
    _sum?: MedicalEventMedicationSumAggregateInputType
    _min?: MedicalEventMedicationMinAggregateInputType
    _max?: MedicalEventMedicationMaxAggregateInputType
  }

  export type MedicalEventMedicationGroupByOutputType = {
    id: string
    medicalEventId: string
    medicationId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date
    notes: string | null
    _count: MedicalEventMedicationCountAggregateOutputType | null
    _avg: MedicalEventMedicationAvgAggregateOutputType | null
    _sum: MedicalEventMedicationSumAggregateOutputType | null
    _min: MedicalEventMedicationMinAggregateOutputType | null
    _max: MedicalEventMedicationMaxAggregateOutputType | null
  }

  type GetMedicalEventMedicationGroupByPayload<T extends MedicalEventMedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalEventMedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalEventMedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalEventMedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalEventMedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicalEventMedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalEventId?: boolean
    medicationId?: boolean
    quantityUsed?: boolean
    dosageGiven?: boolean
    administeredAt?: boolean
    notes?: boolean
    medicalEvent?: boolean | MedicalEventDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalEventMedication"]>



  export type MedicalEventMedicationSelectScalar = {
    id?: boolean
    medicalEventId?: boolean
    medicationId?: boolean
    quantityUsed?: boolean
    dosageGiven?: boolean
    administeredAt?: boolean
    notes?: boolean
  }

  export type MedicalEventMedicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalEventId" | "medicationId" | "quantityUsed" | "dosageGiven" | "administeredAt" | "notes", ExtArgs["result"]["medicalEventMedication"]>
  export type MedicalEventMedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalEvent?: boolean | MedicalEventDefaultArgs<ExtArgs>
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }

  export type $MedicalEventMedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalEventMedication"
    objects: {
      medicalEvent: Prisma.$MedicalEventPayload<ExtArgs>
      medication: Prisma.$MedicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicalEventId: string
      medicationId: string
      quantityUsed: number
      dosageGiven: string
      administeredAt: Date
      notes: string | null
    }, ExtArgs["result"]["medicalEventMedication"]>
    composites: {}
  }

  type MedicalEventMedicationGetPayload<S extends boolean | null | undefined | MedicalEventMedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicalEventMedicationPayload, S>

  type MedicalEventMedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalEventMedicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalEventMedicationCountAggregateInputType | true
    }

  export interface MedicalEventMedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalEventMedication'], meta: { name: 'MedicalEventMedication' } }
    /**
     * Find zero or one MedicalEventMedication that matches the filter.
     * @param {MedicalEventMedicationFindUniqueArgs} args - Arguments to find a MedicalEventMedication
     * @example
     * // Get one MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalEventMedicationFindUniqueArgs>(args: SelectSubset<T, MedicalEventMedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalEventMedication that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalEventMedicationFindUniqueOrThrowArgs} args - Arguments to find a MedicalEventMedication
     * @example
     * // Get one MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalEventMedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalEventMedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalEventMedication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationFindFirstArgs} args - Arguments to find a MedicalEventMedication
     * @example
     * // Get one MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalEventMedicationFindFirstArgs>(args?: SelectSubset<T, MedicalEventMedicationFindFirstArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalEventMedication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationFindFirstOrThrowArgs} args - Arguments to find a MedicalEventMedication
     * @example
     * // Get one MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalEventMedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalEventMedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalEventMedications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalEventMedications
     * const medicalEventMedications = await prisma.medicalEventMedication.findMany()
     * 
     * // Get first 10 MedicalEventMedications
     * const medicalEventMedications = await prisma.medicalEventMedication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalEventMedicationWithIdOnly = await prisma.medicalEventMedication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalEventMedicationFindManyArgs>(args?: SelectSubset<T, MedicalEventMedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalEventMedication.
     * @param {MedicalEventMedicationCreateArgs} args - Arguments to create a MedicalEventMedication.
     * @example
     * // Create one MedicalEventMedication
     * const MedicalEventMedication = await prisma.medicalEventMedication.create({
     *   data: {
     *     // ... data to create a MedicalEventMedication
     *   }
     * })
     * 
     */
    create<T extends MedicalEventMedicationCreateArgs>(args: SelectSubset<T, MedicalEventMedicationCreateArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalEventMedications.
     * @param {MedicalEventMedicationCreateManyArgs} args - Arguments to create many MedicalEventMedications.
     * @example
     * // Create many MedicalEventMedications
     * const medicalEventMedication = await prisma.medicalEventMedication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalEventMedicationCreateManyArgs>(args?: SelectSubset<T, MedicalEventMedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalEventMedication.
     * @param {MedicalEventMedicationDeleteArgs} args - Arguments to delete one MedicalEventMedication.
     * @example
     * // Delete one MedicalEventMedication
     * const MedicalEventMedication = await prisma.medicalEventMedication.delete({
     *   where: {
     *     // ... filter to delete one MedicalEventMedication
     *   }
     * })
     * 
     */
    delete<T extends MedicalEventMedicationDeleteArgs>(args: SelectSubset<T, MedicalEventMedicationDeleteArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalEventMedication.
     * @param {MedicalEventMedicationUpdateArgs} args - Arguments to update one MedicalEventMedication.
     * @example
     * // Update one MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalEventMedicationUpdateArgs>(args: SelectSubset<T, MedicalEventMedicationUpdateArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalEventMedications.
     * @param {MedicalEventMedicationDeleteManyArgs} args - Arguments to filter MedicalEventMedications to delete.
     * @example
     * // Delete a few MedicalEventMedications
     * const { count } = await prisma.medicalEventMedication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalEventMedicationDeleteManyArgs>(args?: SelectSubset<T, MedicalEventMedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalEventMedications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalEventMedications
     * const medicalEventMedication = await prisma.medicalEventMedication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalEventMedicationUpdateManyArgs>(args: SelectSubset<T, MedicalEventMedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalEventMedication.
     * @param {MedicalEventMedicationUpsertArgs} args - Arguments to update or create a MedicalEventMedication.
     * @example
     * // Update or create a MedicalEventMedication
     * const medicalEventMedication = await prisma.medicalEventMedication.upsert({
     *   create: {
     *     // ... data to create a MedicalEventMedication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalEventMedication we want to update
     *   }
     * })
     */
    upsert<T extends MedicalEventMedicationUpsertArgs>(args: SelectSubset<T, MedicalEventMedicationUpsertArgs<ExtArgs>>): Prisma__MedicalEventMedicationClient<$Result.GetResult<Prisma.$MedicalEventMedicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalEventMedications that matches the filter.
     * @param {MedicalEventMedicationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medicalEventMedication = await prisma.medicalEventMedication.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicalEventMedicationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MedicalEventMedication.
     * @param {MedicalEventMedicationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medicalEventMedication = await prisma.medicalEventMedication.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicalEventMedicationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MedicalEventMedications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationCountArgs} args - Arguments to filter MedicalEventMedications to count.
     * @example
     * // Count the number of MedicalEventMedications
     * const count = await prisma.medicalEventMedication.count({
     *   where: {
     *     // ... the filter for the MedicalEventMedications we want to count
     *   }
     * })
    **/
    count<T extends MedicalEventMedicationCountArgs>(
      args?: Subset<T, MedicalEventMedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalEventMedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalEventMedication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalEventMedicationAggregateArgs>(args: Subset<T, MedicalEventMedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicalEventMedicationAggregateType<T>>

    /**
     * Group by MedicalEventMedication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalEventMedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalEventMedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalEventMedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicalEventMedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalEventMedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalEventMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalEventMedication model
   */
  readonly fields: MedicalEventMedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalEventMedication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalEventMedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalEvent<T extends MedicalEventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalEventDefaultArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalEventMedication model
   */
  interface MedicalEventMedicationFieldRefs {
    readonly id: FieldRef<"MedicalEventMedication", 'String'>
    readonly medicalEventId: FieldRef<"MedicalEventMedication", 'String'>
    readonly medicationId: FieldRef<"MedicalEventMedication", 'String'>
    readonly quantityUsed: FieldRef<"MedicalEventMedication", 'Int'>
    readonly dosageGiven: FieldRef<"MedicalEventMedication", 'String'>
    readonly administeredAt: FieldRef<"MedicalEventMedication", 'DateTime'>
    readonly notes: FieldRef<"MedicalEventMedication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MedicalEventMedication findUnique
   */
  export type MedicalEventMedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEventMedication to fetch.
     */
    where: MedicalEventMedicationWhereUniqueInput
  }

  /**
   * MedicalEventMedication findUniqueOrThrow
   */
  export type MedicalEventMedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEventMedication to fetch.
     */
    where: MedicalEventMedicationWhereUniqueInput
  }

  /**
   * MedicalEventMedication findFirst
   */
  export type MedicalEventMedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEventMedication to fetch.
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEventMedications to fetch.
     */
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalEventMedications.
     */
    cursor?: MedicalEventMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEventMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEventMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalEventMedications.
     */
    distinct?: MedicalEventMedicationScalarFieldEnum | MedicalEventMedicationScalarFieldEnum[]
  }

  /**
   * MedicalEventMedication findFirstOrThrow
   */
  export type MedicalEventMedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEventMedication to fetch.
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEventMedications to fetch.
     */
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalEventMedications.
     */
    cursor?: MedicalEventMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEventMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEventMedications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalEventMedications.
     */
    distinct?: MedicalEventMedicationScalarFieldEnum | MedicalEventMedicationScalarFieldEnum[]
  }

  /**
   * MedicalEventMedication findMany
   */
  export type MedicalEventMedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter, which MedicalEventMedications to fetch.
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalEventMedications to fetch.
     */
    orderBy?: MedicalEventMedicationOrderByWithRelationInput | MedicalEventMedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalEventMedications.
     */
    cursor?: MedicalEventMedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalEventMedications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalEventMedications.
     */
    skip?: number
    distinct?: MedicalEventMedicationScalarFieldEnum | MedicalEventMedicationScalarFieldEnum[]
  }

  /**
   * MedicalEventMedication create
   */
  export type MedicalEventMedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalEventMedication.
     */
    data: XOR<MedicalEventMedicationCreateInput, MedicalEventMedicationUncheckedCreateInput>
  }

  /**
   * MedicalEventMedication createMany
   */
  export type MedicalEventMedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalEventMedications.
     */
    data: MedicalEventMedicationCreateManyInput | MedicalEventMedicationCreateManyInput[]
  }

  /**
   * MedicalEventMedication update
   */
  export type MedicalEventMedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalEventMedication.
     */
    data: XOR<MedicalEventMedicationUpdateInput, MedicalEventMedicationUncheckedUpdateInput>
    /**
     * Choose, which MedicalEventMedication to update.
     */
    where: MedicalEventMedicationWhereUniqueInput
  }

  /**
   * MedicalEventMedication updateMany
   */
  export type MedicalEventMedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalEventMedications.
     */
    data: XOR<MedicalEventMedicationUpdateManyMutationInput, MedicalEventMedicationUncheckedUpdateManyInput>
    /**
     * Filter which MedicalEventMedications to update
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * Limit how many MedicalEventMedications to update.
     */
    limit?: number
  }

  /**
   * MedicalEventMedication upsert
   */
  export type MedicalEventMedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalEventMedication to update in case it exists.
     */
    where: MedicalEventMedicationWhereUniqueInput
    /**
     * In case the MedicalEventMedication found by the `where` argument doesn't exist, create a new MedicalEventMedication with this data.
     */
    create: XOR<MedicalEventMedicationCreateInput, MedicalEventMedicationUncheckedCreateInput>
    /**
     * In case the MedicalEventMedication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalEventMedicationUpdateInput, MedicalEventMedicationUncheckedUpdateInput>
  }

  /**
   * MedicalEventMedication delete
   */
  export type MedicalEventMedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
    /**
     * Filter which MedicalEventMedication to delete.
     */
    where: MedicalEventMedicationWhereUniqueInput
  }

  /**
   * MedicalEventMedication deleteMany
   */
  export type MedicalEventMedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalEventMedications to delete
     */
    where?: MedicalEventMedicationWhereInput
    /**
     * Limit how many MedicalEventMedications to delete.
     */
    limit?: number
  }

  /**
   * MedicalEventMedication findRaw
   */
  export type MedicalEventMedicationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalEventMedication aggregateRaw
   */
  export type MedicalEventMedicationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalEventMedication without action
   */
  export type MedicalEventMedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEventMedication
     */
    select?: MedicalEventMedicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEventMedication
     */
    omit?: MedicalEventMedicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventMedicationInclude<ExtArgs> | null
  }


  /**
   * Model StockMovement
   */

  export type AggregateStockMovement = {
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  export type StockMovementAvgAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementSumAggregateOutputType = {
    quantity: number | null
  }

  export type StockMovementMinAggregateOutputType = {
    id: string | null
    medicationId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type StockMovementMaxAggregateOutputType = {
    id: string | null
    medicationId: string | null
    type: string | null
    quantity: number | null
    reason: string | null
    reference: string | null
    createdAt: Date | null
  }

  export type StockMovementCountAggregateOutputType = {
    id: number
    medicationId: number
    type: number
    quantity: number
    reason: number
    reference: number
    createdAt: number
    _all: number
  }


  export type StockMovementAvgAggregateInputType = {
    quantity?: true
  }

  export type StockMovementSumAggregateInputType = {
    quantity?: true
  }

  export type StockMovementMinAggregateInputType = {
    id?: true
    medicationId?: true
    type?: true
    quantity?: true
    reason?: true
    reference?: true
    createdAt?: true
  }

  export type StockMovementMaxAggregateInputType = {
    id?: true
    medicationId?: true
    type?: true
    quantity?: true
    reason?: true
    reference?: true
    createdAt?: true
  }

  export type StockMovementCountAggregateInputType = {
    id?: true
    medicationId?: true
    type?: true
    quantity?: true
    reason?: true
    reference?: true
    createdAt?: true
    _all?: true
  }

  export type StockMovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovement to aggregate.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StockMovements
    **/
    _count?: true | StockMovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StockMovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StockMovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StockMovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StockMovementMaxAggregateInputType
  }

  export type GetStockMovementAggregateType<T extends StockMovementAggregateArgs> = {
        [P in keyof T & keyof AggregateStockMovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStockMovement[P]>
      : GetScalarType<T[P], AggregateStockMovement[P]>
  }




  export type StockMovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StockMovementWhereInput
    orderBy?: StockMovementOrderByWithAggregationInput | StockMovementOrderByWithAggregationInput[]
    by: StockMovementScalarFieldEnum[] | StockMovementScalarFieldEnum
    having?: StockMovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StockMovementCountAggregateInputType | true
    _avg?: StockMovementAvgAggregateInputType
    _sum?: StockMovementSumAggregateInputType
    _min?: StockMovementMinAggregateInputType
    _max?: StockMovementMaxAggregateInputType
  }

  export type StockMovementGroupByOutputType = {
    id: string
    medicationId: string
    type: string
    quantity: number
    reason: string | null
    reference: string | null
    createdAt: Date
    _count: StockMovementCountAggregateOutputType | null
    _avg: StockMovementAvgAggregateOutputType | null
    _sum: StockMovementSumAggregateOutputType | null
    _min: StockMovementMinAggregateOutputType | null
    _max: StockMovementMaxAggregateOutputType | null
  }

  type GetStockMovementGroupByPayload<T extends StockMovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StockMovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StockMovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
            : GetScalarType<T[P], StockMovementGroupByOutputType[P]>
        }
      >
    >


  export type StockMovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicationId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stockMovement"]>



  export type StockMovementSelectScalar = {
    id?: boolean
    medicationId?: boolean
    type?: boolean
    quantity?: boolean
    reason?: boolean
    reference?: boolean
    createdAt?: boolean
  }

  export type StockMovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicationId" | "type" | "quantity" | "reason" | "reference" | "createdAt", ExtArgs["result"]["stockMovement"]>
  export type StockMovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medication?: boolean | MedicationDefaultArgs<ExtArgs>
  }

  export type $StockMovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StockMovement"
    objects: {
      medication: Prisma.$MedicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicationId: string
      type: string
      quantity: number
      reason: string | null
      reference: string | null
      createdAt: Date
    }, ExtArgs["result"]["stockMovement"]>
    composites: {}
  }

  type StockMovementGetPayload<S extends boolean | null | undefined | StockMovementDefaultArgs> = $Result.GetResult<Prisma.$StockMovementPayload, S>

  type StockMovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StockMovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StockMovementCountAggregateInputType | true
    }

  export interface StockMovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StockMovement'], meta: { name: 'StockMovement' } }
    /**
     * Find zero or one StockMovement that matches the filter.
     * @param {StockMovementFindUniqueArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StockMovementFindUniqueArgs>(args: SelectSubset<T, StockMovementFindUniqueArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StockMovement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StockMovementFindUniqueOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StockMovementFindUniqueOrThrowArgs>(args: SelectSubset<T, StockMovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StockMovementFindFirstArgs>(args?: SelectSubset<T, StockMovementFindFirstArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StockMovement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindFirstOrThrowArgs} args - Arguments to find a StockMovement
     * @example
     * // Get one StockMovement
     * const stockMovement = await prisma.stockMovement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StockMovementFindFirstOrThrowArgs>(args?: SelectSubset<T, StockMovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockMovements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StockMovements
     * const stockMovements = await prisma.stockMovement.findMany()
     * 
     * // Get first 10 StockMovements
     * const stockMovements = await prisma.stockMovement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stockMovementWithIdOnly = await prisma.stockMovement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StockMovementFindManyArgs>(args?: SelectSubset<T, StockMovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StockMovement.
     * @param {StockMovementCreateArgs} args - Arguments to create a StockMovement.
     * @example
     * // Create one StockMovement
     * const StockMovement = await prisma.stockMovement.create({
     *   data: {
     *     // ... data to create a StockMovement
     *   }
     * })
     * 
     */
    create<T extends StockMovementCreateArgs>(args: SelectSubset<T, StockMovementCreateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StockMovements.
     * @param {StockMovementCreateManyArgs} args - Arguments to create many StockMovements.
     * @example
     * // Create many StockMovements
     * const stockMovement = await prisma.stockMovement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StockMovementCreateManyArgs>(args?: SelectSubset<T, StockMovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StockMovement.
     * @param {StockMovementDeleteArgs} args - Arguments to delete one StockMovement.
     * @example
     * // Delete one StockMovement
     * const StockMovement = await prisma.stockMovement.delete({
     *   where: {
     *     // ... filter to delete one StockMovement
     *   }
     * })
     * 
     */
    delete<T extends StockMovementDeleteArgs>(args: SelectSubset<T, StockMovementDeleteArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StockMovement.
     * @param {StockMovementUpdateArgs} args - Arguments to update one StockMovement.
     * @example
     * // Update one StockMovement
     * const stockMovement = await prisma.stockMovement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StockMovementUpdateArgs>(args: SelectSubset<T, StockMovementUpdateArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StockMovements.
     * @param {StockMovementDeleteManyArgs} args - Arguments to filter StockMovements to delete.
     * @example
     * // Delete a few StockMovements
     * const { count } = await prisma.stockMovement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StockMovementDeleteManyArgs>(args?: SelectSubset<T, StockMovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StockMovements
     * const stockMovement = await prisma.stockMovement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StockMovementUpdateManyArgs>(args: SelectSubset<T, StockMovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StockMovement.
     * @param {StockMovementUpsertArgs} args - Arguments to update or create a StockMovement.
     * @example
     * // Update or create a StockMovement
     * const stockMovement = await prisma.stockMovement.upsert({
     *   create: {
     *     // ... data to create a StockMovement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StockMovement we want to update
     *   }
     * })
     */
    upsert<T extends StockMovementUpsertArgs>(args: SelectSubset<T, StockMovementUpsertArgs<ExtArgs>>): Prisma__StockMovementClient<$Result.GetResult<Prisma.$StockMovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StockMovements that matches the filter.
     * @param {StockMovementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const stockMovement = await prisma.stockMovement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: StockMovementFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a StockMovement.
     * @param {StockMovementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const stockMovement = await prisma.stockMovement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: StockMovementAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of StockMovements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementCountArgs} args - Arguments to filter StockMovements to count.
     * @example
     * // Count the number of StockMovements
     * const count = await prisma.stockMovement.count({
     *   where: {
     *     // ... the filter for the StockMovements we want to count
     *   }
     * })
    **/
    count<T extends StockMovementCountArgs>(
      args?: Subset<T, StockMovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StockMovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StockMovementAggregateArgs>(args: Subset<T, StockMovementAggregateArgs>): Prisma.PrismaPromise<GetStockMovementAggregateType<T>>

    /**
     * Group by StockMovement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StockMovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StockMovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StockMovementGroupByArgs['orderBy'] }
        : { orderBy?: StockMovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StockMovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStockMovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StockMovement model
   */
  readonly fields: StockMovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StockMovement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StockMovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medication<T extends MedicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicationDefaultArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StockMovement model
   */
  interface StockMovementFieldRefs {
    readonly id: FieldRef<"StockMovement", 'String'>
    readonly medicationId: FieldRef<"StockMovement", 'String'>
    readonly type: FieldRef<"StockMovement", 'String'>
    readonly quantity: FieldRef<"StockMovement", 'Int'>
    readonly reason: FieldRef<"StockMovement", 'String'>
    readonly reference: FieldRef<"StockMovement", 'String'>
    readonly createdAt: FieldRef<"StockMovement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StockMovement findUnique
   */
  export type StockMovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findUniqueOrThrow
   */
  export type StockMovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement findFirst
   */
  export type StockMovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findFirstOrThrow
   */
  export type StockMovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovement to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StockMovements.
     */
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement findMany
   */
  export type StockMovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter, which StockMovements to fetch.
     */
    where?: StockMovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StockMovements to fetch.
     */
    orderBy?: StockMovementOrderByWithRelationInput | StockMovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StockMovements.
     */
    cursor?: StockMovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StockMovements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StockMovements.
     */
    skip?: number
    distinct?: StockMovementScalarFieldEnum | StockMovementScalarFieldEnum[]
  }

  /**
   * StockMovement create
   */
  export type StockMovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to create a StockMovement.
     */
    data: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
  }

  /**
   * StockMovement createMany
   */
  export type StockMovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StockMovements.
     */
    data: StockMovementCreateManyInput | StockMovementCreateManyInput[]
  }

  /**
   * StockMovement update
   */
  export type StockMovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The data needed to update a StockMovement.
     */
    data: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
    /**
     * Choose, which StockMovement to update.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement updateMany
   */
  export type StockMovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StockMovements.
     */
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyInput>
    /**
     * Filter which StockMovements to update
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to update.
     */
    limit?: number
  }

  /**
   * StockMovement upsert
   */
  export type StockMovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * The filter to search for the StockMovement to update in case it exists.
     */
    where: StockMovementWhereUniqueInput
    /**
     * In case the StockMovement found by the `where` argument doesn't exist, create a new StockMovement with this data.
     */
    create: XOR<StockMovementCreateInput, StockMovementUncheckedCreateInput>
    /**
     * In case the StockMovement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StockMovementUpdateInput, StockMovementUncheckedUpdateInput>
  }

  /**
   * StockMovement delete
   */
  export type StockMovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
    /**
     * Filter which StockMovement to delete.
     */
    where: StockMovementWhereUniqueInput
  }

  /**
   * StockMovement deleteMany
   */
  export type StockMovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StockMovements to delete
     */
    where?: StockMovementWhereInput
    /**
     * Limit how many StockMovements to delete.
     */
    limit?: number
  }

  /**
   * StockMovement findRaw
   */
  export type StockMovementFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StockMovement aggregateRaw
   */
  export type StockMovementAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * StockMovement without action
   */
  export type StockMovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StockMovement
     */
    select?: StockMovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StockMovement
     */
    omit?: StockMovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StockMovementInclude<ExtArgs> | null
  }


  /**
   * Model VaccinationCampaign
   */

  export type AggregateVaccinationCampaign = {
    _count: VaccinationCampaignCountAggregateOutputType | null
    _min: VaccinationCampaignMinAggregateOutputType | null
    _max: VaccinationCampaignMaxAggregateOutputType | null
  }

  export type VaccinationCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    vaccineName: string | null
    scheduledDate: Date | null
    deadline: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaccinationCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    vaccineName: string | null
    scheduledDate: Date | null
    deadline: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaccinationCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    vaccineName: number
    targetGrades: number
    scheduledDate: number
    deadline: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaccinationCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    vaccineName?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaccinationCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    vaccineName?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaccinationCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    vaccineName?: true
    targetGrades?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaccinationCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationCampaign to aggregate.
     */
    where?: VaccinationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationCampaigns to fetch.
     */
    orderBy?: VaccinationCampaignOrderByWithRelationInput | VaccinationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VaccinationCampaigns
    **/
    _count?: true | VaccinationCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationCampaignMaxAggregateInputType
  }

  export type GetVaccinationCampaignAggregateType<T extends VaccinationCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccinationCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccinationCampaign[P]>
      : GetScalarType<T[P], AggregateVaccinationCampaign[P]>
  }




  export type VaccinationCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationCampaignWhereInput
    orderBy?: VaccinationCampaignOrderByWithAggregationInput | VaccinationCampaignOrderByWithAggregationInput[]
    by: VaccinationCampaignScalarFieldEnum[] | VaccinationCampaignScalarFieldEnum
    having?: VaccinationCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationCampaignCountAggregateInputType | true
    _min?: VaccinationCampaignMinAggregateInputType
    _max?: VaccinationCampaignMaxAggregateInputType
  }

  export type VaccinationCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    vaccineName: string
    targetGrades: string[]
    scheduledDate: Date
    deadline: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: VaccinationCampaignCountAggregateOutputType | null
    _min: VaccinationCampaignMinAggregateOutputType | null
    _max: VaccinationCampaignMaxAggregateOutputType | null
  }

  type GetVaccinationCampaignGroupByPayload<T extends VaccinationCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationCampaignGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    vaccineName?: boolean
    targetGrades?: boolean
    scheduledDate?: boolean
    deadline?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vaccinations?: boolean | VaccinationCampaign$vaccinationsArgs<ExtArgs>
    notifications?: boolean | VaccinationCampaign$notificationsArgs<ExtArgs>
    _count?: boolean | VaccinationCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vaccinationCampaign"]>



  export type VaccinationCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    vaccineName?: boolean
    targetGrades?: boolean
    scheduledDate?: boolean
    deadline?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VaccinationCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "vaccineName" | "targetGrades" | "scheduledDate" | "deadline" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["vaccinationCampaign"]>
  export type VaccinationCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vaccinations?: boolean | VaccinationCampaign$vaccinationsArgs<ExtArgs>
    notifications?: boolean | VaccinationCampaign$notificationsArgs<ExtArgs>
    _count?: boolean | VaccinationCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $VaccinationCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VaccinationCampaign"
    objects: {
      vaccinations: Prisma.$VaccinationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      vaccineName: string
      targetGrades: string[]
      scheduledDate: Date
      deadline: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vaccinationCampaign"]>
    composites: {}
  }

  type VaccinationCampaignGetPayload<S extends boolean | null | undefined | VaccinationCampaignDefaultArgs> = $Result.GetResult<Prisma.$VaccinationCampaignPayload, S>

  type VaccinationCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationCampaignCountAggregateInputType | true
    }

  export interface VaccinationCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VaccinationCampaign'], meta: { name: 'VaccinationCampaign' } }
    /**
     * Find zero or one VaccinationCampaign that matches the filter.
     * @param {VaccinationCampaignFindUniqueArgs} args - Arguments to find a VaccinationCampaign
     * @example
     * // Get one VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationCampaignFindUniqueArgs>(args: SelectSubset<T, VaccinationCampaignFindUniqueArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VaccinationCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationCampaignFindUniqueOrThrowArgs} args - Arguments to find a VaccinationCampaign
     * @example
     * // Get one VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignFindFirstArgs} args - Arguments to find a VaccinationCampaign
     * @example
     * // Get one VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationCampaignFindFirstArgs>(args?: SelectSubset<T, VaccinationCampaignFindFirstArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VaccinationCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignFindFirstOrThrowArgs} args - Arguments to find a VaccinationCampaign
     * @example
     * // Get one VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccinationCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VaccinationCampaigns
     * const vaccinationCampaigns = await prisma.vaccinationCampaign.findMany()
     * 
     * // Get first 10 VaccinationCampaigns
     * const vaccinationCampaigns = await prisma.vaccinationCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationCampaignWithIdOnly = await prisma.vaccinationCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationCampaignFindManyArgs>(args?: SelectSubset<T, VaccinationCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VaccinationCampaign.
     * @param {VaccinationCampaignCreateArgs} args - Arguments to create a VaccinationCampaign.
     * @example
     * // Create one VaccinationCampaign
     * const VaccinationCampaign = await prisma.vaccinationCampaign.create({
     *   data: {
     *     // ... data to create a VaccinationCampaign
     *   }
     * })
     * 
     */
    create<T extends VaccinationCampaignCreateArgs>(args: SelectSubset<T, VaccinationCampaignCreateArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VaccinationCampaigns.
     * @param {VaccinationCampaignCreateManyArgs} args - Arguments to create many VaccinationCampaigns.
     * @example
     * // Create many VaccinationCampaigns
     * const vaccinationCampaign = await prisma.vaccinationCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationCampaignCreateManyArgs>(args?: SelectSubset<T, VaccinationCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VaccinationCampaign.
     * @param {VaccinationCampaignDeleteArgs} args - Arguments to delete one VaccinationCampaign.
     * @example
     * // Delete one VaccinationCampaign
     * const VaccinationCampaign = await prisma.vaccinationCampaign.delete({
     *   where: {
     *     // ... filter to delete one VaccinationCampaign
     *   }
     * })
     * 
     */
    delete<T extends VaccinationCampaignDeleteArgs>(args: SelectSubset<T, VaccinationCampaignDeleteArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VaccinationCampaign.
     * @param {VaccinationCampaignUpdateArgs} args - Arguments to update one VaccinationCampaign.
     * @example
     * // Update one VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationCampaignUpdateArgs>(args: SelectSubset<T, VaccinationCampaignUpdateArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VaccinationCampaigns.
     * @param {VaccinationCampaignDeleteManyArgs} args - Arguments to filter VaccinationCampaigns to delete.
     * @example
     * // Delete a few VaccinationCampaigns
     * const { count } = await prisma.vaccinationCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationCampaignDeleteManyArgs>(args?: SelectSubset<T, VaccinationCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VaccinationCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VaccinationCampaigns
     * const vaccinationCampaign = await prisma.vaccinationCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationCampaignUpdateManyArgs>(args: SelectSubset<T, VaccinationCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VaccinationCampaign.
     * @param {VaccinationCampaignUpsertArgs} args - Arguments to update or create a VaccinationCampaign.
     * @example
     * // Update or create a VaccinationCampaign
     * const vaccinationCampaign = await prisma.vaccinationCampaign.upsert({
     *   create: {
     *     // ... data to create a VaccinationCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VaccinationCampaign we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationCampaignUpsertArgs>(args: SelectSubset<T, VaccinationCampaignUpsertArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VaccinationCampaigns that matches the filter.
     * @param {VaccinationCampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vaccinationCampaign = await prisma.vaccinationCampaign.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VaccinationCampaignFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a VaccinationCampaign.
     * @param {VaccinationCampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vaccinationCampaign = await prisma.vaccinationCampaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VaccinationCampaignAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of VaccinationCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignCountArgs} args - Arguments to filter VaccinationCampaigns to count.
     * @example
     * // Count the number of VaccinationCampaigns
     * const count = await prisma.vaccinationCampaign.count({
     *   where: {
     *     // ... the filter for the VaccinationCampaigns we want to count
     *   }
     * })
    **/
    count<T extends VaccinationCampaignCountArgs>(
      args?: Subset<T, VaccinationCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VaccinationCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationCampaignAggregateArgs>(args: Subset<T, VaccinationCampaignAggregateArgs>): Prisma.PrismaPromise<GetVaccinationCampaignAggregateType<T>>

    /**
     * Group by VaccinationCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationCampaignGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VaccinationCampaign model
   */
  readonly fields: VaccinationCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VaccinationCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vaccinations<T extends VaccinationCampaign$vaccinationsArgs<ExtArgs> = {}>(args?: Subset<T, VaccinationCampaign$vaccinationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends VaccinationCampaign$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, VaccinationCampaign$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VaccinationCampaign model
   */
  interface VaccinationCampaignFieldRefs {
    readonly id: FieldRef<"VaccinationCampaign", 'String'>
    readonly name: FieldRef<"VaccinationCampaign", 'String'>
    readonly description: FieldRef<"VaccinationCampaign", 'String'>
    readonly vaccineName: FieldRef<"VaccinationCampaign", 'String'>
    readonly targetGrades: FieldRef<"VaccinationCampaign", 'String[]'>
    readonly scheduledDate: FieldRef<"VaccinationCampaign", 'DateTime'>
    readonly deadline: FieldRef<"VaccinationCampaign", 'DateTime'>
    readonly isActive: FieldRef<"VaccinationCampaign", 'Boolean'>
    readonly createdAt: FieldRef<"VaccinationCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"VaccinationCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VaccinationCampaign findUnique
   */
  export type VaccinationCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationCampaign to fetch.
     */
    where: VaccinationCampaignWhereUniqueInput
  }

  /**
   * VaccinationCampaign findUniqueOrThrow
   */
  export type VaccinationCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationCampaign to fetch.
     */
    where: VaccinationCampaignWhereUniqueInput
  }

  /**
   * VaccinationCampaign findFirst
   */
  export type VaccinationCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationCampaign to fetch.
     */
    where?: VaccinationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationCampaigns to fetch.
     */
    orderBy?: VaccinationCampaignOrderByWithRelationInput | VaccinationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationCampaigns.
     */
    cursor?: VaccinationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationCampaigns.
     */
    distinct?: VaccinationCampaignScalarFieldEnum | VaccinationCampaignScalarFieldEnum[]
  }

  /**
   * VaccinationCampaign findFirstOrThrow
   */
  export type VaccinationCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationCampaign to fetch.
     */
    where?: VaccinationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationCampaigns to fetch.
     */
    orderBy?: VaccinationCampaignOrderByWithRelationInput | VaccinationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VaccinationCampaigns.
     */
    cursor?: VaccinationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VaccinationCampaigns.
     */
    distinct?: VaccinationCampaignScalarFieldEnum | VaccinationCampaignScalarFieldEnum[]
  }

  /**
   * VaccinationCampaign findMany
   */
  export type VaccinationCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter, which VaccinationCampaigns to fetch.
     */
    where?: VaccinationCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VaccinationCampaigns to fetch.
     */
    orderBy?: VaccinationCampaignOrderByWithRelationInput | VaccinationCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VaccinationCampaigns.
     */
    cursor?: VaccinationCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VaccinationCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VaccinationCampaigns.
     */
    skip?: number
    distinct?: VaccinationCampaignScalarFieldEnum | VaccinationCampaignScalarFieldEnum[]
  }

  /**
   * VaccinationCampaign create
   */
  export type VaccinationCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a VaccinationCampaign.
     */
    data: XOR<VaccinationCampaignCreateInput, VaccinationCampaignUncheckedCreateInput>
  }

  /**
   * VaccinationCampaign createMany
   */
  export type VaccinationCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VaccinationCampaigns.
     */
    data: VaccinationCampaignCreateManyInput | VaccinationCampaignCreateManyInput[]
  }

  /**
   * VaccinationCampaign update
   */
  export type VaccinationCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a VaccinationCampaign.
     */
    data: XOR<VaccinationCampaignUpdateInput, VaccinationCampaignUncheckedUpdateInput>
    /**
     * Choose, which VaccinationCampaign to update.
     */
    where: VaccinationCampaignWhereUniqueInput
  }

  /**
   * VaccinationCampaign updateMany
   */
  export type VaccinationCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VaccinationCampaigns.
     */
    data: XOR<VaccinationCampaignUpdateManyMutationInput, VaccinationCampaignUncheckedUpdateManyInput>
    /**
     * Filter which VaccinationCampaigns to update
     */
    where?: VaccinationCampaignWhereInput
    /**
     * Limit how many VaccinationCampaigns to update.
     */
    limit?: number
  }

  /**
   * VaccinationCampaign upsert
   */
  export type VaccinationCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the VaccinationCampaign to update in case it exists.
     */
    where: VaccinationCampaignWhereUniqueInput
    /**
     * In case the VaccinationCampaign found by the `where` argument doesn't exist, create a new VaccinationCampaign with this data.
     */
    create: XOR<VaccinationCampaignCreateInput, VaccinationCampaignUncheckedCreateInput>
    /**
     * In case the VaccinationCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationCampaignUpdateInput, VaccinationCampaignUncheckedUpdateInput>
  }

  /**
   * VaccinationCampaign delete
   */
  export type VaccinationCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    /**
     * Filter which VaccinationCampaign to delete.
     */
    where: VaccinationCampaignWhereUniqueInput
  }

  /**
   * VaccinationCampaign deleteMany
   */
  export type VaccinationCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VaccinationCampaigns to delete
     */
    where?: VaccinationCampaignWhereInput
    /**
     * Limit how many VaccinationCampaigns to delete.
     */
    limit?: number
  }

  /**
   * VaccinationCampaign findRaw
   */
  export type VaccinationCampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VaccinationCampaign aggregateRaw
   */
  export type VaccinationCampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * VaccinationCampaign.vaccinations
   */
  export type VaccinationCampaign$vaccinationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    cursor?: VaccinationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * VaccinationCampaign.notifications
   */
  export type VaccinationCampaign$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * VaccinationCampaign without action
   */
  export type VaccinationCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
  }


  /**
   * Model Vaccination
   */

  export type AggregateVaccination = {
    _count: VaccinationCountAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  export type VaccinationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    campaignId: string | null
    nurseId: string | null
    status: $Enums.VaccinationStatus | null
    scheduledDate: Date | null
    administeredDate: Date | null
    dose: string | null
    batch: string | null
    sideEffects: string | null
    notes: string | null
    parentConsent: boolean | null
    consentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaccinationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    campaignId: string | null
    nurseId: string | null
    status: $Enums.VaccinationStatus | null
    scheduledDate: Date | null
    administeredDate: Date | null
    dose: string | null
    batch: string | null
    sideEffects: string | null
    notes: string | null
    parentConsent: boolean | null
    consentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VaccinationCountAggregateOutputType = {
    id: number
    studentId: number
    campaignId: number
    nurseId: number
    status: number
    scheduledDate: number
    administeredDate: number
    dose: number
    batch: number
    sideEffects: number
    notes: number
    parentConsent: number
    consentDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VaccinationMinAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    administeredDate?: true
    dose?: true
    batch?: true
    sideEffects?: true
    notes?: true
    parentConsent?: true
    consentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaccinationMaxAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    administeredDate?: true
    dose?: true
    batch?: true
    sideEffects?: true
    notes?: true
    parentConsent?: true
    consentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VaccinationCountAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    administeredDate?: true
    dose?: true
    batch?: true
    sideEffects?: true
    notes?: true
    parentConsent?: true
    consentDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VaccinationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccination to aggregate.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vaccinations
    **/
    _count?: true | VaccinationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VaccinationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VaccinationMaxAggregateInputType
  }

  export type GetVaccinationAggregateType<T extends VaccinationAggregateArgs> = {
        [P in keyof T & keyof AggregateVaccination]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVaccination[P]>
      : GetScalarType<T[P], AggregateVaccination[P]>
  }




  export type VaccinationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VaccinationWhereInput
    orderBy?: VaccinationOrderByWithAggregationInput | VaccinationOrderByWithAggregationInput[]
    by: VaccinationScalarFieldEnum[] | VaccinationScalarFieldEnum
    having?: VaccinationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VaccinationCountAggregateInputType | true
    _min?: VaccinationMinAggregateInputType
    _max?: VaccinationMaxAggregateInputType
  }

  export type VaccinationGroupByOutputType = {
    id: string
    studentId: string
    campaignId: string
    nurseId: string | null
    status: $Enums.VaccinationStatus
    scheduledDate: Date
    administeredDate: Date | null
    dose: string | null
    batch: string | null
    sideEffects: string | null
    notes: string | null
    parentConsent: boolean
    consentDate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: VaccinationCountAggregateOutputType | null
    _min: VaccinationMinAggregateOutputType | null
    _max: VaccinationMaxAggregateOutputType | null
  }

  type GetVaccinationGroupByPayload<T extends VaccinationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VaccinationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VaccinationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
            : GetScalarType<T[P], VaccinationGroupByOutputType[P]>
        }
      >
    >


  export type VaccinationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    campaignId?: boolean
    nurseId?: boolean
    status?: boolean
    scheduledDate?: boolean
    administeredDate?: boolean
    dose?: boolean
    batch?: boolean
    sideEffects?: boolean
    notes?: boolean
    parentConsent?: boolean
    consentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    campaign?: boolean | VaccinationCampaignDefaultArgs<ExtArgs>
    nurse?: boolean | Vaccination$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["vaccination"]>



  export type VaccinationSelectScalar = {
    id?: boolean
    studentId?: boolean
    campaignId?: boolean
    nurseId?: boolean
    status?: boolean
    scheduledDate?: boolean
    administeredDate?: boolean
    dose?: boolean
    batch?: boolean
    sideEffects?: boolean
    notes?: boolean
    parentConsent?: boolean
    consentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VaccinationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "campaignId" | "nurseId" | "status" | "scheduledDate" | "administeredDate" | "dose" | "batch" | "sideEffects" | "notes" | "parentConsent" | "consentDate" | "createdAt" | "updatedAt", ExtArgs["result"]["vaccination"]>
  export type VaccinationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    campaign?: boolean | VaccinationCampaignDefaultArgs<ExtArgs>
    nurse?: boolean | Vaccination$nurseArgs<ExtArgs>
  }

  export type $VaccinationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vaccination"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      campaign: Prisma.$VaccinationCampaignPayload<ExtArgs>
      nurse: Prisma.$SchoolNursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      campaignId: string
      nurseId: string | null
      status: $Enums.VaccinationStatus
      scheduledDate: Date
      administeredDate: Date | null
      dose: string | null
      batch: string | null
      sideEffects: string | null
      notes: string | null
      parentConsent: boolean
      consentDate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vaccination"]>
    composites: {}
  }

  type VaccinationGetPayload<S extends boolean | null | undefined | VaccinationDefaultArgs> = $Result.GetResult<Prisma.$VaccinationPayload, S>

  type VaccinationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VaccinationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VaccinationCountAggregateInputType | true
    }

  export interface VaccinationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vaccination'], meta: { name: 'Vaccination' } }
    /**
     * Find zero or one Vaccination that matches the filter.
     * @param {VaccinationFindUniqueArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VaccinationFindUniqueArgs>(args: SelectSubset<T, VaccinationFindUniqueArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vaccination that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VaccinationFindUniqueOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VaccinationFindUniqueOrThrowArgs>(args: SelectSubset<T, VaccinationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccination that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VaccinationFindFirstArgs>(args?: SelectSubset<T, VaccinationFindFirstArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vaccination that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindFirstOrThrowArgs} args - Arguments to find a Vaccination
     * @example
     * // Get one Vaccination
     * const vaccination = await prisma.vaccination.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VaccinationFindFirstOrThrowArgs>(args?: SelectSubset<T, VaccinationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vaccinations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vaccinations
     * const vaccinations = await prisma.vaccination.findMany()
     * 
     * // Get first 10 Vaccinations
     * const vaccinations = await prisma.vaccination.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vaccinationWithIdOnly = await prisma.vaccination.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VaccinationFindManyArgs>(args?: SelectSubset<T, VaccinationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vaccination.
     * @param {VaccinationCreateArgs} args - Arguments to create a Vaccination.
     * @example
     * // Create one Vaccination
     * const Vaccination = await prisma.vaccination.create({
     *   data: {
     *     // ... data to create a Vaccination
     *   }
     * })
     * 
     */
    create<T extends VaccinationCreateArgs>(args: SelectSubset<T, VaccinationCreateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vaccinations.
     * @param {VaccinationCreateManyArgs} args - Arguments to create many Vaccinations.
     * @example
     * // Create many Vaccinations
     * const vaccination = await prisma.vaccination.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VaccinationCreateManyArgs>(args?: SelectSubset<T, VaccinationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vaccination.
     * @param {VaccinationDeleteArgs} args - Arguments to delete one Vaccination.
     * @example
     * // Delete one Vaccination
     * const Vaccination = await prisma.vaccination.delete({
     *   where: {
     *     // ... filter to delete one Vaccination
     *   }
     * })
     * 
     */
    delete<T extends VaccinationDeleteArgs>(args: SelectSubset<T, VaccinationDeleteArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vaccination.
     * @param {VaccinationUpdateArgs} args - Arguments to update one Vaccination.
     * @example
     * // Update one Vaccination
     * const vaccination = await prisma.vaccination.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VaccinationUpdateArgs>(args: SelectSubset<T, VaccinationUpdateArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vaccinations.
     * @param {VaccinationDeleteManyArgs} args - Arguments to filter Vaccinations to delete.
     * @example
     * // Delete a few Vaccinations
     * const { count } = await prisma.vaccination.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VaccinationDeleteManyArgs>(args?: SelectSubset<T, VaccinationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vaccinations
     * const vaccination = await prisma.vaccination.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VaccinationUpdateManyArgs>(args: SelectSubset<T, VaccinationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vaccination.
     * @param {VaccinationUpsertArgs} args - Arguments to update or create a Vaccination.
     * @example
     * // Update or create a Vaccination
     * const vaccination = await prisma.vaccination.upsert({
     *   create: {
     *     // ... data to create a Vaccination
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vaccination we want to update
     *   }
     * })
     */
    upsert<T extends VaccinationUpsertArgs>(args: SelectSubset<T, VaccinationUpsertArgs<ExtArgs>>): Prisma__VaccinationClient<$Result.GetResult<Prisma.$VaccinationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vaccinations that matches the filter.
     * @param {VaccinationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vaccination = await prisma.vaccination.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: VaccinationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vaccination.
     * @param {VaccinationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vaccination = await prisma.vaccination.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: VaccinationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vaccinations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationCountArgs} args - Arguments to filter Vaccinations to count.
     * @example
     * // Count the number of Vaccinations
     * const count = await prisma.vaccination.count({
     *   where: {
     *     // ... the filter for the Vaccinations we want to count
     *   }
     * })
    **/
    count<T extends VaccinationCountArgs>(
      args?: Subset<T, VaccinationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VaccinationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VaccinationAggregateArgs>(args: Subset<T, VaccinationAggregateArgs>): Prisma.PrismaPromise<GetVaccinationAggregateType<T>>

    /**
     * Group by Vaccination.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VaccinationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VaccinationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VaccinationGroupByArgs['orderBy'] }
        : { orderBy?: VaccinationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VaccinationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVaccinationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vaccination model
   */
  readonly fields: VaccinationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vaccination.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VaccinationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends VaccinationCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VaccinationCampaignDefaultArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nurse<T extends Vaccination$nurseArgs<ExtArgs> = {}>(args?: Subset<T, Vaccination$nurseArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vaccination model
   */
  interface VaccinationFieldRefs {
    readonly id: FieldRef<"Vaccination", 'String'>
    readonly studentId: FieldRef<"Vaccination", 'String'>
    readonly campaignId: FieldRef<"Vaccination", 'String'>
    readonly nurseId: FieldRef<"Vaccination", 'String'>
    readonly status: FieldRef<"Vaccination", 'VaccinationStatus'>
    readonly scheduledDate: FieldRef<"Vaccination", 'DateTime'>
    readonly administeredDate: FieldRef<"Vaccination", 'DateTime'>
    readonly dose: FieldRef<"Vaccination", 'String'>
    readonly batch: FieldRef<"Vaccination", 'String'>
    readonly sideEffects: FieldRef<"Vaccination", 'String'>
    readonly notes: FieldRef<"Vaccination", 'String'>
    readonly parentConsent: FieldRef<"Vaccination", 'Boolean'>
    readonly consentDate: FieldRef<"Vaccination", 'DateTime'>
    readonly createdAt: FieldRef<"Vaccination", 'DateTime'>
    readonly updatedAt: FieldRef<"Vaccination", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vaccination findUnique
   */
  export type VaccinationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findUniqueOrThrow
   */
  export type VaccinationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination findFirst
   */
  export type VaccinationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findFirstOrThrow
   */
  export type VaccinationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccination to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vaccinations.
     */
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination findMany
   */
  export type VaccinationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter, which Vaccinations to fetch.
     */
    where?: VaccinationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vaccinations to fetch.
     */
    orderBy?: VaccinationOrderByWithRelationInput | VaccinationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vaccinations.
     */
    cursor?: VaccinationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vaccinations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vaccinations.
     */
    skip?: number
    distinct?: VaccinationScalarFieldEnum | VaccinationScalarFieldEnum[]
  }

  /**
   * Vaccination create
   */
  export type VaccinationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to create a Vaccination.
     */
    data: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
  }

  /**
   * Vaccination createMany
   */
  export type VaccinationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vaccinations.
     */
    data: VaccinationCreateManyInput | VaccinationCreateManyInput[]
  }

  /**
   * Vaccination update
   */
  export type VaccinationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The data needed to update a Vaccination.
     */
    data: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
    /**
     * Choose, which Vaccination to update.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination updateMany
   */
  export type VaccinationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vaccinations.
     */
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyInput>
    /**
     * Filter which Vaccinations to update
     */
    where?: VaccinationWhereInput
    /**
     * Limit how many Vaccinations to update.
     */
    limit?: number
  }

  /**
   * Vaccination upsert
   */
  export type VaccinationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * The filter to search for the Vaccination to update in case it exists.
     */
    where: VaccinationWhereUniqueInput
    /**
     * In case the Vaccination found by the `where` argument doesn't exist, create a new Vaccination with this data.
     */
    create: XOR<VaccinationCreateInput, VaccinationUncheckedCreateInput>
    /**
     * In case the Vaccination was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VaccinationUpdateInput, VaccinationUncheckedUpdateInput>
  }

  /**
   * Vaccination delete
   */
  export type VaccinationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
    /**
     * Filter which Vaccination to delete.
     */
    where: VaccinationWhereUniqueInput
  }

  /**
   * Vaccination deleteMany
   */
  export type VaccinationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vaccinations to delete
     */
    where?: VaccinationWhereInput
    /**
     * Limit how many Vaccinations to delete.
     */
    limit?: number
  }

  /**
   * Vaccination findRaw
   */
  export type VaccinationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vaccination aggregateRaw
   */
  export type VaccinationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Vaccination.nurse
   */
  export type Vaccination$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    where?: SchoolNurseWhereInput
  }

  /**
   * Vaccination without action
   */
  export type VaccinationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vaccination
     */
    select?: VaccinationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vaccination
     */
    omit?: VaccinationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationInclude<ExtArgs> | null
  }


  /**
   * Model MedicalCheckCampaign
   */

  export type AggregateMedicalCheckCampaign = {
    _count: MedicalCheckCampaignCountAggregateOutputType | null
    _min: MedicalCheckCampaignMinAggregateOutputType | null
    _max: MedicalCheckCampaignMaxAggregateOutputType | null
  }

  export type MedicalCheckCampaignMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scheduledDate: Date | null
    deadline: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalCheckCampaignMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    scheduledDate: Date | null
    deadline: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalCheckCampaignCountAggregateOutputType = {
    id: number
    name: number
    description: number
    checkTypes: number
    targetGrades: number
    scheduledDate: number
    deadline: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalCheckCampaignMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalCheckCampaignMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalCheckCampaignCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    checkTypes?: true
    targetGrades?: true
    scheduledDate?: true
    deadline?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalCheckCampaignAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalCheckCampaign to aggregate.
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCheckCampaigns to fetch.
     */
    orderBy?: MedicalCheckCampaignOrderByWithRelationInput | MedicalCheckCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalCheckCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCheckCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCheckCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalCheckCampaigns
    **/
    _count?: true | MedicalCheckCampaignCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalCheckCampaignMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalCheckCampaignMaxAggregateInputType
  }

  export type GetMedicalCheckCampaignAggregateType<T extends MedicalCheckCampaignAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalCheckCampaign]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalCheckCampaign[P]>
      : GetScalarType<T[P], AggregateMedicalCheckCampaign[P]>
  }




  export type MedicalCheckCampaignGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCheckCampaignWhereInput
    orderBy?: MedicalCheckCampaignOrderByWithAggregationInput | MedicalCheckCampaignOrderByWithAggregationInput[]
    by: MedicalCheckCampaignScalarFieldEnum[] | MedicalCheckCampaignScalarFieldEnum
    having?: MedicalCheckCampaignScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalCheckCampaignCountAggregateInputType | true
    _min?: MedicalCheckCampaignMinAggregateInputType
    _max?: MedicalCheckCampaignMaxAggregateInputType
  }

  export type MedicalCheckCampaignGroupByOutputType = {
    id: string
    name: string
    description: string | null
    checkTypes: string[]
    targetGrades: string[]
    scheduledDate: Date
    deadline: Date
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: MedicalCheckCampaignCountAggregateOutputType | null
    _min: MedicalCheckCampaignMinAggregateOutputType | null
    _max: MedicalCheckCampaignMaxAggregateOutputType | null
  }

  type GetMedicalCheckCampaignGroupByPayload<T extends MedicalCheckCampaignGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalCheckCampaignGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalCheckCampaignGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalCheckCampaignGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalCheckCampaignGroupByOutputType[P]>
        }
      >
    >


  export type MedicalCheckCampaignSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    checkTypes?: boolean
    targetGrades?: boolean
    scheduledDate?: boolean
    deadline?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    medicalChecks?: boolean | MedicalCheckCampaign$medicalChecksArgs<ExtArgs>
    notifications?: boolean | MedicalCheckCampaign$notificationsArgs<ExtArgs>
    _count?: boolean | MedicalCheckCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicalCheckCampaign"]>



  export type MedicalCheckCampaignSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    checkTypes?: boolean
    targetGrades?: boolean
    scheduledDate?: boolean
    deadline?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalCheckCampaignOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "checkTypes" | "targetGrades" | "scheduledDate" | "deadline" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalCheckCampaign"]>
  export type MedicalCheckCampaignInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalChecks?: boolean | MedicalCheckCampaign$medicalChecksArgs<ExtArgs>
    notifications?: boolean | MedicalCheckCampaign$notificationsArgs<ExtArgs>
    _count?: boolean | MedicalCheckCampaignCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MedicalCheckCampaignPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalCheckCampaign"
    objects: {
      medicalChecks: Prisma.$MedicalCheckPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      checkTypes: string[]
      targetGrades: string[]
      scheduledDate: Date
      deadline: Date
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalCheckCampaign"]>
    composites: {}
  }

  type MedicalCheckCampaignGetPayload<S extends boolean | null | undefined | MedicalCheckCampaignDefaultArgs> = $Result.GetResult<Prisma.$MedicalCheckCampaignPayload, S>

  type MedicalCheckCampaignCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalCheckCampaignFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalCheckCampaignCountAggregateInputType | true
    }

  export interface MedicalCheckCampaignDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalCheckCampaign'], meta: { name: 'MedicalCheckCampaign' } }
    /**
     * Find zero or one MedicalCheckCampaign that matches the filter.
     * @param {MedicalCheckCampaignFindUniqueArgs} args - Arguments to find a MedicalCheckCampaign
     * @example
     * // Get one MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalCheckCampaignFindUniqueArgs>(args: SelectSubset<T, MedicalCheckCampaignFindUniqueArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalCheckCampaign that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalCheckCampaignFindUniqueOrThrowArgs} args - Arguments to find a MedicalCheckCampaign
     * @example
     * // Get one MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalCheckCampaignFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalCheckCampaignFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCheckCampaign that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignFindFirstArgs} args - Arguments to find a MedicalCheckCampaign
     * @example
     * // Get one MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalCheckCampaignFindFirstArgs>(args?: SelectSubset<T, MedicalCheckCampaignFindFirstArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCheckCampaign that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignFindFirstOrThrowArgs} args - Arguments to find a MedicalCheckCampaign
     * @example
     * // Get one MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalCheckCampaignFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalCheckCampaignFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalCheckCampaigns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalCheckCampaigns
     * const medicalCheckCampaigns = await prisma.medicalCheckCampaign.findMany()
     * 
     * // Get first 10 MedicalCheckCampaigns
     * const medicalCheckCampaigns = await prisma.medicalCheckCampaign.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalCheckCampaignWithIdOnly = await prisma.medicalCheckCampaign.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalCheckCampaignFindManyArgs>(args?: SelectSubset<T, MedicalCheckCampaignFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalCheckCampaign.
     * @param {MedicalCheckCampaignCreateArgs} args - Arguments to create a MedicalCheckCampaign.
     * @example
     * // Create one MedicalCheckCampaign
     * const MedicalCheckCampaign = await prisma.medicalCheckCampaign.create({
     *   data: {
     *     // ... data to create a MedicalCheckCampaign
     *   }
     * })
     * 
     */
    create<T extends MedicalCheckCampaignCreateArgs>(args: SelectSubset<T, MedicalCheckCampaignCreateArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalCheckCampaigns.
     * @param {MedicalCheckCampaignCreateManyArgs} args - Arguments to create many MedicalCheckCampaigns.
     * @example
     * // Create many MedicalCheckCampaigns
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalCheckCampaignCreateManyArgs>(args?: SelectSubset<T, MedicalCheckCampaignCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalCheckCampaign.
     * @param {MedicalCheckCampaignDeleteArgs} args - Arguments to delete one MedicalCheckCampaign.
     * @example
     * // Delete one MedicalCheckCampaign
     * const MedicalCheckCampaign = await prisma.medicalCheckCampaign.delete({
     *   where: {
     *     // ... filter to delete one MedicalCheckCampaign
     *   }
     * })
     * 
     */
    delete<T extends MedicalCheckCampaignDeleteArgs>(args: SelectSubset<T, MedicalCheckCampaignDeleteArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalCheckCampaign.
     * @param {MedicalCheckCampaignUpdateArgs} args - Arguments to update one MedicalCheckCampaign.
     * @example
     * // Update one MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalCheckCampaignUpdateArgs>(args: SelectSubset<T, MedicalCheckCampaignUpdateArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalCheckCampaigns.
     * @param {MedicalCheckCampaignDeleteManyArgs} args - Arguments to filter MedicalCheckCampaigns to delete.
     * @example
     * // Delete a few MedicalCheckCampaigns
     * const { count } = await prisma.medicalCheckCampaign.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalCheckCampaignDeleteManyArgs>(args?: SelectSubset<T, MedicalCheckCampaignDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalCheckCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalCheckCampaigns
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalCheckCampaignUpdateManyArgs>(args: SelectSubset<T, MedicalCheckCampaignUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalCheckCampaign.
     * @param {MedicalCheckCampaignUpsertArgs} args - Arguments to update or create a MedicalCheckCampaign.
     * @example
     * // Update or create a MedicalCheckCampaign
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.upsert({
     *   create: {
     *     // ... data to create a MedicalCheckCampaign
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalCheckCampaign we want to update
     *   }
     * })
     */
    upsert<T extends MedicalCheckCampaignUpsertArgs>(args: SelectSubset<T, MedicalCheckCampaignUpsertArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalCheckCampaigns that matches the filter.
     * @param {MedicalCheckCampaignFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicalCheckCampaignFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MedicalCheckCampaign.
     * @param {MedicalCheckCampaignAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medicalCheckCampaign = await prisma.medicalCheckCampaign.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicalCheckCampaignAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MedicalCheckCampaigns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignCountArgs} args - Arguments to filter MedicalCheckCampaigns to count.
     * @example
     * // Count the number of MedicalCheckCampaigns
     * const count = await prisma.medicalCheckCampaign.count({
     *   where: {
     *     // ... the filter for the MedicalCheckCampaigns we want to count
     *   }
     * })
    **/
    count<T extends MedicalCheckCampaignCountArgs>(
      args?: Subset<T, MedicalCheckCampaignCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalCheckCampaignCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalCheckCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalCheckCampaignAggregateArgs>(args: Subset<T, MedicalCheckCampaignAggregateArgs>): Prisma.PrismaPromise<GetMedicalCheckCampaignAggregateType<T>>

    /**
     * Group by MedicalCheckCampaign.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCampaignGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalCheckCampaignGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalCheckCampaignGroupByArgs['orderBy'] }
        : { orderBy?: MedicalCheckCampaignGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalCheckCampaignGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalCheckCampaignGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalCheckCampaign model
   */
  readonly fields: MedicalCheckCampaignFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalCheckCampaign.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalCheckCampaignClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalChecks<T extends MedicalCheckCampaign$medicalChecksArgs<ExtArgs> = {}>(args?: Subset<T, MedicalCheckCampaign$medicalChecksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends MedicalCheckCampaign$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, MedicalCheckCampaign$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalCheckCampaign model
   */
  interface MedicalCheckCampaignFieldRefs {
    readonly id: FieldRef<"MedicalCheckCampaign", 'String'>
    readonly name: FieldRef<"MedicalCheckCampaign", 'String'>
    readonly description: FieldRef<"MedicalCheckCampaign", 'String'>
    readonly checkTypes: FieldRef<"MedicalCheckCampaign", 'String[]'>
    readonly targetGrades: FieldRef<"MedicalCheckCampaign", 'String[]'>
    readonly scheduledDate: FieldRef<"MedicalCheckCampaign", 'DateTime'>
    readonly deadline: FieldRef<"MedicalCheckCampaign", 'DateTime'>
    readonly isActive: FieldRef<"MedicalCheckCampaign", 'Boolean'>
    readonly createdAt: FieldRef<"MedicalCheckCampaign", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalCheckCampaign", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalCheckCampaign findUnique
   */
  export type MedicalCheckCampaignFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheckCampaign to fetch.
     */
    where: MedicalCheckCampaignWhereUniqueInput
  }

  /**
   * MedicalCheckCampaign findUniqueOrThrow
   */
  export type MedicalCheckCampaignFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheckCampaign to fetch.
     */
    where: MedicalCheckCampaignWhereUniqueInput
  }

  /**
   * MedicalCheckCampaign findFirst
   */
  export type MedicalCheckCampaignFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheckCampaign to fetch.
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCheckCampaigns to fetch.
     */
    orderBy?: MedicalCheckCampaignOrderByWithRelationInput | MedicalCheckCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalCheckCampaigns.
     */
    cursor?: MedicalCheckCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCheckCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCheckCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalCheckCampaigns.
     */
    distinct?: MedicalCheckCampaignScalarFieldEnum | MedicalCheckCampaignScalarFieldEnum[]
  }

  /**
   * MedicalCheckCampaign findFirstOrThrow
   */
  export type MedicalCheckCampaignFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheckCampaign to fetch.
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCheckCampaigns to fetch.
     */
    orderBy?: MedicalCheckCampaignOrderByWithRelationInput | MedicalCheckCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalCheckCampaigns.
     */
    cursor?: MedicalCheckCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCheckCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCheckCampaigns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalCheckCampaigns.
     */
    distinct?: MedicalCheckCampaignScalarFieldEnum | MedicalCheckCampaignScalarFieldEnum[]
  }

  /**
   * MedicalCheckCampaign findMany
   */
  export type MedicalCheckCampaignFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheckCampaigns to fetch.
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalCheckCampaigns to fetch.
     */
    orderBy?: MedicalCheckCampaignOrderByWithRelationInput | MedicalCheckCampaignOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalCheckCampaigns.
     */
    cursor?: MedicalCheckCampaignWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalCheckCampaigns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalCheckCampaigns.
     */
    skip?: number
    distinct?: MedicalCheckCampaignScalarFieldEnum | MedicalCheckCampaignScalarFieldEnum[]
  }

  /**
   * MedicalCheckCampaign create
   */
  export type MedicalCheckCampaignCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalCheckCampaign.
     */
    data: XOR<MedicalCheckCampaignCreateInput, MedicalCheckCampaignUncheckedCreateInput>
  }

  /**
   * MedicalCheckCampaign createMany
   */
  export type MedicalCheckCampaignCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalCheckCampaigns.
     */
    data: MedicalCheckCampaignCreateManyInput | MedicalCheckCampaignCreateManyInput[]
  }

  /**
   * MedicalCheckCampaign update
   */
  export type MedicalCheckCampaignUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalCheckCampaign.
     */
    data: XOR<MedicalCheckCampaignUpdateInput, MedicalCheckCampaignUncheckedUpdateInput>
    /**
     * Choose, which MedicalCheckCampaign to update.
     */
    where: MedicalCheckCampaignWhereUniqueInput
  }

  /**
   * MedicalCheckCampaign updateMany
   */
  export type MedicalCheckCampaignUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalCheckCampaigns.
     */
    data: XOR<MedicalCheckCampaignUpdateManyMutationInput, MedicalCheckCampaignUncheckedUpdateManyInput>
    /**
     * Filter which MedicalCheckCampaigns to update
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * Limit how many MedicalCheckCampaigns to update.
     */
    limit?: number
  }

  /**
   * MedicalCheckCampaign upsert
   */
  export type MedicalCheckCampaignUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalCheckCampaign to update in case it exists.
     */
    where: MedicalCheckCampaignWhereUniqueInput
    /**
     * In case the MedicalCheckCampaign found by the `where` argument doesn't exist, create a new MedicalCheckCampaign with this data.
     */
    create: XOR<MedicalCheckCampaignCreateInput, MedicalCheckCampaignUncheckedCreateInput>
    /**
     * In case the MedicalCheckCampaign was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalCheckCampaignUpdateInput, MedicalCheckCampaignUncheckedUpdateInput>
  }

  /**
   * MedicalCheckCampaign delete
   */
  export type MedicalCheckCampaignDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    /**
     * Filter which MedicalCheckCampaign to delete.
     */
    where: MedicalCheckCampaignWhereUniqueInput
  }

  /**
   * MedicalCheckCampaign deleteMany
   */
  export type MedicalCheckCampaignDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalCheckCampaigns to delete
     */
    where?: MedicalCheckCampaignWhereInput
    /**
     * Limit how many MedicalCheckCampaigns to delete.
     */
    limit?: number
  }

  /**
   * MedicalCheckCampaign findRaw
   */
  export type MedicalCheckCampaignFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalCheckCampaign aggregateRaw
   */
  export type MedicalCheckCampaignAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalCheckCampaign.medicalChecks
   */
  export type MedicalCheckCampaign$medicalChecksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    where?: MedicalCheckWhereInput
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    cursor?: MedicalCheckWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * MedicalCheckCampaign.notifications
   */
  export type MedicalCheckCampaign$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * MedicalCheckCampaign without action
   */
  export type MedicalCheckCampaignDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
  }


  /**
   * Model MedicalCheck
   */

  export type AggregateMedicalCheck = {
    _count: MedicalCheckCountAggregateOutputType | null
    _min: MedicalCheckMinAggregateOutputType | null
    _max: MedicalCheckMaxAggregateOutputType | null
  }

  export type MedicalCheckMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    campaignId: string | null
    nurseId: string | null
    status: $Enums.MedicalCheckStatus | null
    scheduledDate: Date | null
    completedDate: Date | null
    visionResult: string | null
    hearingResult: string | null
    dentalResult: string | null
    generalHealth: string | null
    recommendations: string | null
    requiresFollowUp: boolean | null
    followUpDate: Date | null
    notes: string | null
    parentNotified: boolean | null
    parentResponse: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalCheckMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    campaignId: string | null
    nurseId: string | null
    status: $Enums.MedicalCheckStatus | null
    scheduledDate: Date | null
    completedDate: Date | null
    visionResult: string | null
    hearingResult: string | null
    dentalResult: string | null
    generalHealth: string | null
    recommendations: string | null
    requiresFollowUp: boolean | null
    followUpDate: Date | null
    notes: string | null
    parentNotified: boolean | null
    parentResponse: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicalCheckCountAggregateOutputType = {
    id: number
    studentId: number
    campaignId: number
    nurseId: number
    status: number
    scheduledDate: number
    completedDate: number
    visionResult: number
    hearingResult: number
    dentalResult: number
    heightWeight: number
    generalHealth: number
    recommendations: number
    requiresFollowUp: number
    followUpDate: number
    notes: number
    parentNotified: number
    parentResponse: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicalCheckMinAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    completedDate?: true
    visionResult?: true
    hearingResult?: true
    dentalResult?: true
    generalHealth?: true
    recommendations?: true
    requiresFollowUp?: true
    followUpDate?: true
    notes?: true
    parentNotified?: true
    parentResponse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalCheckMaxAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    completedDate?: true
    visionResult?: true
    hearingResult?: true
    dentalResult?: true
    generalHealth?: true
    recommendations?: true
    requiresFollowUp?: true
    followUpDate?: true
    notes?: true
    parentNotified?: true
    parentResponse?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicalCheckCountAggregateInputType = {
    id?: true
    studentId?: true
    campaignId?: true
    nurseId?: true
    status?: true
    scheduledDate?: true
    completedDate?: true
    visionResult?: true
    hearingResult?: true
    dentalResult?: true
    heightWeight?: true
    generalHealth?: true
    recommendations?: true
    requiresFollowUp?: true
    followUpDate?: true
    notes?: true
    parentNotified?: true
    parentResponse?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicalCheckAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalCheck to aggregate.
     */
    where?: MedicalCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalChecks to fetch.
     */
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalChecks
    **/
    _count?: true | MedicalCheckCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalCheckMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalCheckMaxAggregateInputType
  }

  export type GetMedicalCheckAggregateType<T extends MedicalCheckAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalCheck]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalCheck[P]>
      : GetScalarType<T[P], AggregateMedicalCheck[P]>
  }




  export type MedicalCheckGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalCheckWhereInput
    orderBy?: MedicalCheckOrderByWithAggregationInput | MedicalCheckOrderByWithAggregationInput[]
    by: MedicalCheckScalarFieldEnum[] | MedicalCheckScalarFieldEnum
    having?: MedicalCheckScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalCheckCountAggregateInputType | true
    _min?: MedicalCheckMinAggregateInputType
    _max?: MedicalCheckMaxAggregateInputType
  }

  export type MedicalCheckGroupByOutputType = {
    id: string
    studentId: string
    campaignId: string
    nurseId: string | null
    status: $Enums.MedicalCheckStatus
    scheduledDate: Date
    completedDate: Date | null
    visionResult: string | null
    hearingResult: string | null
    dentalResult: string | null
    heightWeight: JsonValue | null
    generalHealth: string | null
    recommendations: string | null
    requiresFollowUp: boolean
    followUpDate: Date | null
    notes: string | null
    parentNotified: boolean
    parentResponse: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicalCheckCountAggregateOutputType | null
    _min: MedicalCheckMinAggregateOutputType | null
    _max: MedicalCheckMaxAggregateOutputType | null
  }

  type GetMedicalCheckGroupByPayload<T extends MedicalCheckGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalCheckGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalCheckGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalCheckGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalCheckGroupByOutputType[P]>
        }
      >
    >


  export type MedicalCheckSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    campaignId?: boolean
    nurseId?: boolean
    status?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    visionResult?: boolean
    hearingResult?: boolean
    dentalResult?: boolean
    heightWeight?: boolean
    generalHealth?: boolean
    recommendations?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    notes?: boolean
    parentNotified?: boolean
    parentResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    campaign?: boolean | MedicalCheckCampaignDefaultArgs<ExtArgs>
    nurse?: boolean | MedicalCheck$nurseArgs<ExtArgs>
  }, ExtArgs["result"]["medicalCheck"]>



  export type MedicalCheckSelectScalar = {
    id?: boolean
    studentId?: boolean
    campaignId?: boolean
    nurseId?: boolean
    status?: boolean
    scheduledDate?: boolean
    completedDate?: boolean
    visionResult?: boolean
    hearingResult?: boolean
    dentalResult?: boolean
    heightWeight?: boolean
    generalHealth?: boolean
    recommendations?: boolean
    requiresFollowUp?: boolean
    followUpDate?: boolean
    notes?: boolean
    parentNotified?: boolean
    parentResponse?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicalCheckOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "studentId" | "campaignId" | "nurseId" | "status" | "scheduledDate" | "completedDate" | "visionResult" | "hearingResult" | "dentalResult" | "heightWeight" | "generalHealth" | "recommendations" | "requiresFollowUp" | "followUpDate" | "notes" | "parentNotified" | "parentResponse" | "createdAt" | "updatedAt", ExtArgs["result"]["medicalCheck"]>
  export type MedicalCheckInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    campaign?: boolean | MedicalCheckCampaignDefaultArgs<ExtArgs>
    nurse?: boolean | MedicalCheck$nurseArgs<ExtArgs>
  }

  export type $MedicalCheckPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalCheck"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      campaign: Prisma.$MedicalCheckCampaignPayload<ExtArgs>
      nurse: Prisma.$SchoolNursePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      campaignId: string
      nurseId: string | null
      status: $Enums.MedicalCheckStatus
      scheduledDate: Date
      completedDate: Date | null
      visionResult: string | null
      hearingResult: string | null
      dentalResult: string | null
      heightWeight: Prisma.JsonValue | null
      generalHealth: string | null
      recommendations: string | null
      requiresFollowUp: boolean
      followUpDate: Date | null
      notes: string | null
      parentNotified: boolean
      parentResponse: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicalCheck"]>
    composites: {}
  }

  type MedicalCheckGetPayload<S extends boolean | null | undefined | MedicalCheckDefaultArgs> = $Result.GetResult<Prisma.$MedicalCheckPayload, S>

  type MedicalCheckCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalCheckFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalCheckCountAggregateInputType | true
    }

  export interface MedicalCheckDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalCheck'], meta: { name: 'MedicalCheck' } }
    /**
     * Find zero or one MedicalCheck that matches the filter.
     * @param {MedicalCheckFindUniqueArgs} args - Arguments to find a MedicalCheck
     * @example
     * // Get one MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalCheckFindUniqueArgs>(args: SelectSubset<T, MedicalCheckFindUniqueArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalCheck that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalCheckFindUniqueOrThrowArgs} args - Arguments to find a MedicalCheck
     * @example
     * // Get one MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalCheckFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalCheckFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCheck that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckFindFirstArgs} args - Arguments to find a MedicalCheck
     * @example
     * // Get one MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalCheckFindFirstArgs>(args?: SelectSubset<T, MedicalCheckFindFirstArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalCheck that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckFindFirstOrThrowArgs} args - Arguments to find a MedicalCheck
     * @example
     * // Get one MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalCheckFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalCheckFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalChecks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalChecks
     * const medicalChecks = await prisma.medicalCheck.findMany()
     * 
     * // Get first 10 MedicalChecks
     * const medicalChecks = await prisma.medicalCheck.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalCheckWithIdOnly = await prisma.medicalCheck.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalCheckFindManyArgs>(args?: SelectSubset<T, MedicalCheckFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalCheck.
     * @param {MedicalCheckCreateArgs} args - Arguments to create a MedicalCheck.
     * @example
     * // Create one MedicalCheck
     * const MedicalCheck = await prisma.medicalCheck.create({
     *   data: {
     *     // ... data to create a MedicalCheck
     *   }
     * })
     * 
     */
    create<T extends MedicalCheckCreateArgs>(args: SelectSubset<T, MedicalCheckCreateArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalChecks.
     * @param {MedicalCheckCreateManyArgs} args - Arguments to create many MedicalChecks.
     * @example
     * // Create many MedicalChecks
     * const medicalCheck = await prisma.medicalCheck.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalCheckCreateManyArgs>(args?: SelectSubset<T, MedicalCheckCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalCheck.
     * @param {MedicalCheckDeleteArgs} args - Arguments to delete one MedicalCheck.
     * @example
     * // Delete one MedicalCheck
     * const MedicalCheck = await prisma.medicalCheck.delete({
     *   where: {
     *     // ... filter to delete one MedicalCheck
     *   }
     * })
     * 
     */
    delete<T extends MedicalCheckDeleteArgs>(args: SelectSubset<T, MedicalCheckDeleteArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalCheck.
     * @param {MedicalCheckUpdateArgs} args - Arguments to update one MedicalCheck.
     * @example
     * // Update one MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalCheckUpdateArgs>(args: SelectSubset<T, MedicalCheckUpdateArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalChecks.
     * @param {MedicalCheckDeleteManyArgs} args - Arguments to filter MedicalChecks to delete.
     * @example
     * // Delete a few MedicalChecks
     * const { count } = await prisma.medicalCheck.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalCheckDeleteManyArgs>(args?: SelectSubset<T, MedicalCheckDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalChecks
     * const medicalCheck = await prisma.medicalCheck.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalCheckUpdateManyArgs>(args: SelectSubset<T, MedicalCheckUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalCheck.
     * @param {MedicalCheckUpsertArgs} args - Arguments to update or create a MedicalCheck.
     * @example
     * // Update or create a MedicalCheck
     * const medicalCheck = await prisma.medicalCheck.upsert({
     *   create: {
     *     // ... data to create a MedicalCheck
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalCheck we want to update
     *   }
     * })
     */
    upsert<T extends MedicalCheckUpsertArgs>(args: SelectSubset<T, MedicalCheckUpsertArgs<ExtArgs>>): Prisma__MedicalCheckClient<$Result.GetResult<Prisma.$MedicalCheckPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalChecks that matches the filter.
     * @param {MedicalCheckFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medicalCheck = await prisma.medicalCheck.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicalCheckFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MedicalCheck.
     * @param {MedicalCheckAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medicalCheck = await prisma.medicalCheck.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicalCheckAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MedicalChecks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckCountArgs} args - Arguments to filter MedicalChecks to count.
     * @example
     * // Count the number of MedicalChecks
     * const count = await prisma.medicalCheck.count({
     *   where: {
     *     // ... the filter for the MedicalChecks we want to count
     *   }
     * })
    **/
    count<T extends MedicalCheckCountArgs>(
      args?: Subset<T, MedicalCheckCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalCheckCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalCheckAggregateArgs>(args: Subset<T, MedicalCheckAggregateArgs>): Prisma.PrismaPromise<GetMedicalCheckAggregateType<T>>

    /**
     * Group by MedicalCheck.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalCheckGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalCheckGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalCheckGroupByArgs['orderBy'] }
        : { orderBy?: MedicalCheckGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalCheckGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalCheckGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalCheck model
   */
  readonly fields: MedicalCheckFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalCheck.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalCheckClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    campaign<T extends MedicalCheckCampaignDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicalCheckCampaignDefaultArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nurse<T extends MedicalCheck$nurseArgs<ExtArgs> = {}>(args?: Subset<T, MedicalCheck$nurseArgs<ExtArgs>>): Prisma__SchoolNurseClient<$Result.GetResult<Prisma.$SchoolNursePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalCheck model
   */
  interface MedicalCheckFieldRefs {
    readonly id: FieldRef<"MedicalCheck", 'String'>
    readonly studentId: FieldRef<"MedicalCheck", 'String'>
    readonly campaignId: FieldRef<"MedicalCheck", 'String'>
    readonly nurseId: FieldRef<"MedicalCheck", 'String'>
    readonly status: FieldRef<"MedicalCheck", 'MedicalCheckStatus'>
    readonly scheduledDate: FieldRef<"MedicalCheck", 'DateTime'>
    readonly completedDate: FieldRef<"MedicalCheck", 'DateTime'>
    readonly visionResult: FieldRef<"MedicalCheck", 'String'>
    readonly hearingResult: FieldRef<"MedicalCheck", 'String'>
    readonly dentalResult: FieldRef<"MedicalCheck", 'String'>
    readonly heightWeight: FieldRef<"MedicalCheck", 'Json'>
    readonly generalHealth: FieldRef<"MedicalCheck", 'String'>
    readonly recommendations: FieldRef<"MedicalCheck", 'String'>
    readonly requiresFollowUp: FieldRef<"MedicalCheck", 'Boolean'>
    readonly followUpDate: FieldRef<"MedicalCheck", 'DateTime'>
    readonly notes: FieldRef<"MedicalCheck", 'String'>
    readonly parentNotified: FieldRef<"MedicalCheck", 'Boolean'>
    readonly parentResponse: FieldRef<"MedicalCheck", 'String'>
    readonly createdAt: FieldRef<"MedicalCheck", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicalCheck", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalCheck findUnique
   */
  export type MedicalCheckFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheck to fetch.
     */
    where: MedicalCheckWhereUniqueInput
  }

  /**
   * MedicalCheck findUniqueOrThrow
   */
  export type MedicalCheckFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheck to fetch.
     */
    where: MedicalCheckWhereUniqueInput
  }

  /**
   * MedicalCheck findFirst
   */
  export type MedicalCheckFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheck to fetch.
     */
    where?: MedicalCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalChecks to fetch.
     */
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalChecks.
     */
    cursor?: MedicalCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalChecks.
     */
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * MedicalCheck findFirstOrThrow
   */
  export type MedicalCheckFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter, which MedicalCheck to fetch.
     */
    where?: MedicalCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalChecks to fetch.
     */
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalChecks.
     */
    cursor?: MedicalCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalChecks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalChecks.
     */
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * MedicalCheck findMany
   */
  export type MedicalCheckFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter, which MedicalChecks to fetch.
     */
    where?: MedicalCheckWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalChecks to fetch.
     */
    orderBy?: MedicalCheckOrderByWithRelationInput | MedicalCheckOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalChecks.
     */
    cursor?: MedicalCheckWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalChecks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalChecks.
     */
    skip?: number
    distinct?: MedicalCheckScalarFieldEnum | MedicalCheckScalarFieldEnum[]
  }

  /**
   * MedicalCheck create
   */
  export type MedicalCheckCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalCheck.
     */
    data: XOR<MedicalCheckCreateInput, MedicalCheckUncheckedCreateInput>
  }

  /**
   * MedicalCheck createMany
   */
  export type MedicalCheckCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalChecks.
     */
    data: MedicalCheckCreateManyInput | MedicalCheckCreateManyInput[]
  }

  /**
   * MedicalCheck update
   */
  export type MedicalCheckUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalCheck.
     */
    data: XOR<MedicalCheckUpdateInput, MedicalCheckUncheckedUpdateInput>
    /**
     * Choose, which MedicalCheck to update.
     */
    where: MedicalCheckWhereUniqueInput
  }

  /**
   * MedicalCheck updateMany
   */
  export type MedicalCheckUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalChecks.
     */
    data: XOR<MedicalCheckUpdateManyMutationInput, MedicalCheckUncheckedUpdateManyInput>
    /**
     * Filter which MedicalChecks to update
     */
    where?: MedicalCheckWhereInput
    /**
     * Limit how many MedicalChecks to update.
     */
    limit?: number
  }

  /**
   * MedicalCheck upsert
   */
  export type MedicalCheckUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalCheck to update in case it exists.
     */
    where: MedicalCheckWhereUniqueInput
    /**
     * In case the MedicalCheck found by the `where` argument doesn't exist, create a new MedicalCheck with this data.
     */
    create: XOR<MedicalCheckCreateInput, MedicalCheckUncheckedCreateInput>
    /**
     * In case the MedicalCheck was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalCheckUpdateInput, MedicalCheckUncheckedUpdateInput>
  }

  /**
   * MedicalCheck delete
   */
  export type MedicalCheckDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
    /**
     * Filter which MedicalCheck to delete.
     */
    where: MedicalCheckWhereUniqueInput
  }

  /**
   * MedicalCheck deleteMany
   */
  export type MedicalCheckDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalChecks to delete
     */
    where?: MedicalCheckWhereInput
    /**
     * Limit how many MedicalChecks to delete.
     */
    limit?: number
  }

  /**
   * MedicalCheck findRaw
   */
  export type MedicalCheckFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalCheck aggregateRaw
   */
  export type MedicalCheckAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalCheck.nurse
   */
  export type MedicalCheck$nurseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolNurse
     */
    select?: SchoolNurseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolNurse
     */
    omit?: SchoolNurseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolNurseInclude<ExtArgs> | null
    where?: SchoolNurseWhereInput
  }

  /**
   * MedicalCheck without action
   */
  export type MedicalCheckDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheck
     */
    select?: MedicalCheckSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheck
     */
    omit?: MedicalCheckOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckInclude<ExtArgs> | null
  }


  /**
   * Model MedicalDocument
   */

  export type AggregateMedicalDocument = {
    _count: MedicalDocumentCountAggregateOutputType | null
    _avg: MedicalDocumentAvgAggregateOutputType | null
    _sum: MedicalDocumentSumAggregateOutputType | null
    _min: MedicalDocumentMinAggregateOutputType | null
    _max: MedicalDocumentMaxAggregateOutputType | null
  }

  export type MedicalDocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type MedicalDocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type MedicalDocumentMinAggregateOutputType = {
    id: string | null
    medicalEventId: string | null
    title: string | null
    description: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type MedicalDocumentMaxAggregateOutputType = {
    id: string | null
    medicalEventId: string | null
    title: string | null
    description: string | null
    fileName: string | null
    filePath: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
  }

  export type MedicalDocumentCountAggregateOutputType = {
    id: number
    medicalEventId: number
    title: number
    description: number
    fileName: number
    filePath: number
    fileSize: number
    mimeType: number
    createdAt: number
    _all: number
  }


  export type MedicalDocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type MedicalDocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type MedicalDocumentMinAggregateInputType = {
    id?: true
    medicalEventId?: true
    title?: true
    description?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
  }

  export type MedicalDocumentMaxAggregateInputType = {
    id?: true
    medicalEventId?: true
    title?: true
    description?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
  }

  export type MedicalDocumentCountAggregateInputType = {
    id?: true
    medicalEventId?: true
    title?: true
    description?: true
    fileName?: true
    filePath?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    _all?: true
  }

  export type MedicalDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalDocument to aggregate.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicalDocuments
    **/
    _count?: true | MedicalDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicalDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicalDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicalDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicalDocumentMaxAggregateInputType
  }

  export type GetMedicalDocumentAggregateType<T extends MedicalDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicalDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicalDocument[P]>
      : GetScalarType<T[P], AggregateMedicalDocument[P]>
  }




  export type MedicalDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicalDocumentWhereInput
    orderBy?: MedicalDocumentOrderByWithAggregationInput | MedicalDocumentOrderByWithAggregationInput[]
    by: MedicalDocumentScalarFieldEnum[] | MedicalDocumentScalarFieldEnum
    having?: MedicalDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicalDocumentCountAggregateInputType | true
    _avg?: MedicalDocumentAvgAggregateInputType
    _sum?: MedicalDocumentSumAggregateInputType
    _min?: MedicalDocumentMinAggregateInputType
    _max?: MedicalDocumentMaxAggregateInputType
  }

  export type MedicalDocumentGroupByOutputType = {
    id: string
    medicalEventId: string | null
    title: string
    description: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt: Date
    _count: MedicalDocumentCountAggregateOutputType | null
    _avg: MedicalDocumentAvgAggregateOutputType | null
    _sum: MedicalDocumentSumAggregateOutputType | null
    _min: MedicalDocumentMinAggregateOutputType | null
    _max: MedicalDocumentMaxAggregateOutputType | null
  }

  type GetMedicalDocumentGroupByPayload<T extends MedicalDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicalDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicalDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicalDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], MedicalDocumentGroupByOutputType[P]>
        }
      >
    >


  export type MedicalDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    medicalEventId?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    medicalEvent?: boolean | MedicalDocument$medicalEventArgs<ExtArgs>
  }, ExtArgs["result"]["medicalDocument"]>



  export type MedicalDocumentSelectScalar = {
    id?: boolean
    medicalEventId?: boolean
    title?: boolean
    description?: boolean
    fileName?: boolean
    filePath?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
  }

  export type MedicalDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "medicalEventId" | "title" | "description" | "fileName" | "filePath" | "fileSize" | "mimeType" | "createdAt", ExtArgs["result"]["medicalDocument"]>
  export type MedicalDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    medicalEvent?: boolean | MedicalDocument$medicalEventArgs<ExtArgs>
  }

  export type $MedicalDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicalDocument"
    objects: {
      medicalEvent: Prisma.$MedicalEventPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      medicalEventId: string | null
      title: string
      description: string | null
      fileName: string
      filePath: string
      fileSize: number
      mimeType: string
      createdAt: Date
    }, ExtArgs["result"]["medicalDocument"]>
    composites: {}
  }

  type MedicalDocumentGetPayload<S extends boolean | null | undefined | MedicalDocumentDefaultArgs> = $Result.GetResult<Prisma.$MedicalDocumentPayload, S>

  type MedicalDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MedicalDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MedicalDocumentCountAggregateInputType | true
    }

  export interface MedicalDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicalDocument'], meta: { name: 'MedicalDocument' } }
    /**
     * Find zero or one MedicalDocument that matches the filter.
     * @param {MedicalDocumentFindUniqueArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicalDocumentFindUniqueArgs>(args: SelectSubset<T, MedicalDocumentFindUniqueArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MedicalDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MedicalDocumentFindUniqueOrThrowArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicalDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicalDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindFirstArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicalDocumentFindFirstArgs>(args?: SelectSubset<T, MedicalDocumentFindFirstArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MedicalDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindFirstOrThrowArgs} args - Arguments to find a MedicalDocument
     * @example
     * // Get one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicalDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicalDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicalDocuments
     * const medicalDocuments = await prisma.medicalDocument.findMany()
     * 
     * // Get first 10 MedicalDocuments
     * const medicalDocuments = await prisma.medicalDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicalDocumentWithIdOnly = await prisma.medicalDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicalDocumentFindManyArgs>(args?: SelectSubset<T, MedicalDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MedicalDocument.
     * @param {MedicalDocumentCreateArgs} args - Arguments to create a MedicalDocument.
     * @example
     * // Create one MedicalDocument
     * const MedicalDocument = await prisma.medicalDocument.create({
     *   data: {
     *     // ... data to create a MedicalDocument
     *   }
     * })
     * 
     */
    create<T extends MedicalDocumentCreateArgs>(args: SelectSubset<T, MedicalDocumentCreateArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MedicalDocuments.
     * @param {MedicalDocumentCreateManyArgs} args - Arguments to create many MedicalDocuments.
     * @example
     * // Create many MedicalDocuments
     * const medicalDocument = await prisma.medicalDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicalDocumentCreateManyArgs>(args?: SelectSubset<T, MedicalDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MedicalDocument.
     * @param {MedicalDocumentDeleteArgs} args - Arguments to delete one MedicalDocument.
     * @example
     * // Delete one MedicalDocument
     * const MedicalDocument = await prisma.medicalDocument.delete({
     *   where: {
     *     // ... filter to delete one MedicalDocument
     *   }
     * })
     * 
     */
    delete<T extends MedicalDocumentDeleteArgs>(args: SelectSubset<T, MedicalDocumentDeleteArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MedicalDocument.
     * @param {MedicalDocumentUpdateArgs} args - Arguments to update one MedicalDocument.
     * @example
     * // Update one MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicalDocumentUpdateArgs>(args: SelectSubset<T, MedicalDocumentUpdateArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MedicalDocuments.
     * @param {MedicalDocumentDeleteManyArgs} args - Arguments to filter MedicalDocuments to delete.
     * @example
     * // Delete a few MedicalDocuments
     * const { count } = await prisma.medicalDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicalDocumentDeleteManyArgs>(args?: SelectSubset<T, MedicalDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicalDocuments
     * const medicalDocument = await prisma.medicalDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicalDocumentUpdateManyArgs>(args: SelectSubset<T, MedicalDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicalDocument.
     * @param {MedicalDocumentUpsertArgs} args - Arguments to update or create a MedicalDocument.
     * @example
     * // Update or create a MedicalDocument
     * const medicalDocument = await prisma.medicalDocument.upsert({
     *   create: {
     *     // ... data to create a MedicalDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicalDocument we want to update
     *   }
     * })
     */
    upsert<T extends MedicalDocumentUpsertArgs>(args: SelectSubset<T, MedicalDocumentUpsertArgs<ExtArgs>>): Prisma__MedicalDocumentClient<$Result.GetResult<Prisma.$MedicalDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MedicalDocuments that matches the filter.
     * @param {MedicalDocumentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const medicalDocument = await prisma.medicalDocument.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MedicalDocumentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a MedicalDocument.
     * @param {MedicalDocumentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const medicalDocument = await prisma.medicalDocument.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: MedicalDocumentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of MedicalDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentCountArgs} args - Arguments to filter MedicalDocuments to count.
     * @example
     * // Count the number of MedicalDocuments
     * const count = await prisma.medicalDocument.count({
     *   where: {
     *     // ... the filter for the MedicalDocuments we want to count
     *   }
     * })
    **/
    count<T extends MedicalDocumentCountArgs>(
      args?: Subset<T, MedicalDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicalDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicalDocumentAggregateArgs>(args: Subset<T, MedicalDocumentAggregateArgs>): Prisma.PrismaPromise<GetMedicalDocumentAggregateType<T>>

    /**
     * Group by MedicalDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicalDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicalDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicalDocumentGroupByArgs['orderBy'] }
        : { orderBy?: MedicalDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicalDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicalDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicalDocument model
   */
  readonly fields: MedicalDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicalDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicalDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    medicalEvent<T extends MedicalDocument$medicalEventArgs<ExtArgs> = {}>(args?: Subset<T, MedicalDocument$medicalEventArgs<ExtArgs>>): Prisma__MedicalEventClient<$Result.GetResult<Prisma.$MedicalEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicalDocument model
   */
  interface MedicalDocumentFieldRefs {
    readonly id: FieldRef<"MedicalDocument", 'String'>
    readonly medicalEventId: FieldRef<"MedicalDocument", 'String'>
    readonly title: FieldRef<"MedicalDocument", 'String'>
    readonly description: FieldRef<"MedicalDocument", 'String'>
    readonly fileName: FieldRef<"MedicalDocument", 'String'>
    readonly filePath: FieldRef<"MedicalDocument", 'String'>
    readonly fileSize: FieldRef<"MedicalDocument", 'Int'>
    readonly mimeType: FieldRef<"MedicalDocument", 'String'>
    readonly createdAt: FieldRef<"MedicalDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicalDocument findUnique
   */
  export type MedicalDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where: MedicalDocumentWhereUniqueInput
  }

  /**
   * MedicalDocument findUniqueOrThrow
   */
  export type MedicalDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where: MedicalDocumentWhereUniqueInput
  }

  /**
   * MedicalDocument findFirst
   */
  export type MedicalDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalDocuments.
     */
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }

  /**
   * MedicalDocument findFirstOrThrow
   */
  export type MedicalDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocument to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicalDocuments.
     */
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }

  /**
   * MedicalDocument findMany
   */
  export type MedicalDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter, which MedicalDocuments to fetch.
     */
    where?: MedicalDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicalDocuments to fetch.
     */
    orderBy?: MedicalDocumentOrderByWithRelationInput | MedicalDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicalDocuments.
     */
    cursor?: MedicalDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicalDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicalDocuments.
     */
    skip?: number
    distinct?: MedicalDocumentScalarFieldEnum | MedicalDocumentScalarFieldEnum[]
  }

  /**
   * MedicalDocument create
   */
  export type MedicalDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicalDocument.
     */
    data: XOR<MedicalDocumentCreateInput, MedicalDocumentUncheckedCreateInput>
  }

  /**
   * MedicalDocument createMany
   */
  export type MedicalDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicalDocuments.
     */
    data: MedicalDocumentCreateManyInput | MedicalDocumentCreateManyInput[]
  }

  /**
   * MedicalDocument update
   */
  export type MedicalDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicalDocument.
     */
    data: XOR<MedicalDocumentUpdateInput, MedicalDocumentUncheckedUpdateInput>
    /**
     * Choose, which MedicalDocument to update.
     */
    where: MedicalDocumentWhereUniqueInput
  }

  /**
   * MedicalDocument updateMany
   */
  export type MedicalDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicalDocuments.
     */
    data: XOR<MedicalDocumentUpdateManyMutationInput, MedicalDocumentUncheckedUpdateManyInput>
    /**
     * Filter which MedicalDocuments to update
     */
    where?: MedicalDocumentWhereInput
    /**
     * Limit how many MedicalDocuments to update.
     */
    limit?: number
  }

  /**
   * MedicalDocument upsert
   */
  export type MedicalDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicalDocument to update in case it exists.
     */
    where: MedicalDocumentWhereUniqueInput
    /**
     * In case the MedicalDocument found by the `where` argument doesn't exist, create a new MedicalDocument with this data.
     */
    create: XOR<MedicalDocumentCreateInput, MedicalDocumentUncheckedCreateInput>
    /**
     * In case the MedicalDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicalDocumentUpdateInput, MedicalDocumentUncheckedUpdateInput>
  }

  /**
   * MedicalDocument delete
   */
  export type MedicalDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
    /**
     * Filter which MedicalDocument to delete.
     */
    where: MedicalDocumentWhereUniqueInput
  }

  /**
   * MedicalDocument deleteMany
   */
  export type MedicalDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicalDocuments to delete
     */
    where?: MedicalDocumentWhereInput
    /**
     * Limit how many MedicalDocuments to delete.
     */
    limit?: number
  }

  /**
   * MedicalDocument findRaw
   */
  export type MedicalDocumentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalDocument aggregateRaw
   */
  export type MedicalDocumentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * MedicalDocument.medicalEvent
   */
  export type MedicalDocument$medicalEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalEvent
     */
    select?: MedicalEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalEvent
     */
    omit?: MedicalEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalEventInclude<ExtArgs> | null
    where?: MedicalEventWhereInput
  }

  /**
   * MedicalDocument without action
   */
  export type MedicalDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalDocument
     */
    select?: MedicalDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalDocument
     */
    omit?: MedicalDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    category: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    title: string | null
    content: string | null
    excerpt: string | null
    coverImage: string | null
    category: string | null
    isPublished: boolean | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    authorId: number
    title: number
    content: number
    excerpt: number
    coverImage: number
    category: number
    tags: number
    isPublished: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    excerpt?: true
    coverImage?: true
    category?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    excerpt?: true
    coverImage?: true
    category?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    authorId?: true
    title?: true
    content?: true
    excerpt?: true
    coverImage?: true
    category?: true
    tags?: true
    isPublished?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    authorId: string
    title: string
    content: string
    excerpt: string | null
    coverImage: string | null
    category: string | null
    tags: string[]
    isPublished: boolean
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    category?: boolean
    tags?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>



  export type PostSelectScalar = {
    id?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    excerpt?: boolean
    coverImage?: boolean
    category?: boolean
    tags?: boolean
    isPublished?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "authorId" | "title" | "content" | "excerpt" | "coverImage" | "category" | "tags" | "isPublished" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      title: string
      content: string
      excerpt: string | null
      coverImage: string | null
      category: string | null
      tags: string[]
      isPublished: boolean
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * @param {PostFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const post = await prisma.post.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PostFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Post.
     * @param {PostAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const post = await prisma.post.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PostAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly authorId: FieldRef<"Post", 'String'>
    readonly title: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly excerpt: FieldRef<"Post", 'String'>
    readonly coverImage: FieldRef<"Post", 'String'>
    readonly category: FieldRef<"Post", 'String'>
    readonly tags: FieldRef<"Post", 'String[]'>
    readonly isPublished: FieldRef<"Post", 'Boolean'>
    readonly publishedAt: FieldRef<"Post", 'DateTime'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post findRaw
   */
  export type PostFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post aggregateRaw
   */
  export type PostAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    vaccinationCampaignId: string | null
    medicalCheckCampaignId: string | null
    title: string | null
    message: string | null
    type: string | null
    status: $Enums.NotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    vaccinationCampaignId: string | null
    medicalCheckCampaignId: string | null
    title: string | null
    message: string | null
    type: string | null
    status: $Enums.NotificationStatus | null
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    vaccinationCampaignId: number
    medicalCheckCampaignId: number
    title: number
    message: number
    type: number
    status: number
    scheduledAt: number
    sentAt: number
    readAt: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    vaccinationCampaignId?: true
    medicalCheckCampaignId?: true
    title?: true
    message?: true
    type?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    vaccinationCampaignId?: true
    medicalCheckCampaignId?: true
    title?: true
    message?: true
    type?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    vaccinationCampaignId?: true
    medicalCheckCampaignId?: true
    title?: true
    message?: true
    type?: true
    status?: true
    scheduledAt?: true
    sentAt?: true
    readAt?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    vaccinationCampaignId: string | null
    medicalCheckCampaignId: string | null
    title: string
    message: string
    type: string
    status: $Enums.NotificationStatus
    scheduledAt: Date | null
    sentAt: Date | null
    readAt: Date | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    vaccinationCampaignId?: boolean
    medicalCheckCampaignId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    vaccinationCampaign?: boolean | Notification$vaccinationCampaignArgs<ExtArgs>
    medicalCheckCampaign?: boolean | Notification$medicalCheckCampaignArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>



  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    vaccinationCampaignId?: boolean
    medicalCheckCampaignId?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    status?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    readAt?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "vaccinationCampaignId" | "medicalCheckCampaignId" | "title" | "message" | "type" | "status" | "scheduledAt" | "sentAt" | "readAt" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    vaccinationCampaign?: boolean | Notification$vaccinationCampaignArgs<ExtArgs>
    medicalCheckCampaign?: boolean | Notification$medicalCheckCampaignArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      vaccinationCampaign: Prisma.$VaccinationCampaignPayload<ExtArgs> | null
      medicalCheckCampaign: Prisma.$MedicalCheckCampaignPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      vaccinationCampaignId: string | null
      medicalCheckCampaignId: string | null
      title: string
      message: string
      type: string
      status: $Enums.NotificationStatus
      scheduledAt: Date | null
      sentAt: Date | null
      readAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: NotificationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vaccinationCampaign<T extends Notification$vaccinationCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Notification$vaccinationCampaignArgs<ExtArgs>>): Prisma__VaccinationCampaignClient<$Result.GetResult<Prisma.$VaccinationCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    medicalCheckCampaign<T extends Notification$medicalCheckCampaignArgs<ExtArgs> = {}>(args?: Subset<T, Notification$medicalCheckCampaignArgs<ExtArgs>>): Prisma__MedicalCheckCampaignClient<$Result.GetResult<Prisma.$MedicalCheckCampaignPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly vaccinationCampaignId: FieldRef<"Notification", 'String'>
    readonly medicalCheckCampaignId: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly scheduledAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Notification.vaccinationCampaign
   */
  export type Notification$vaccinationCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VaccinationCampaign
     */
    select?: VaccinationCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VaccinationCampaign
     */
    omit?: VaccinationCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VaccinationCampaignInclude<ExtArgs> | null
    where?: VaccinationCampaignWhereInput
  }

  /**
   * Notification.medicalCheckCampaign
   */
  export type Notification$medicalCheckCampaignArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicalCheckCampaign
     */
    select?: MedicalCheckCampaignSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MedicalCheckCampaign
     */
    omit?: MedicalCheckCampaignOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicalCheckCampaignInclude<ExtArgs> | null
    where?: MedicalCheckCampaignWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    resource: string
    resourceId: string | null
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>



  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      resource: string
      resourceId: string | null
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * @param {AuditLogFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AuditLogFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AuditLog.
     * @param {AuditLogAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auditLog = await prisma.auditLog.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AuditLogAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog findRaw
   */
  export type AuditLogFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AuditLog aggregateRaw
   */
  export type AuditLogAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model SchoolInfo
   */

  export type AggregateSchoolInfo = {
    _count: SchoolInfoCountAggregateOutputType | null
    _min: SchoolInfoMinAggregateOutputType | null
    _max: SchoolInfoMaxAggregateOutputType | null
  }

  export type SchoolInfoMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    description: string | null
    healthDeptHead: string | null
    healthDeptPhone: string | null
    healthDeptEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolInfoMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    description: string | null
    healthDeptHead: string | null
    healthDeptPhone: string | null
    healthDeptEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SchoolInfoCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    email: number
    website: number
    logo: number
    description: number
    healthDeptHead: number
    healthDeptPhone: number
    healthDeptEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SchoolInfoMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    description?: true
    healthDeptHead?: true
    healthDeptPhone?: true
    healthDeptEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolInfoMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    description?: true
    healthDeptHead?: true
    healthDeptPhone?: true
    healthDeptEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SchoolInfoCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    website?: true
    logo?: true
    description?: true
    healthDeptHead?: true
    healthDeptPhone?: true
    healthDeptEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SchoolInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolInfo to aggregate.
     */
    where?: SchoolInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolInfos to fetch.
     */
    orderBy?: SchoolInfoOrderByWithRelationInput | SchoolInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolInfos
    **/
    _count?: true | SchoolInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolInfoMaxAggregateInputType
  }

  export type GetSchoolInfoAggregateType<T extends SchoolInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolInfo[P]>
      : GetScalarType<T[P], AggregateSchoolInfo[P]>
  }




  export type SchoolInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolInfoWhereInput
    orderBy?: SchoolInfoOrderByWithAggregationInput | SchoolInfoOrderByWithAggregationInput[]
    by: SchoolInfoScalarFieldEnum[] | SchoolInfoScalarFieldEnum
    having?: SchoolInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolInfoCountAggregateInputType | true
    _min?: SchoolInfoMinAggregateInputType
    _max?: SchoolInfoMaxAggregateInputType
  }

  export type SchoolInfoGroupByOutputType = {
    id: string
    name: string
    address: string
    phone: string | null
    email: string | null
    website: string | null
    logo: string | null
    description: string | null
    healthDeptHead: string | null
    healthDeptPhone: string | null
    healthDeptEmail: string | null
    createdAt: Date
    updatedAt: Date
    _count: SchoolInfoCountAggregateOutputType | null
    _min: SchoolInfoMinAggregateOutputType | null
    _max: SchoolInfoMaxAggregateOutputType | null
  }

  type GetSchoolInfoGroupByPayload<T extends SchoolInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolInfoGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolInfoGroupByOutputType[P]>
        }
      >
    >


  export type SchoolInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    healthDeptHead?: boolean
    healthDeptPhone?: boolean
    healthDeptEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["schoolInfo"]>



  export type SchoolInfoSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    website?: boolean
    logo?: boolean
    description?: boolean
    healthDeptHead?: boolean
    healthDeptPhone?: boolean
    healthDeptEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SchoolInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "phone" | "email" | "website" | "logo" | "description" | "healthDeptHead" | "healthDeptPhone" | "healthDeptEmail" | "createdAt" | "updatedAt", ExtArgs["result"]["schoolInfo"]>

  export type $SchoolInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolInfo"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      phone: string | null
      email: string | null
      website: string | null
      logo: string | null
      description: string | null
      healthDeptHead: string | null
      healthDeptPhone: string | null
      healthDeptEmail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["schoolInfo"]>
    composites: {}
  }

  type SchoolInfoGetPayload<S extends boolean | null | undefined | SchoolInfoDefaultArgs> = $Result.GetResult<Prisma.$SchoolInfoPayload, S>

  type SchoolInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolInfoCountAggregateInputType | true
    }

  export interface SchoolInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolInfo'], meta: { name: 'SchoolInfo' } }
    /**
     * Find zero or one SchoolInfo that matches the filter.
     * @param {SchoolInfoFindUniqueArgs} args - Arguments to find a SchoolInfo
     * @example
     * // Get one SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolInfoFindUniqueArgs>(args: SelectSubset<T, SchoolInfoFindUniqueArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolInfoFindUniqueOrThrowArgs} args - Arguments to find a SchoolInfo
     * @example
     * // Get one SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoFindFirstArgs} args - Arguments to find a SchoolInfo
     * @example
     * // Get one SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolInfoFindFirstArgs>(args?: SelectSubset<T, SchoolInfoFindFirstArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoFindFirstOrThrowArgs} args - Arguments to find a SchoolInfo
     * @example
     * // Get one SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolInfos
     * const schoolInfos = await prisma.schoolInfo.findMany()
     * 
     * // Get first 10 SchoolInfos
     * const schoolInfos = await prisma.schoolInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolInfoWithIdOnly = await prisma.schoolInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolInfoFindManyArgs>(args?: SelectSubset<T, SchoolInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolInfo.
     * @param {SchoolInfoCreateArgs} args - Arguments to create a SchoolInfo.
     * @example
     * // Create one SchoolInfo
     * const SchoolInfo = await prisma.schoolInfo.create({
     *   data: {
     *     // ... data to create a SchoolInfo
     *   }
     * })
     * 
     */
    create<T extends SchoolInfoCreateArgs>(args: SelectSubset<T, SchoolInfoCreateArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolInfos.
     * @param {SchoolInfoCreateManyArgs} args - Arguments to create many SchoolInfos.
     * @example
     * // Create many SchoolInfos
     * const schoolInfo = await prisma.schoolInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolInfoCreateManyArgs>(args?: SelectSubset<T, SchoolInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SchoolInfo.
     * @param {SchoolInfoDeleteArgs} args - Arguments to delete one SchoolInfo.
     * @example
     * // Delete one SchoolInfo
     * const SchoolInfo = await prisma.schoolInfo.delete({
     *   where: {
     *     // ... filter to delete one SchoolInfo
     *   }
     * })
     * 
     */
    delete<T extends SchoolInfoDeleteArgs>(args: SelectSubset<T, SchoolInfoDeleteArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolInfo.
     * @param {SchoolInfoUpdateArgs} args - Arguments to update one SchoolInfo.
     * @example
     * // Update one SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolInfoUpdateArgs>(args: SelectSubset<T, SchoolInfoUpdateArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolInfos.
     * @param {SchoolInfoDeleteManyArgs} args - Arguments to filter SchoolInfos to delete.
     * @example
     * // Delete a few SchoolInfos
     * const { count } = await prisma.schoolInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolInfoDeleteManyArgs>(args?: SelectSubset<T, SchoolInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolInfos
     * const schoolInfo = await prisma.schoolInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolInfoUpdateManyArgs>(args: SelectSubset<T, SchoolInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SchoolInfo.
     * @param {SchoolInfoUpsertArgs} args - Arguments to update or create a SchoolInfo.
     * @example
     * // Update or create a SchoolInfo
     * const schoolInfo = await prisma.schoolInfo.upsert({
     *   create: {
     *     // ... data to create a SchoolInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolInfo we want to update
     *   }
     * })
     */
    upsert<T extends SchoolInfoUpsertArgs>(args: SelectSubset<T, SchoolInfoUpsertArgs<ExtArgs>>): Prisma__SchoolInfoClient<$Result.GetResult<Prisma.$SchoolInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolInfos that matches the filter.
     * @param {SchoolInfoFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const schoolInfo = await prisma.schoolInfo.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SchoolInfoFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a SchoolInfo.
     * @param {SchoolInfoAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const schoolInfo = await prisma.schoolInfo.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SchoolInfoAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of SchoolInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoCountArgs} args - Arguments to filter SchoolInfos to count.
     * @example
     * // Count the number of SchoolInfos
     * const count = await prisma.schoolInfo.count({
     *   where: {
     *     // ... the filter for the SchoolInfos we want to count
     *   }
     * })
    **/
    count<T extends SchoolInfoCountArgs>(
      args?: Subset<T, SchoolInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolInfoAggregateArgs>(args: Subset<T, SchoolInfoAggregateArgs>): Prisma.PrismaPromise<GetSchoolInfoAggregateType<T>>

    /**
     * Group by SchoolInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolInfoGroupByArgs['orderBy'] }
        : { orderBy?: SchoolInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolInfo model
   */
  readonly fields: SchoolInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolInfo model
   */
  interface SchoolInfoFieldRefs {
    readonly id: FieldRef<"SchoolInfo", 'String'>
    readonly name: FieldRef<"SchoolInfo", 'String'>
    readonly address: FieldRef<"SchoolInfo", 'String'>
    readonly phone: FieldRef<"SchoolInfo", 'String'>
    readonly email: FieldRef<"SchoolInfo", 'String'>
    readonly website: FieldRef<"SchoolInfo", 'String'>
    readonly logo: FieldRef<"SchoolInfo", 'String'>
    readonly description: FieldRef<"SchoolInfo", 'String'>
    readonly healthDeptHead: FieldRef<"SchoolInfo", 'String'>
    readonly healthDeptPhone: FieldRef<"SchoolInfo", 'String'>
    readonly healthDeptEmail: FieldRef<"SchoolInfo", 'String'>
    readonly createdAt: FieldRef<"SchoolInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"SchoolInfo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SchoolInfo findUnique
   */
  export type SchoolInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter, which SchoolInfo to fetch.
     */
    where: SchoolInfoWhereUniqueInput
  }

  /**
   * SchoolInfo findUniqueOrThrow
   */
  export type SchoolInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter, which SchoolInfo to fetch.
     */
    where: SchoolInfoWhereUniqueInput
  }

  /**
   * SchoolInfo findFirst
   */
  export type SchoolInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter, which SchoolInfo to fetch.
     */
    where?: SchoolInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolInfos to fetch.
     */
    orderBy?: SchoolInfoOrderByWithRelationInput | SchoolInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolInfos.
     */
    cursor?: SchoolInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolInfos.
     */
    distinct?: SchoolInfoScalarFieldEnum | SchoolInfoScalarFieldEnum[]
  }

  /**
   * SchoolInfo findFirstOrThrow
   */
  export type SchoolInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter, which SchoolInfo to fetch.
     */
    where?: SchoolInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolInfos to fetch.
     */
    orderBy?: SchoolInfoOrderByWithRelationInput | SchoolInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolInfos.
     */
    cursor?: SchoolInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolInfos.
     */
    distinct?: SchoolInfoScalarFieldEnum | SchoolInfoScalarFieldEnum[]
  }

  /**
   * SchoolInfo findMany
   */
  export type SchoolInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter, which SchoolInfos to fetch.
     */
    where?: SchoolInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolInfos to fetch.
     */
    orderBy?: SchoolInfoOrderByWithRelationInput | SchoolInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolInfos.
     */
    cursor?: SchoolInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SchoolInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolInfos.
     */
    skip?: number
    distinct?: SchoolInfoScalarFieldEnum | SchoolInfoScalarFieldEnum[]
  }

  /**
   * SchoolInfo create
   */
  export type SchoolInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * The data needed to create a SchoolInfo.
     */
    data: XOR<SchoolInfoCreateInput, SchoolInfoUncheckedCreateInput>
  }

  /**
   * SchoolInfo createMany
   */
  export type SchoolInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolInfos.
     */
    data: SchoolInfoCreateManyInput | SchoolInfoCreateManyInput[]
  }

  /**
   * SchoolInfo update
   */
  export type SchoolInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * The data needed to update a SchoolInfo.
     */
    data: XOR<SchoolInfoUpdateInput, SchoolInfoUncheckedUpdateInput>
    /**
     * Choose, which SchoolInfo to update.
     */
    where: SchoolInfoWhereUniqueInput
  }

  /**
   * SchoolInfo updateMany
   */
  export type SchoolInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolInfos.
     */
    data: XOR<SchoolInfoUpdateManyMutationInput, SchoolInfoUncheckedUpdateManyInput>
    /**
     * Filter which SchoolInfos to update
     */
    where?: SchoolInfoWhereInput
    /**
     * Limit how many SchoolInfos to update.
     */
    limit?: number
  }

  /**
   * SchoolInfo upsert
   */
  export type SchoolInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * The filter to search for the SchoolInfo to update in case it exists.
     */
    where: SchoolInfoWhereUniqueInput
    /**
     * In case the SchoolInfo found by the `where` argument doesn't exist, create a new SchoolInfo with this data.
     */
    create: XOR<SchoolInfoCreateInput, SchoolInfoUncheckedCreateInput>
    /**
     * In case the SchoolInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolInfoUpdateInput, SchoolInfoUncheckedUpdateInput>
  }

  /**
   * SchoolInfo delete
   */
  export type SchoolInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
    /**
     * Filter which SchoolInfo to delete.
     */
    where: SchoolInfoWhereUniqueInput
  }

  /**
   * SchoolInfo deleteMany
   */
  export type SchoolInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolInfos to delete
     */
    where?: SchoolInfoWhereInput
    /**
     * Limit how many SchoolInfos to delete.
     */
    limit?: number
  }

  /**
   * SchoolInfo findRaw
   */
  export type SchoolInfoFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SchoolInfo aggregateRaw
   */
  export type SchoolInfoAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * SchoolInfo without action
   */
  export type SchoolInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolInfo
     */
    select?: SchoolInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolInfo
     */
    omit?: SchoolInfoOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UsersScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    password: 'password',
    email: 'email',
    role: 'role',
    phone: 'phone',
    address: 'address',
    avatar: 'avatar',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    studentCode: 'studentCode',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    class: 'class',
    grade: 'grade',
    bloodType: 'bloodType',
    emergencyContact: 'emergencyContact',
    emergencyPhone: 'emergencyPhone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ParentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    occupation: 'occupation',
    workplace: 'workplace',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParentScalarFieldEnum = (typeof ParentScalarFieldEnum)[keyof typeof ParentScalarFieldEnum]


  export const SchoolNurseScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    licenseNumber: 'licenseNumber',
    specialization: 'specialization',
    experience: 'experience',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolNurseScalarFieldEnum = (typeof SchoolNurseScalarFieldEnum)[keyof typeof SchoolNurseScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    department: 'department',
    position: 'position',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const AdminScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminScalarFieldEnum = (typeof AdminScalarFieldEnum)[keyof typeof AdminScalarFieldEnum]


  export const StudentParentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    relationship: 'relationship',
    isPrimary: 'isPrimary'
  };

  export type StudentParentScalarFieldEnum = (typeof StudentParentScalarFieldEnum)[keyof typeof StudentParentScalarFieldEnum]


  export const HealthProfileScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    allergies: 'allergies',
    chronicDiseases: 'chronicDiseases',
    medications: 'medications',
    treatmentHistory: 'treatmentHistory',
    vision: 'vision',
    hearing: 'hearing',
    height: 'height',
    weight: 'weight',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthProfileScalarFieldEnum = (typeof HealthProfileScalarFieldEnum)[keyof typeof HealthProfileScalarFieldEnum]


  export const MedicalEventScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    nurseId: 'nurseId',
    createdById: 'createdById',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    severity: 'severity',
    location: 'location',
    symptoms: 'symptoms',
    treatment: 'treatment',
    outcome: 'outcome',
    occurredAt: 'occurredAt',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalEventScalarFieldEnum = (typeof MedicalEventScalarFieldEnum)[keyof typeof MedicalEventScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    dosage: 'dosage',
    unit: 'unit',
    manufacturer: 'manufacturer',
    expiryDate: 'expiryDate',
    stockQuantity: 'stockQuantity',
    minStockLevel: 'minStockLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const StudentMedicationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    parentId: 'parentId',
    medicationId: 'medicationId',
    dosage: 'dosage',
    frequency: 'frequency',
    duration: 'duration',
    instructions: 'instructions',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentMedicationScalarFieldEnum = (typeof StudentMedicationScalarFieldEnum)[keyof typeof StudentMedicationScalarFieldEnum]


  export const MedicalEventMedicationScalarFieldEnum: {
    id: 'id',
    medicalEventId: 'medicalEventId',
    medicationId: 'medicationId',
    quantityUsed: 'quantityUsed',
    dosageGiven: 'dosageGiven',
    administeredAt: 'administeredAt',
    notes: 'notes'
  };

  export type MedicalEventMedicationScalarFieldEnum = (typeof MedicalEventMedicationScalarFieldEnum)[keyof typeof MedicalEventMedicationScalarFieldEnum]


  export const StockMovementScalarFieldEnum: {
    id: 'id',
    medicationId: 'medicationId',
    type: 'type',
    quantity: 'quantity',
    reason: 'reason',
    reference: 'reference',
    createdAt: 'createdAt'
  };

  export type StockMovementScalarFieldEnum = (typeof StockMovementScalarFieldEnum)[keyof typeof StockMovementScalarFieldEnum]


  export const VaccinationCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    vaccineName: 'vaccineName',
    targetGrades: 'targetGrades',
    scheduledDate: 'scheduledDate',
    deadline: 'deadline',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaccinationCampaignScalarFieldEnum = (typeof VaccinationCampaignScalarFieldEnum)[keyof typeof VaccinationCampaignScalarFieldEnum]


  export const VaccinationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    campaignId: 'campaignId',
    nurseId: 'nurseId',
    status: 'status',
    scheduledDate: 'scheduledDate',
    administeredDate: 'administeredDate',
    dose: 'dose',
    batch: 'batch',
    sideEffects: 'sideEffects',
    notes: 'notes',
    parentConsent: 'parentConsent',
    consentDate: 'consentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VaccinationScalarFieldEnum = (typeof VaccinationScalarFieldEnum)[keyof typeof VaccinationScalarFieldEnum]


  export const MedicalCheckCampaignScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    checkTypes: 'checkTypes',
    targetGrades: 'targetGrades',
    scheduledDate: 'scheduledDate',
    deadline: 'deadline',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalCheckCampaignScalarFieldEnum = (typeof MedicalCheckCampaignScalarFieldEnum)[keyof typeof MedicalCheckCampaignScalarFieldEnum]


  export const MedicalCheckScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    campaignId: 'campaignId',
    nurseId: 'nurseId',
    status: 'status',
    scheduledDate: 'scheduledDate',
    completedDate: 'completedDate',
    visionResult: 'visionResult',
    hearingResult: 'hearingResult',
    dentalResult: 'dentalResult',
    heightWeight: 'heightWeight',
    generalHealth: 'generalHealth',
    recommendations: 'recommendations',
    requiresFollowUp: 'requiresFollowUp',
    followUpDate: 'followUpDate',
    notes: 'notes',
    parentNotified: 'parentNotified',
    parentResponse: 'parentResponse',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicalCheckScalarFieldEnum = (typeof MedicalCheckScalarFieldEnum)[keyof typeof MedicalCheckScalarFieldEnum]


  export const MedicalDocumentScalarFieldEnum: {
    id: 'id',
    medicalEventId: 'medicalEventId',
    title: 'title',
    description: 'description',
    fileName: 'fileName',
    filePath: 'filePath',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt'
  };

  export type MedicalDocumentScalarFieldEnum = (typeof MedicalDocumentScalarFieldEnum)[keyof typeof MedicalDocumentScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    excerpt: 'excerpt',
    coverImage: 'coverImage',
    category: 'category',
    tags: 'tags',
    isPublished: 'isPublished',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    vaccinationCampaignId: 'vaccinationCampaignId',
    medicalCheckCampaignId: 'medicalCheckCampaignId',
    title: 'title',
    message: 'message',
    type: 'type',
    status: 'status',
    scheduledAt: 'scheduledAt',
    sentAt: 'sentAt',
    readAt: 'readAt',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SchoolInfoScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    website: 'website',
    logo: 'logo',
    description: 'description',
    healthDeptHead: 'healthDeptHead',
    healthDeptPhone: 'healthDeptPhone',
    healthDeptEmail: 'healthDeptEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SchoolInfoScalarFieldEnum = (typeof SchoolInfoScalarFieldEnum)[keyof typeof SchoolInfoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'MedicalEventType'
   */
  export type EnumMedicalEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalEventType'>
    


  /**
   * Reference to a field of type 'MedicalEventType[]'
   */
  export type ListEnumMedicalEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalEventType[]'>
    


  /**
   * Reference to a field of type 'MedicalEventStatus'
   */
  export type EnumMedicalEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalEventStatus'>
    


  /**
   * Reference to a field of type 'MedicalEventStatus[]'
   */
  export type ListEnumMedicalEventStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalEventStatus[]'>
    


  /**
   * Reference to a field of type 'MedicationStatus'
   */
  export type EnumMedicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationStatus'>
    


  /**
   * Reference to a field of type 'MedicationStatus[]'
   */
  export type ListEnumMedicationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicationStatus[]'>
    


  /**
   * Reference to a field of type 'VaccinationStatus'
   */
  export type EnumVaccinationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VaccinationStatus'>
    


  /**
   * Reference to a field of type 'VaccinationStatus[]'
   */
  export type ListEnumVaccinationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VaccinationStatus[]'>
    


  /**
   * Reference to a field of type 'MedicalCheckStatus'
   */
  export type EnumMedicalCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalCheckStatus'>
    


  /**
   * Reference to a field of type 'MedicalCheckStatus[]'
   */
  export type ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MedicalCheckStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    fullName?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    phone?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    studentProfile?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parentProfile?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    nurseProfile?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
    managerProfile?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdPosts?: PostListRelationFilter
    createdEvents?: MedicalEventListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentProfile?: StudentOrderByWithRelationInput
    parentProfile?: ParentOrderByWithRelationInput
    nurseProfile?: SchoolNurseOrderByWithRelationInput
    managerProfile?: ManagerOrderByWithRelationInput
    adminProfile?: AdminOrderByWithRelationInput
    createdPosts?: PostOrderByRelationAggregateInput
    createdEvents?: MedicalEventOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    fullName?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    role?: EnumUserRoleFilter<"users"> | $Enums.UserRole
    phone?: StringNullableFilter<"users"> | string | null
    address?: StringNullableFilter<"users"> | string | null
    avatar?: StringNullableFilter<"users"> | string | null
    isActive?: BoolFilter<"users"> | boolean
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    studentProfile?: XOR<StudentNullableScalarRelationFilter, StudentWhereInput> | null
    parentProfile?: XOR<ParentNullableScalarRelationFilter, ParentWhereInput> | null
    nurseProfile?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
    managerProfile?: XOR<ManagerNullableScalarRelationFilter, ManagerWhereInput> | null
    adminProfile?: XOR<AdminNullableScalarRelationFilter, AdminWhereInput> | null
    createdPosts?: PostListRelationFilter
    createdEvents?: MedicalEventListRelationFilter
    notifications?: NotificationListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    fullName?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    role?: EnumUserRoleWithAggregatesFilter<"users"> | $Enums.UserRole
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    address?: StringNullableWithAggregatesFilter<"users"> | string | null
    avatar?: StringNullableWithAggregatesFilter<"users"> | string | null
    isActive?: BoolWithAggregatesFilter<"users"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    studentCode?: StringFilter<"Student"> | string
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    class?: StringFilter<"Student"> | string
    grade?: StringFilter<"Student"> | string
    bloodType?: StringNullableFilter<"Student"> | string | null
    emergencyContact?: StringFilter<"Student"> | string
    emergencyPhone?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    parents?: StudentParentListRelationFilter
    healthProfile?: XOR<HealthProfileNullableScalarRelationFilter, HealthProfileWhereInput> | null
    medicalEvents?: MedicalEventListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    medicalChecks?: MedicalCheckListRelationFilter
    medications?: StudentMedicationListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentCode?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    class?: SortOrder
    grade?: SortOrder
    bloodType?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    parents?: StudentParentOrderByRelationAggregateInput
    healthProfile?: HealthProfileOrderByWithRelationInput
    medicalEvents?: MedicalEventOrderByRelationAggregateInput
    vaccinations?: VaccinationOrderByRelationAggregateInput
    medicalChecks?: MedicalCheckOrderByRelationAggregateInput
    medications?: StudentMedicationOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    studentCode?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    dateOfBirth?: DateTimeFilter<"Student"> | Date | string
    gender?: StringFilter<"Student"> | string
    class?: StringFilter<"Student"> | string
    grade?: StringFilter<"Student"> | string
    bloodType?: StringNullableFilter<"Student"> | string | null
    emergencyContact?: StringFilter<"Student"> | string
    emergencyPhone?: StringFilter<"Student"> | string
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    parents?: StudentParentListRelationFilter
    healthProfile?: XOR<HealthProfileNullableScalarRelationFilter, HealthProfileWhereInput> | null
    medicalEvents?: MedicalEventListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    medicalChecks?: MedicalCheckListRelationFilter
    medications?: StudentMedicationListRelationFilter
  }, "id" | "userId" | "studentCode">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    studentCode?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    class?: SortOrder
    grade?: SortOrder
    bloodType?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    studentCode?: StringWithAggregatesFilter<"Student"> | string
    dateOfBirth?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    gender?: StringWithAggregatesFilter<"Student"> | string
    class?: StringWithAggregatesFilter<"Student"> | string
    grade?: StringWithAggregatesFilter<"Student"> | string
    bloodType?: StringNullableWithAggregatesFilter<"Student"> | string | null
    emergencyContact?: StringWithAggregatesFilter<"Student"> | string
    emergencyPhone?: StringWithAggregatesFilter<"Student"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ParentWhereInput = {
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    id?: StringFilter<"Parent"> | string
    userId?: StringFilter<"Parent"> | string
    occupation?: StringNullableFilter<"Parent"> | string | null
    workplace?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    children?: StudentParentListRelationFilter
    medications?: StudentMedicationListRelationFilter
  }

  export type ParentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    children?: StudentParentOrderByRelationAggregateInput
    medications?: StudentMedicationOrderByRelationAggregateInput
  }

  export type ParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ParentWhereInput | ParentWhereInput[]
    OR?: ParentWhereInput[]
    NOT?: ParentWhereInput | ParentWhereInput[]
    occupation?: StringNullableFilter<"Parent"> | string | null
    workplace?: StringNullableFilter<"Parent"> | string | null
    createdAt?: DateTimeFilter<"Parent"> | Date | string
    updatedAt?: DateTimeFilter<"Parent"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    children?: StudentParentListRelationFilter
    medications?: StudentMedicationListRelationFilter
  }, "id" | "userId">

  export type ParentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParentCountOrderByAggregateInput
    _max?: ParentMaxOrderByAggregateInput
    _min?: ParentMinOrderByAggregateInput
  }

  export type ParentScalarWhereWithAggregatesInput = {
    AND?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    OR?: ParentScalarWhereWithAggregatesInput[]
    NOT?: ParentScalarWhereWithAggregatesInput | ParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Parent"> | string
    userId?: StringWithAggregatesFilter<"Parent"> | string
    occupation?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    workplace?: StringNullableWithAggregatesFilter<"Parent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Parent"> | Date | string
  }

  export type SchoolNurseWhereInput = {
    AND?: SchoolNurseWhereInput | SchoolNurseWhereInput[]
    OR?: SchoolNurseWhereInput[]
    NOT?: SchoolNurseWhereInput | SchoolNurseWhereInput[]
    id?: StringFilter<"SchoolNurse"> | string
    userId?: StringFilter<"SchoolNurse"> | string
    licenseNumber?: StringFilter<"SchoolNurse"> | string
    specialization?: StringNullableFilter<"SchoolNurse"> | string | null
    experience?: IntNullableFilter<"SchoolNurse"> | number | null
    createdAt?: DateTimeFilter<"SchoolNurse"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolNurse"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    handledEvents?: MedicalEventListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    medicalChecks?: MedicalCheckListRelationFilter
  }

  export type SchoolNurseOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
    handledEvents?: MedicalEventOrderByRelationAggregateInput
    vaccinations?: VaccinationOrderByRelationAggregateInput
    medicalChecks?: MedicalCheckOrderByRelationAggregateInput
  }

  export type SchoolNurseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    licenseNumber?: string
    AND?: SchoolNurseWhereInput | SchoolNurseWhereInput[]
    OR?: SchoolNurseWhereInput[]
    NOT?: SchoolNurseWhereInput | SchoolNurseWhereInput[]
    specialization?: StringNullableFilter<"SchoolNurse"> | string | null
    experience?: IntNullableFilter<"SchoolNurse"> | number | null
    createdAt?: DateTimeFilter<"SchoolNurse"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolNurse"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    handledEvents?: MedicalEventListRelationFilter
    vaccinations?: VaccinationListRelationFilter
    medicalChecks?: MedicalCheckListRelationFilter
  }, "id" | "userId" | "licenseNumber">

  export type SchoolNurseOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolNurseCountOrderByAggregateInput
    _avg?: SchoolNurseAvgOrderByAggregateInput
    _max?: SchoolNurseMaxOrderByAggregateInput
    _min?: SchoolNurseMinOrderByAggregateInput
    _sum?: SchoolNurseSumOrderByAggregateInput
  }

  export type SchoolNurseScalarWhereWithAggregatesInput = {
    AND?: SchoolNurseScalarWhereWithAggregatesInput | SchoolNurseScalarWhereWithAggregatesInput[]
    OR?: SchoolNurseScalarWhereWithAggregatesInput[]
    NOT?: SchoolNurseScalarWhereWithAggregatesInput | SchoolNurseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolNurse"> | string
    userId?: StringWithAggregatesFilter<"SchoolNurse"> | string
    licenseNumber?: StringWithAggregatesFilter<"SchoolNurse"> | string
    specialization?: StringNullableWithAggregatesFilter<"SchoolNurse"> | string | null
    experience?: IntNullableWithAggregatesFilter<"SchoolNurse"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SchoolNurse"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolNurse"> | Date | string
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: StringFilter<"Manager"> | string
    userId?: StringFilter<"Manager"> | string
    department?: StringNullableFilter<"Manager"> | string | null
    position?: StringNullableFilter<"Manager"> | string | null
    createdAt?: DateTimeFilter<"Manager"> | Date | string
    updatedAt?: DateTimeFilter<"Manager"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    department?: StringNullableFilter<"Manager"> | string | null
    position?: StringNullableFilter<"Manager"> | string | null
    createdAt?: DateTimeFilter<"Manager"> | Date | string
    updatedAt?: DateTimeFilter<"Manager"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Manager"> | string
    userId?: StringWithAggregatesFilter<"Manager"> | string
    department?: StringNullableWithAggregatesFilter<"Manager"> | string | null
    position?: StringNullableWithAggregatesFilter<"Manager"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Manager"> | Date | string
  }

  export type AdminWhereInput = {
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    id?: StringFilter<"Admin"> | string
    userId?: StringFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type AdminOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type AdminWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: AdminWhereInput | AdminWhereInput[]
    OR?: AdminWhereInput[]
    NOT?: AdminWhereInput | AdminWhereInput[]
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeFilter<"Admin"> | Date | string
    updatedAt?: DateTimeFilter<"Admin"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "userId">

  export type AdminOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminCountOrderByAggregateInput
    _max?: AdminMaxOrderByAggregateInput
    _min?: AdminMinOrderByAggregateInput
  }

  export type AdminScalarWhereWithAggregatesInput = {
    AND?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    OR?: AdminScalarWhereWithAggregatesInput[]
    NOT?: AdminScalarWhereWithAggregatesInput | AdminScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Admin"> | string
    userId?: StringWithAggregatesFilter<"Admin"> | string
    permissions?: StringNullableListFilter<"Admin">
    createdAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Admin"> | Date | string
  }

  export type StudentParentWhereInput = {
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }

  export type StudentParentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
  }

  export type StudentParentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_parentId?: StudentParentStudentIdParentIdCompoundUniqueInput
    AND?: StudentParentWhereInput | StudentParentWhereInput[]
    OR?: StudentParentWhereInput[]
    NOT?: StudentParentWhereInput | StudentParentWhereInput[]
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
  }, "id" | "studentId_parentId">

  export type StudentParentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
    _count?: StudentParentCountOrderByAggregateInput
    _max?: StudentParentMaxOrderByAggregateInput
    _min?: StudentParentMinOrderByAggregateInput
  }

  export type StudentParentScalarWhereWithAggregatesInput = {
    AND?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    OR?: StudentParentScalarWhereWithAggregatesInput[]
    NOT?: StudentParentScalarWhereWithAggregatesInput | StudentParentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentParent"> | string
    studentId?: StringWithAggregatesFilter<"StudentParent"> | string
    parentId?: StringWithAggregatesFilter<"StudentParent"> | string
    relationship?: StringWithAggregatesFilter<"StudentParent"> | string
    isPrimary?: BoolWithAggregatesFilter<"StudentParent"> | boolean
  }

  export type HealthProfileWhereInput = {
    AND?: HealthProfileWhereInput | HealthProfileWhereInput[]
    OR?: HealthProfileWhereInput[]
    NOT?: HealthProfileWhereInput | HealthProfileWhereInput[]
    id?: StringFilter<"HealthProfile"> | string
    studentId?: StringFilter<"HealthProfile"> | string
    allergies?: StringNullableListFilter<"HealthProfile">
    chronicDiseases?: StringNullableListFilter<"HealthProfile">
    medications?: StringNullableListFilter<"HealthProfile">
    treatmentHistory?: StringNullableFilter<"HealthProfile"> | string | null
    vision?: StringNullableFilter<"HealthProfile"> | string | null
    hearing?: StringNullableFilter<"HealthProfile"> | string | null
    height?: FloatNullableFilter<"HealthProfile"> | number | null
    weight?: FloatNullableFilter<"HealthProfile"> | number | null
    notes?: StringNullableFilter<"HealthProfile"> | string | null
    createdAt?: DateTimeFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeFilter<"HealthProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }

  export type HealthProfileOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    medications?: SortOrder
    treatmentHistory?: SortOrder
    vision?: SortOrder
    hearing?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type HealthProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: HealthProfileWhereInput | HealthProfileWhereInput[]
    OR?: HealthProfileWhereInput[]
    NOT?: HealthProfileWhereInput | HealthProfileWhereInput[]
    allergies?: StringNullableListFilter<"HealthProfile">
    chronicDiseases?: StringNullableListFilter<"HealthProfile">
    medications?: StringNullableListFilter<"HealthProfile">
    treatmentHistory?: StringNullableFilter<"HealthProfile"> | string | null
    vision?: StringNullableFilter<"HealthProfile"> | string | null
    hearing?: StringNullableFilter<"HealthProfile"> | string | null
    height?: FloatNullableFilter<"HealthProfile"> | number | null
    weight?: FloatNullableFilter<"HealthProfile"> | number | null
    notes?: StringNullableFilter<"HealthProfile"> | string | null
    createdAt?: DateTimeFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeFilter<"HealthProfile"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
  }, "id" | "studentId">

  export type HealthProfileOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    medications?: SortOrder
    treatmentHistory?: SortOrder
    vision?: SortOrder
    hearing?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthProfileCountOrderByAggregateInput
    _avg?: HealthProfileAvgOrderByAggregateInput
    _max?: HealthProfileMaxOrderByAggregateInput
    _min?: HealthProfileMinOrderByAggregateInput
    _sum?: HealthProfileSumOrderByAggregateInput
  }

  export type HealthProfileScalarWhereWithAggregatesInput = {
    AND?: HealthProfileScalarWhereWithAggregatesInput | HealthProfileScalarWhereWithAggregatesInput[]
    OR?: HealthProfileScalarWhereWithAggregatesInput[]
    NOT?: HealthProfileScalarWhereWithAggregatesInput | HealthProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthProfile"> | string
    studentId?: StringWithAggregatesFilter<"HealthProfile"> | string
    allergies?: StringNullableListFilter<"HealthProfile">
    chronicDiseases?: StringNullableListFilter<"HealthProfile">
    medications?: StringNullableListFilter<"HealthProfile">
    treatmentHistory?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    vision?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    hearing?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    height?: FloatNullableWithAggregatesFilter<"HealthProfile"> | number | null
    weight?: FloatNullableWithAggregatesFilter<"HealthProfile"> | number | null
    notes?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthProfile"> | Date | string
  }

  export type MedicalEventWhereInput = {
    AND?: MedicalEventWhereInput | MedicalEventWhereInput[]
    OR?: MedicalEventWhereInput[]
    NOT?: MedicalEventWhereInput | MedicalEventWhereInput[]
    id?: StringFilter<"MedicalEvent"> | string
    studentId?: StringFilter<"MedicalEvent"> | string
    nurseId?: StringNullableFilter<"MedicalEvent"> | string | null
    createdById?: StringFilter<"MedicalEvent"> | string
    title?: StringFilter<"MedicalEvent"> | string
    description?: StringFilter<"MedicalEvent"> | string
    type?: EnumMedicalEventTypeFilter<"MedicalEvent"> | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFilter<"MedicalEvent"> | $Enums.MedicalEventStatus
    severity?: StringFilter<"MedicalEvent"> | string
    location?: StringNullableFilter<"MedicalEvent"> | string | null
    symptoms?: StringNullableListFilter<"MedicalEvent">
    treatment?: StringNullableFilter<"MedicalEvent"> | string | null
    outcome?: StringNullableFilter<"MedicalEvent"> | string | null
    occurredAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"MedicalEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
    createdBy?: XOR<UsersScalarRelationFilter, usersWhereInput>
    medicationsUsed?: MedicalEventMedicationListRelationFilter
    documents?: MedicalDocumentListRelationFilter
  }

  export type MedicalEventOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    nurseId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    location?: SortOrder
    symptoms?: SortOrder
    treatment?: SortOrder
    outcome?: SortOrder
    occurredAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    nurse?: SchoolNurseOrderByWithRelationInput
    createdBy?: usersOrderByWithRelationInput
    medicationsUsed?: MedicalEventMedicationOrderByRelationAggregateInput
    documents?: MedicalDocumentOrderByRelationAggregateInput
  }

  export type MedicalEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalEventWhereInput | MedicalEventWhereInput[]
    OR?: MedicalEventWhereInput[]
    NOT?: MedicalEventWhereInput | MedicalEventWhereInput[]
    studentId?: StringFilter<"MedicalEvent"> | string
    nurseId?: StringNullableFilter<"MedicalEvent"> | string | null
    createdById?: StringFilter<"MedicalEvent"> | string
    title?: StringFilter<"MedicalEvent"> | string
    description?: StringFilter<"MedicalEvent"> | string
    type?: EnumMedicalEventTypeFilter<"MedicalEvent"> | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFilter<"MedicalEvent"> | $Enums.MedicalEventStatus
    severity?: StringFilter<"MedicalEvent"> | string
    location?: StringNullableFilter<"MedicalEvent"> | string | null
    symptoms?: StringNullableListFilter<"MedicalEvent">
    treatment?: StringNullableFilter<"MedicalEvent"> | string | null
    outcome?: StringNullableFilter<"MedicalEvent"> | string | null
    occurredAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"MedicalEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
    createdBy?: XOR<UsersScalarRelationFilter, usersWhereInput>
    medicationsUsed?: MedicalEventMedicationListRelationFilter
    documents?: MedicalDocumentListRelationFilter
  }, "id">

  export type MedicalEventOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    nurseId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    location?: SortOrder
    symptoms?: SortOrder
    treatment?: SortOrder
    outcome?: SortOrder
    occurredAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalEventCountOrderByAggregateInput
    _max?: MedicalEventMaxOrderByAggregateInput
    _min?: MedicalEventMinOrderByAggregateInput
  }

  export type MedicalEventScalarWhereWithAggregatesInput = {
    AND?: MedicalEventScalarWhereWithAggregatesInput | MedicalEventScalarWhereWithAggregatesInput[]
    OR?: MedicalEventScalarWhereWithAggregatesInput[]
    NOT?: MedicalEventScalarWhereWithAggregatesInput | MedicalEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalEvent"> | string
    studentId?: StringWithAggregatesFilter<"MedicalEvent"> | string
    nurseId?: StringNullableWithAggregatesFilter<"MedicalEvent"> | string | null
    createdById?: StringWithAggregatesFilter<"MedicalEvent"> | string
    title?: StringWithAggregatesFilter<"MedicalEvent"> | string
    description?: StringWithAggregatesFilter<"MedicalEvent"> | string
    type?: EnumMedicalEventTypeWithAggregatesFilter<"MedicalEvent"> | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusWithAggregatesFilter<"MedicalEvent"> | $Enums.MedicalEventStatus
    severity?: StringWithAggregatesFilter<"MedicalEvent"> | string
    location?: StringNullableWithAggregatesFilter<"MedicalEvent"> | string | null
    symptoms?: StringNullableListFilter<"MedicalEvent">
    treatment?: StringNullableWithAggregatesFilter<"MedicalEvent"> | string | null
    outcome?: StringNullableWithAggregatesFilter<"MedicalEvent"> | string | null
    occurredAt?: DateTimeWithAggregatesFilter<"MedicalEvent"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"MedicalEvent"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalEvent"> | Date | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    name?: StringFilter<"Medication"> | string
    description?: StringNullableFilter<"Medication"> | string | null
    dosage?: StringFilter<"Medication"> | string
    unit?: StringFilter<"Medication"> | string
    manufacturer?: StringNullableFilter<"Medication"> | string | null
    expiryDate?: DateTimeNullableFilter<"Medication"> | Date | string | null
    stockQuantity?: IntFilter<"Medication"> | number
    minStockLevel?: IntFilter<"Medication"> | number
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    studentMedications?: StudentMedicationListRelationFilter
    medicalEventMedications?: MedicalEventMedicationListRelationFilter
    stockMovements?: StockMovementListRelationFilter
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dosage?: SortOrder
    unit?: SortOrder
    manufacturer?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    studentMedications?: StudentMedicationOrderByRelationAggregateInput
    medicalEventMedications?: MedicalEventMedicationOrderByRelationAggregateInput
    stockMovements?: StockMovementOrderByRelationAggregateInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    name?: StringFilter<"Medication"> | string
    description?: StringNullableFilter<"Medication"> | string | null
    dosage?: StringFilter<"Medication"> | string
    unit?: StringFilter<"Medication"> | string
    manufacturer?: StringNullableFilter<"Medication"> | string | null
    expiryDate?: DateTimeNullableFilter<"Medication"> | Date | string | null
    stockQuantity?: IntFilter<"Medication"> | number
    minStockLevel?: IntFilter<"Medication"> | number
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    studentMedications?: StudentMedicationListRelationFilter
    medicalEventMedications?: MedicalEventMedicationListRelationFilter
    stockMovements?: StockMovementListRelationFilter
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dosage?: SortOrder
    unit?: SortOrder
    manufacturer?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _avg?: MedicationAvgOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
    _sum?: MedicationSumOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    name?: StringWithAggregatesFilter<"Medication"> | string
    description?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    dosage?: StringWithAggregatesFilter<"Medication"> | string
    unit?: StringWithAggregatesFilter<"Medication"> | string
    manufacturer?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    stockQuantity?: IntWithAggregatesFilter<"Medication"> | number
    minStockLevel?: IntWithAggregatesFilter<"Medication"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
  }

  export type StudentMedicationWhereInput = {
    AND?: StudentMedicationWhereInput | StudentMedicationWhereInput[]
    OR?: StudentMedicationWhereInput[]
    NOT?: StudentMedicationWhereInput | StudentMedicationWhereInput[]
    id?: StringFilter<"StudentMedication"> | string
    studentId?: StringFilter<"StudentMedication"> | string
    parentId?: StringFilter<"StudentMedication"> | string
    medicationId?: StringFilter<"StudentMedication"> | string
    dosage?: StringFilter<"StudentMedication"> | string
    frequency?: StringFilter<"StudentMedication"> | string
    duration?: StringNullableFilter<"StudentMedication"> | string | null
    instructions?: StringNullableFilter<"StudentMedication"> | string | null
    status?: EnumMedicationStatusFilter<"StudentMedication"> | $Enums.MedicationStatus
    startDate?: DateTimeFilter<"StudentMedication"> | Date | string
    endDate?: DateTimeNullableFilter<"StudentMedication"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentMedication"> | Date | string
    updatedAt?: DateTimeFilter<"StudentMedication"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }

  export type StudentMedicationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    medicationId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    parent?: ParentOrderByWithRelationInput
    medication?: MedicationOrderByWithRelationInput
  }

  export type StudentMedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentMedicationWhereInput | StudentMedicationWhereInput[]
    OR?: StudentMedicationWhereInput[]
    NOT?: StudentMedicationWhereInput | StudentMedicationWhereInput[]
    studentId?: StringFilter<"StudentMedication"> | string
    parentId?: StringFilter<"StudentMedication"> | string
    medicationId?: StringFilter<"StudentMedication"> | string
    dosage?: StringFilter<"StudentMedication"> | string
    frequency?: StringFilter<"StudentMedication"> | string
    duration?: StringNullableFilter<"StudentMedication"> | string | null
    instructions?: StringNullableFilter<"StudentMedication"> | string | null
    status?: EnumMedicationStatusFilter<"StudentMedication"> | $Enums.MedicationStatus
    startDate?: DateTimeFilter<"StudentMedication"> | Date | string
    endDate?: DateTimeNullableFilter<"StudentMedication"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentMedication"> | Date | string
    updatedAt?: DateTimeFilter<"StudentMedication"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    parent?: XOR<ParentScalarRelationFilter, ParentWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }, "id">

  export type StudentMedicationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    medicationId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentMedicationCountOrderByAggregateInput
    _max?: StudentMedicationMaxOrderByAggregateInput
    _min?: StudentMedicationMinOrderByAggregateInput
  }

  export type StudentMedicationScalarWhereWithAggregatesInput = {
    AND?: StudentMedicationScalarWhereWithAggregatesInput | StudentMedicationScalarWhereWithAggregatesInput[]
    OR?: StudentMedicationScalarWhereWithAggregatesInput[]
    NOT?: StudentMedicationScalarWhereWithAggregatesInput | StudentMedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentMedication"> | string
    studentId?: StringWithAggregatesFilter<"StudentMedication"> | string
    parentId?: StringWithAggregatesFilter<"StudentMedication"> | string
    medicationId?: StringWithAggregatesFilter<"StudentMedication"> | string
    dosage?: StringWithAggregatesFilter<"StudentMedication"> | string
    frequency?: StringWithAggregatesFilter<"StudentMedication"> | string
    duration?: StringNullableWithAggregatesFilter<"StudentMedication"> | string | null
    instructions?: StringNullableWithAggregatesFilter<"StudentMedication"> | string | null
    status?: EnumMedicationStatusWithAggregatesFilter<"StudentMedication"> | $Enums.MedicationStatus
    startDate?: DateTimeWithAggregatesFilter<"StudentMedication"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"StudentMedication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentMedication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentMedication"> | Date | string
  }

  export type MedicalEventMedicationWhereInput = {
    AND?: MedicalEventMedicationWhereInput | MedicalEventMedicationWhereInput[]
    OR?: MedicalEventMedicationWhereInput[]
    NOT?: MedicalEventMedicationWhereInput | MedicalEventMedicationWhereInput[]
    id?: StringFilter<"MedicalEventMedication"> | string
    medicalEventId?: StringFilter<"MedicalEventMedication"> | string
    medicationId?: StringFilter<"MedicalEventMedication"> | string
    quantityUsed?: IntFilter<"MedicalEventMedication"> | number
    dosageGiven?: StringFilter<"MedicalEventMedication"> | string
    administeredAt?: DateTimeFilter<"MedicalEventMedication"> | Date | string
    notes?: StringNullableFilter<"MedicalEventMedication"> | string | null
    medicalEvent?: XOR<MedicalEventScalarRelationFilter, MedicalEventWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }

  export type MedicalEventMedicationOrderByWithRelationInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    medicationId?: SortOrder
    quantityUsed?: SortOrder
    dosageGiven?: SortOrder
    administeredAt?: SortOrder
    notes?: SortOrder
    medicalEvent?: MedicalEventOrderByWithRelationInput
    medication?: MedicationOrderByWithRelationInput
  }

  export type MedicalEventMedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalEventMedicationWhereInput | MedicalEventMedicationWhereInput[]
    OR?: MedicalEventMedicationWhereInput[]
    NOT?: MedicalEventMedicationWhereInput | MedicalEventMedicationWhereInput[]
    medicalEventId?: StringFilter<"MedicalEventMedication"> | string
    medicationId?: StringFilter<"MedicalEventMedication"> | string
    quantityUsed?: IntFilter<"MedicalEventMedication"> | number
    dosageGiven?: StringFilter<"MedicalEventMedication"> | string
    administeredAt?: DateTimeFilter<"MedicalEventMedication"> | Date | string
    notes?: StringNullableFilter<"MedicalEventMedication"> | string | null
    medicalEvent?: XOR<MedicalEventScalarRelationFilter, MedicalEventWhereInput>
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }, "id">

  export type MedicalEventMedicationOrderByWithAggregationInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    medicationId?: SortOrder
    quantityUsed?: SortOrder
    dosageGiven?: SortOrder
    administeredAt?: SortOrder
    notes?: SortOrder
    _count?: MedicalEventMedicationCountOrderByAggregateInput
    _avg?: MedicalEventMedicationAvgOrderByAggregateInput
    _max?: MedicalEventMedicationMaxOrderByAggregateInput
    _min?: MedicalEventMedicationMinOrderByAggregateInput
    _sum?: MedicalEventMedicationSumOrderByAggregateInput
  }

  export type MedicalEventMedicationScalarWhereWithAggregatesInput = {
    AND?: MedicalEventMedicationScalarWhereWithAggregatesInput | MedicalEventMedicationScalarWhereWithAggregatesInput[]
    OR?: MedicalEventMedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicalEventMedicationScalarWhereWithAggregatesInput | MedicalEventMedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalEventMedication"> | string
    medicalEventId?: StringWithAggregatesFilter<"MedicalEventMedication"> | string
    medicationId?: StringWithAggregatesFilter<"MedicalEventMedication"> | string
    quantityUsed?: IntWithAggregatesFilter<"MedicalEventMedication"> | number
    dosageGiven?: StringWithAggregatesFilter<"MedicalEventMedication"> | string
    administeredAt?: DateTimeWithAggregatesFilter<"MedicalEventMedication"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"MedicalEventMedication"> | string | null
  }

  export type StockMovementWhereInput = {
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    medicationId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }

  export type StockMovementOrderByWithRelationInput = {
    id?: SortOrder
    medicationId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    medication?: MedicationOrderByWithRelationInput
  }

  export type StockMovementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StockMovementWhereInput | StockMovementWhereInput[]
    OR?: StockMovementWhereInput[]
    NOT?: StockMovementWhereInput | StockMovementWhereInput[]
    medicationId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
    medication?: XOR<MedicationScalarRelationFilter, MedicationWhereInput>
  }, "id">

  export type StockMovementOrderByWithAggregationInput = {
    id?: SortOrder
    medicationId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
    _count?: StockMovementCountOrderByAggregateInput
    _avg?: StockMovementAvgOrderByAggregateInput
    _max?: StockMovementMaxOrderByAggregateInput
    _min?: StockMovementMinOrderByAggregateInput
    _sum?: StockMovementSumOrderByAggregateInput
  }

  export type StockMovementScalarWhereWithAggregatesInput = {
    AND?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    OR?: StockMovementScalarWhereWithAggregatesInput[]
    NOT?: StockMovementScalarWhereWithAggregatesInput | StockMovementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StockMovement"> | string
    medicationId?: StringWithAggregatesFilter<"StockMovement"> | string
    type?: StringWithAggregatesFilter<"StockMovement"> | string
    quantity?: IntWithAggregatesFilter<"StockMovement"> | number
    reason?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    reference?: StringNullableWithAggregatesFilter<"StockMovement"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StockMovement"> | Date | string
  }

  export type VaccinationCampaignWhereInput = {
    AND?: VaccinationCampaignWhereInput | VaccinationCampaignWhereInput[]
    OR?: VaccinationCampaignWhereInput[]
    NOT?: VaccinationCampaignWhereInput | VaccinationCampaignWhereInput[]
    id?: StringFilter<"VaccinationCampaign"> | string
    name?: StringFilter<"VaccinationCampaign"> | string
    description?: StringNullableFilter<"VaccinationCampaign"> | string | null
    vaccineName?: StringFilter<"VaccinationCampaign"> | string
    targetGrades?: StringNullableListFilter<"VaccinationCampaign">
    scheduledDate?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    deadline?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    isActive?: BoolFilter<"VaccinationCampaign"> | boolean
    createdAt?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    vaccinations?: VaccinationListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type VaccinationCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    vaccineName?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vaccinations?: VaccinationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type VaccinationCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccinationCampaignWhereInput | VaccinationCampaignWhereInput[]
    OR?: VaccinationCampaignWhereInput[]
    NOT?: VaccinationCampaignWhereInput | VaccinationCampaignWhereInput[]
    name?: StringFilter<"VaccinationCampaign"> | string
    description?: StringNullableFilter<"VaccinationCampaign"> | string | null
    vaccineName?: StringFilter<"VaccinationCampaign"> | string
    targetGrades?: StringNullableListFilter<"VaccinationCampaign">
    scheduledDate?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    deadline?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    isActive?: BoolFilter<"VaccinationCampaign"> | boolean
    createdAt?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"VaccinationCampaign"> | Date | string
    vaccinations?: VaccinationListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type VaccinationCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    vaccineName?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VaccinationCampaignCountOrderByAggregateInput
    _max?: VaccinationCampaignMaxOrderByAggregateInput
    _min?: VaccinationCampaignMinOrderByAggregateInput
  }

  export type VaccinationCampaignScalarWhereWithAggregatesInput = {
    AND?: VaccinationCampaignScalarWhereWithAggregatesInput | VaccinationCampaignScalarWhereWithAggregatesInput[]
    OR?: VaccinationCampaignScalarWhereWithAggregatesInput[]
    NOT?: VaccinationCampaignScalarWhereWithAggregatesInput | VaccinationCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VaccinationCampaign"> | string
    name?: StringWithAggregatesFilter<"VaccinationCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"VaccinationCampaign"> | string | null
    vaccineName?: StringWithAggregatesFilter<"VaccinationCampaign"> | string
    targetGrades?: StringNullableListFilter<"VaccinationCampaign">
    scheduledDate?: DateTimeWithAggregatesFilter<"VaccinationCampaign"> | Date | string
    deadline?: DateTimeWithAggregatesFilter<"VaccinationCampaign"> | Date | string
    isActive?: BoolWithAggregatesFilter<"VaccinationCampaign"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"VaccinationCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VaccinationCampaign"> | Date | string
  }

  export type VaccinationWhereInput = {
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    id?: StringFilter<"Vaccination"> | string
    studentId?: StringFilter<"Vaccination"> | string
    campaignId?: StringFilter<"Vaccination"> | string
    nurseId?: StringNullableFilter<"Vaccination"> | string | null
    status?: EnumVaccinationStatusFilter<"Vaccination"> | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFilter<"Vaccination"> | Date | string
    administeredDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    dose?: StringNullableFilter<"Vaccination"> | string | null
    batch?: StringNullableFilter<"Vaccination"> | string | null
    sideEffects?: StringNullableFilter<"Vaccination"> | string | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    parentConsent?: BoolFilter<"Vaccination"> | boolean
    consentDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccination"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    campaign?: XOR<VaccinationCampaignScalarRelationFilter, VaccinationCampaignWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
  }

  export type VaccinationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    administeredDate?: SortOrder
    dose?: SortOrder
    batch?: SortOrder
    sideEffects?: SortOrder
    notes?: SortOrder
    parentConsent?: SortOrder
    consentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    campaign?: VaccinationCampaignOrderByWithRelationInput
    nurse?: SchoolNurseOrderByWithRelationInput
  }

  export type VaccinationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VaccinationWhereInput | VaccinationWhereInput[]
    OR?: VaccinationWhereInput[]
    NOT?: VaccinationWhereInput | VaccinationWhereInput[]
    studentId?: StringFilter<"Vaccination"> | string
    campaignId?: StringFilter<"Vaccination"> | string
    nurseId?: StringNullableFilter<"Vaccination"> | string | null
    status?: EnumVaccinationStatusFilter<"Vaccination"> | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFilter<"Vaccination"> | Date | string
    administeredDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    dose?: StringNullableFilter<"Vaccination"> | string | null
    batch?: StringNullableFilter<"Vaccination"> | string | null
    sideEffects?: StringNullableFilter<"Vaccination"> | string | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    parentConsent?: BoolFilter<"Vaccination"> | boolean
    consentDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccination"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    campaign?: XOR<VaccinationCampaignScalarRelationFilter, VaccinationCampaignWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
  }, "id">

  export type VaccinationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    administeredDate?: SortOrder
    dose?: SortOrder
    batch?: SortOrder
    sideEffects?: SortOrder
    notes?: SortOrder
    parentConsent?: SortOrder
    consentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VaccinationCountOrderByAggregateInput
    _max?: VaccinationMaxOrderByAggregateInput
    _min?: VaccinationMinOrderByAggregateInput
  }

  export type VaccinationScalarWhereWithAggregatesInput = {
    AND?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    OR?: VaccinationScalarWhereWithAggregatesInput[]
    NOT?: VaccinationScalarWhereWithAggregatesInput | VaccinationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vaccination"> | string
    studentId?: StringWithAggregatesFilter<"Vaccination"> | string
    campaignId?: StringWithAggregatesFilter<"Vaccination"> | string
    nurseId?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    status?: EnumVaccinationStatusWithAggregatesFilter<"Vaccination"> | $Enums.VaccinationStatus
    scheduledDate?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
    administeredDate?: DateTimeNullableWithAggregatesFilter<"Vaccination"> | Date | string | null
    dose?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    batch?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    sideEffects?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Vaccination"> | string | null
    parentConsent?: BoolWithAggregatesFilter<"Vaccination"> | boolean
    consentDate?: DateTimeNullableWithAggregatesFilter<"Vaccination"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vaccination"> | Date | string
  }

  export type MedicalCheckCampaignWhereInput = {
    AND?: MedicalCheckCampaignWhereInput | MedicalCheckCampaignWhereInput[]
    OR?: MedicalCheckCampaignWhereInput[]
    NOT?: MedicalCheckCampaignWhereInput | MedicalCheckCampaignWhereInput[]
    id?: StringFilter<"MedicalCheckCampaign"> | string
    name?: StringFilter<"MedicalCheckCampaign"> | string
    description?: StringNullableFilter<"MedicalCheckCampaign"> | string | null
    checkTypes?: StringNullableListFilter<"MedicalCheckCampaign">
    targetGrades?: StringNullableListFilter<"MedicalCheckCampaign">
    scheduledDate?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    deadline?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    isActive?: BoolFilter<"MedicalCheckCampaign"> | boolean
    createdAt?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    medicalChecks?: MedicalCheckListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type MedicalCheckCampaignOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    checkTypes?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    medicalChecks?: MedicalCheckOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type MedicalCheckCampaignWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalCheckCampaignWhereInput | MedicalCheckCampaignWhereInput[]
    OR?: MedicalCheckCampaignWhereInput[]
    NOT?: MedicalCheckCampaignWhereInput | MedicalCheckCampaignWhereInput[]
    name?: StringFilter<"MedicalCheckCampaign"> | string
    description?: StringNullableFilter<"MedicalCheckCampaign"> | string | null
    checkTypes?: StringNullableListFilter<"MedicalCheckCampaign">
    targetGrades?: StringNullableListFilter<"MedicalCheckCampaign">
    scheduledDate?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    deadline?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    isActive?: BoolFilter<"MedicalCheckCampaign"> | boolean
    createdAt?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalCheckCampaign"> | Date | string
    medicalChecks?: MedicalCheckListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type MedicalCheckCampaignOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    checkTypes?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalCheckCampaignCountOrderByAggregateInput
    _max?: MedicalCheckCampaignMaxOrderByAggregateInput
    _min?: MedicalCheckCampaignMinOrderByAggregateInput
  }

  export type MedicalCheckCampaignScalarWhereWithAggregatesInput = {
    AND?: MedicalCheckCampaignScalarWhereWithAggregatesInput | MedicalCheckCampaignScalarWhereWithAggregatesInput[]
    OR?: MedicalCheckCampaignScalarWhereWithAggregatesInput[]
    NOT?: MedicalCheckCampaignScalarWhereWithAggregatesInput | MedicalCheckCampaignScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalCheckCampaign"> | string
    name?: StringWithAggregatesFilter<"MedicalCheckCampaign"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalCheckCampaign"> | string | null
    checkTypes?: StringNullableListFilter<"MedicalCheckCampaign">
    targetGrades?: StringNullableListFilter<"MedicalCheckCampaign">
    scheduledDate?: DateTimeWithAggregatesFilter<"MedicalCheckCampaign"> | Date | string
    deadline?: DateTimeWithAggregatesFilter<"MedicalCheckCampaign"> | Date | string
    isActive?: BoolWithAggregatesFilter<"MedicalCheckCampaign"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MedicalCheckCampaign"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalCheckCampaign"> | Date | string
  }

  export type MedicalCheckWhereInput = {
    AND?: MedicalCheckWhereInput | MedicalCheckWhereInput[]
    OR?: MedicalCheckWhereInput[]
    NOT?: MedicalCheckWhereInput | MedicalCheckWhereInput[]
    id?: StringFilter<"MedicalCheck"> | string
    studentId?: StringFilter<"MedicalCheck"> | string
    campaignId?: StringFilter<"MedicalCheck"> | string
    nurseId?: StringNullableFilter<"MedicalCheck"> | string | null
    status?: EnumMedicalCheckStatusFilter<"MedicalCheck"> | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFilter<"MedicalCheck"> | Date | string
    completedDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    visionResult?: StringNullableFilter<"MedicalCheck"> | string | null
    hearingResult?: StringNullableFilter<"MedicalCheck"> | string | null
    dentalResult?: StringNullableFilter<"MedicalCheck"> | string | null
    heightWeight?: JsonNullableFilter<"MedicalCheck">
    generalHealth?: StringNullableFilter<"MedicalCheck"> | string | null
    recommendations?: StringNullableFilter<"MedicalCheck"> | string | null
    requiresFollowUp?: BoolFilter<"MedicalCheck"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    notes?: StringNullableFilter<"MedicalCheck"> | string | null
    parentNotified?: BoolFilter<"MedicalCheck"> | boolean
    parentResponse?: StringNullableFilter<"MedicalCheck"> | string | null
    createdAt?: DateTimeFilter<"MedicalCheck"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalCheck"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    campaign?: XOR<MedicalCheckCampaignScalarRelationFilter, MedicalCheckCampaignWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
  }

  export type MedicalCheckOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    visionResult?: SortOrder
    hearingResult?: SortOrder
    dentalResult?: SortOrder
    heightWeight?: SortOrder
    generalHealth?: SortOrder
    recommendations?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    parentResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    campaign?: MedicalCheckCampaignOrderByWithRelationInput
    nurse?: SchoolNurseOrderByWithRelationInput
  }

  export type MedicalCheckWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalCheckWhereInput | MedicalCheckWhereInput[]
    OR?: MedicalCheckWhereInput[]
    NOT?: MedicalCheckWhereInput | MedicalCheckWhereInput[]
    studentId?: StringFilter<"MedicalCheck"> | string
    campaignId?: StringFilter<"MedicalCheck"> | string
    nurseId?: StringNullableFilter<"MedicalCheck"> | string | null
    status?: EnumMedicalCheckStatusFilter<"MedicalCheck"> | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFilter<"MedicalCheck"> | Date | string
    completedDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    visionResult?: StringNullableFilter<"MedicalCheck"> | string | null
    hearingResult?: StringNullableFilter<"MedicalCheck"> | string | null
    dentalResult?: StringNullableFilter<"MedicalCheck"> | string | null
    heightWeight?: JsonNullableFilter<"MedicalCheck">
    generalHealth?: StringNullableFilter<"MedicalCheck"> | string | null
    recommendations?: StringNullableFilter<"MedicalCheck"> | string | null
    requiresFollowUp?: BoolFilter<"MedicalCheck"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    notes?: StringNullableFilter<"MedicalCheck"> | string | null
    parentNotified?: BoolFilter<"MedicalCheck"> | boolean
    parentResponse?: StringNullableFilter<"MedicalCheck"> | string | null
    createdAt?: DateTimeFilter<"MedicalCheck"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalCheck"> | Date | string
    student?: XOR<StudentScalarRelationFilter, StudentWhereInput>
    campaign?: XOR<MedicalCheckCampaignScalarRelationFilter, MedicalCheckCampaignWhereInput>
    nurse?: XOR<SchoolNurseNullableScalarRelationFilter, SchoolNurseWhereInput> | null
  }, "id">

  export type MedicalCheckOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    visionResult?: SortOrder
    hearingResult?: SortOrder
    dentalResult?: SortOrder
    heightWeight?: SortOrder
    generalHealth?: SortOrder
    recommendations?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    parentResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicalCheckCountOrderByAggregateInput
    _max?: MedicalCheckMaxOrderByAggregateInput
    _min?: MedicalCheckMinOrderByAggregateInput
  }

  export type MedicalCheckScalarWhereWithAggregatesInput = {
    AND?: MedicalCheckScalarWhereWithAggregatesInput | MedicalCheckScalarWhereWithAggregatesInput[]
    OR?: MedicalCheckScalarWhereWithAggregatesInput[]
    NOT?: MedicalCheckScalarWhereWithAggregatesInput | MedicalCheckScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalCheck"> | string
    studentId?: StringWithAggregatesFilter<"MedicalCheck"> | string
    campaignId?: StringWithAggregatesFilter<"MedicalCheck"> | string
    nurseId?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    status?: EnumMedicalCheckStatusWithAggregatesFilter<"MedicalCheck"> | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeWithAggregatesFilter<"MedicalCheck"> | Date | string
    completedDate?: DateTimeNullableWithAggregatesFilter<"MedicalCheck"> | Date | string | null
    visionResult?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    hearingResult?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    dentalResult?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    heightWeight?: JsonNullableWithAggregatesFilter<"MedicalCheck">
    generalHealth?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    requiresFollowUp?: BoolWithAggregatesFilter<"MedicalCheck"> | boolean
    followUpDate?: DateTimeNullableWithAggregatesFilter<"MedicalCheck"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    parentNotified?: BoolWithAggregatesFilter<"MedicalCheck"> | boolean
    parentResponse?: StringNullableWithAggregatesFilter<"MedicalCheck"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicalCheck"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicalCheck"> | Date | string
  }

  export type MedicalDocumentWhereInput = {
    AND?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    OR?: MedicalDocumentWhereInput[]
    NOT?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    id?: StringFilter<"MedicalDocument"> | string
    medicalEventId?: StringNullableFilter<"MedicalDocument"> | string | null
    title?: StringFilter<"MedicalDocument"> | string
    description?: StringNullableFilter<"MedicalDocument"> | string | null
    fileName?: StringFilter<"MedicalDocument"> | string
    filePath?: StringFilter<"MedicalDocument"> | string
    fileSize?: IntFilter<"MedicalDocument"> | number
    mimeType?: StringFilter<"MedicalDocument"> | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    medicalEvent?: XOR<MedicalEventNullableScalarRelationFilter, MedicalEventWhereInput> | null
  }

  export type MedicalDocumentOrderByWithRelationInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    medicalEvent?: MedicalEventOrderByWithRelationInput
  }

  export type MedicalDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    OR?: MedicalDocumentWhereInput[]
    NOT?: MedicalDocumentWhereInput | MedicalDocumentWhereInput[]
    medicalEventId?: StringNullableFilter<"MedicalDocument"> | string | null
    title?: StringFilter<"MedicalDocument"> | string
    description?: StringNullableFilter<"MedicalDocument"> | string | null
    fileName?: StringFilter<"MedicalDocument"> | string
    filePath?: StringFilter<"MedicalDocument"> | string
    fileSize?: IntFilter<"MedicalDocument"> | number
    mimeType?: StringFilter<"MedicalDocument"> | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
    medicalEvent?: XOR<MedicalEventNullableScalarRelationFilter, MedicalEventWhereInput> | null
  }, "id">

  export type MedicalDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    _count?: MedicalDocumentCountOrderByAggregateInput
    _avg?: MedicalDocumentAvgOrderByAggregateInput
    _max?: MedicalDocumentMaxOrderByAggregateInput
    _min?: MedicalDocumentMinOrderByAggregateInput
    _sum?: MedicalDocumentSumOrderByAggregateInput
  }

  export type MedicalDocumentScalarWhereWithAggregatesInput = {
    AND?: MedicalDocumentScalarWhereWithAggregatesInput | MedicalDocumentScalarWhereWithAggregatesInput[]
    OR?: MedicalDocumentScalarWhereWithAggregatesInput[]
    NOT?: MedicalDocumentScalarWhereWithAggregatesInput | MedicalDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicalDocument"> | string
    medicalEventId?: StringNullableWithAggregatesFilter<"MedicalDocument"> | string | null
    title?: StringWithAggregatesFilter<"MedicalDocument"> | string
    description?: StringNullableWithAggregatesFilter<"MedicalDocument"> | string | null
    fileName?: StringWithAggregatesFilter<"MedicalDocument"> | string
    filePath?: StringWithAggregatesFilter<"MedicalDocument"> | string
    fileSize?: IntWithAggregatesFilter<"MedicalDocument"> | number
    mimeType?: StringWithAggregatesFilter<"MedicalDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicalDocument"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImage?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    isPublished?: BoolFilter<"Post"> | boolean
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: usersOrderByWithRelationInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    authorId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImage?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    isPublished?: BoolFilter<"Post"> | boolean
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Post"> | string
    authorId?: StringWithAggregatesFilter<"Post"> | string
    title?: StringWithAggregatesFilter<"Post"> | string
    content?: StringWithAggregatesFilter<"Post"> | string
    excerpt?: StringNullableWithAggregatesFilter<"Post"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Post"> | string | null
    category?: StringNullableWithAggregatesFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    isPublished?: BoolWithAggregatesFilter<"Post"> | boolean
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Post"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    vaccinationCampaignId?: StringNullableFilter<"Notification"> | string | null
    medicalCheckCampaignId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    vaccinationCampaign?: XOR<VaccinationCampaignNullableScalarRelationFilter, VaccinationCampaignWhereInput> | null
    medicalCheckCampaign?: XOR<MedicalCheckCampaignNullableScalarRelationFilter, MedicalCheckCampaignWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    vaccinationCampaignId?: SortOrder
    medicalCheckCampaignId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
    vaccinationCampaign?: VaccinationCampaignOrderByWithRelationInput
    medicalCheckCampaign?: MedicalCheckCampaignOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    vaccinationCampaignId?: StringNullableFilter<"Notification"> | string | null
    medicalCheckCampaignId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    vaccinationCampaign?: XOR<VaccinationCampaignNullableScalarRelationFilter, VaccinationCampaignWhereInput> | null
    medicalCheckCampaign?: XOR<MedicalCheckCampaignNullableScalarRelationFilter, MedicalCheckCampaignWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    vaccinationCampaignId?: SortOrder
    medicalCheckCampaignId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    vaccinationCampaignId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    medicalCheckCampaignId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type SchoolInfoWhereInput = {
    AND?: SchoolInfoWhereInput | SchoolInfoWhereInput[]
    OR?: SchoolInfoWhereInput[]
    NOT?: SchoolInfoWhereInput | SchoolInfoWhereInput[]
    id?: StringFilter<"SchoolInfo"> | string
    name?: StringFilter<"SchoolInfo"> | string
    address?: StringFilter<"SchoolInfo"> | string
    phone?: StringNullableFilter<"SchoolInfo"> | string | null
    email?: StringNullableFilter<"SchoolInfo"> | string | null
    website?: StringNullableFilter<"SchoolInfo"> | string | null
    logo?: StringNullableFilter<"SchoolInfo"> | string | null
    description?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptHead?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptPhone?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptEmail?: StringNullableFilter<"SchoolInfo"> | string | null
    createdAt?: DateTimeFilter<"SchoolInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolInfo"> | Date | string
  }

  export type SchoolInfoOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    healthDeptHead?: SortOrder
    healthDeptPhone?: SortOrder
    healthDeptEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolInfoWhereInput | SchoolInfoWhereInput[]
    OR?: SchoolInfoWhereInput[]
    NOT?: SchoolInfoWhereInput | SchoolInfoWhereInput[]
    name?: StringFilter<"SchoolInfo"> | string
    address?: StringFilter<"SchoolInfo"> | string
    phone?: StringNullableFilter<"SchoolInfo"> | string | null
    email?: StringNullableFilter<"SchoolInfo"> | string | null
    website?: StringNullableFilter<"SchoolInfo"> | string | null
    logo?: StringNullableFilter<"SchoolInfo"> | string | null
    description?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptHead?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptPhone?: StringNullableFilter<"SchoolInfo"> | string | null
    healthDeptEmail?: StringNullableFilter<"SchoolInfo"> | string | null
    createdAt?: DateTimeFilter<"SchoolInfo"> | Date | string
    updatedAt?: DateTimeFilter<"SchoolInfo"> | Date | string
  }, "id">

  export type SchoolInfoOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    healthDeptHead?: SortOrder
    healthDeptPhone?: SortOrder
    healthDeptEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SchoolInfoCountOrderByAggregateInput
    _max?: SchoolInfoMaxOrderByAggregateInput
    _min?: SchoolInfoMinOrderByAggregateInput
  }

  export type SchoolInfoScalarWhereWithAggregatesInput = {
    AND?: SchoolInfoScalarWhereWithAggregatesInput | SchoolInfoScalarWhereWithAggregatesInput[]
    OR?: SchoolInfoScalarWhereWithAggregatesInput[]
    NOT?: SchoolInfoScalarWhereWithAggregatesInput | SchoolInfoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolInfo"> | string
    name?: StringWithAggregatesFilter<"SchoolInfo"> | string
    address?: StringWithAggregatesFilter<"SchoolInfo"> | string
    phone?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    email?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    website?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    logo?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    description?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    healthDeptHead?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    healthDeptPhone?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    healthDeptEmail?: StringNullableWithAggregatesFilter<"SchoolInfo"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SchoolInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SchoolInfo"> | Date | string
  }

  export type usersCreateInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentCreateInput = {
    id?: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutParentProfileInput
    children?: StudentParentCreateNestedManyWithoutParentInput
    medications?: StudentMedicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateInput = {
    id?: string
    userId: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentUpdateInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutParentProfileNestedInput
    children?: StudentParentUpdateManyWithoutParentNestedInput
    medications?: StudentMedicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type ParentCreateManyInput = {
    id?: string
    userId: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParentUpdateManyMutationInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolNurseCreateInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutNurseProfileInput
    handledEvents?: MedicalEventCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUncheckedCreateInput = {
    id?: string
    userId: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    handledEvents?: MedicalEventUncheckedCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUpdateInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNurseProfileNestedInput
    handledEvents?: MedicalEventUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledEvents?: MedicalEventUncheckedUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseCreateManyInput = {
    id?: string
    userId: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolNurseUpdateManyMutationInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolNurseUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerCreateInput = {
    id?: string
    department?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutManagerProfileInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: string
    userId: string
    department?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUpdateInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutManagerProfileNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerCreateManyInput = {
    id?: string
    userId: string
    department?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUpdateManyMutationInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutAdminProfileInput
  }

  export type AdminUncheckedCreateInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateInput = {
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAdminProfileNestedInput
  }

  export type AdminUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminCreateManyInput = {
    id?: string
    userId: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUpdateManyMutationInput = {
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateInput = {
    id?: string
    relationship: string
    isPrimary?: boolean
    student: StudentCreateNestedOneWithoutParentsInput
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type StudentParentUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type StudentParentUpdateInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type StudentParentUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type StudentParentUpdateManyMutationInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HealthProfileCreateInput = {
    id?: string
    allergies?: HealthProfileCreateallergiesInput | string[]
    chronicDiseases?: HealthProfileCreatechronicDiseasesInput | string[]
    medications?: HealthProfileCreatemedicationsInput | string[]
    treatmentHistory?: string | null
    vision?: string | null
    hearing?: string | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutHealthProfileInput
  }

  export type HealthProfileUncheckedCreateInput = {
    id?: string
    studentId: string
    allergies?: HealthProfileCreateallergiesInput | string[]
    chronicDiseases?: HealthProfileCreatechronicDiseasesInput | string[]
    medications?: HealthProfileCreatemedicationsInput | string[]
    treatmentHistory?: string | null
    vision?: string | null
    hearing?: string | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUpdateInput = {
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutHealthProfileNestedInput
  }

  export type HealthProfileUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileCreateManyInput = {
    id?: string
    studentId: string
    allergies?: HealthProfileCreateallergiesInput | string[]
    chronicDiseases?: HealthProfileCreatechronicDiseasesInput | string[]
    medications?: HealthProfileCreatemedicationsInput | string[]
    treatmentHistory?: string | null
    vision?: string | null
    hearing?: string | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUpdateManyMutationInput = {
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventCreateInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalEventsInput
    nurse?: SchoolNurseCreateNestedOneWithoutHandledEventsInput
    createdBy: usersCreateNestedOneWithoutCreatedEventsInput
    medicationsUsed?: MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalEventsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutHandledEventsNestedInput
    createdBy?: usersUpdateOneRequiredWithoutCreatedEventsNestedInput
    medicationsUsed?: MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventCreateManyInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalEventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationCreateNestedManyWithoutMedicationInput
    medicalEventMedications?: MedicalEventMedicationCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationUncheckedCreateNestedManyWithoutMedicationInput
    medicalEventMedications?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUpdateManyWithoutMedicationNestedInput
    medicalEventMedications?: MedicalEventMedicationUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUncheckedUpdateManyWithoutMedicationNestedInput
    medicalEventMedications?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationCreateInput = {
    id?: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicationsInput
    parent: ParentCreateNestedOneWithoutMedicationsInput
    medication: MedicationCreateNestedOneWithoutStudentMedicationsInput
  }

  export type StudentMedicationUncheckedCreateInput = {
    id?: string
    studentId: string
    parentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationUpdateInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicationsNestedInput
    parent?: ParentUpdateOneRequiredWithoutMedicationsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutStudentMedicationsNestedInput
  }

  export type StudentMedicationUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationCreateManyInput = {
    id?: string
    studentId: string
    parentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationUpdateManyMutationInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventMedicationCreateInput = {
    id?: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
    medicalEvent: MedicalEventCreateNestedOneWithoutMedicationsUsedInput
    medication: MedicationCreateNestedOneWithoutMedicalEventMedicationsInput
  }

  export type MedicalEventMedicationUncheckedCreateInput = {
    id?: string
    medicalEventId: string
    medicationId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type MedicalEventMedicationUpdateInput = {
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalEvent?: MedicalEventUpdateOneRequiredWithoutMedicationsUsedNestedInput
    medication?: MedicationUpdateOneRequiredWithoutMedicalEventMedicationsNestedInput
  }

  export type MedicalEventMedicationUncheckedUpdateInput = {
    medicalEventId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalEventMedicationCreateManyInput = {
    id?: string
    medicalEventId: string
    medicationId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type MedicalEventMedicationUpdateManyMutationInput = {
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalEventMedicationUncheckedUpdateManyInput = {
    medicalEventId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockMovementCreateInput = {
    id?: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
    medication: MedicationCreateNestedOneWithoutStockMovementsInput
  }

  export type StockMovementUncheckedCreateInput = {
    id?: string
    medicationId: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medication?: MedicationUpdateOneRequiredWithoutStockMovementsNestedInput
  }

  export type StockMovementUncheckedUpdateInput = {
    medicationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementCreateManyInput = {
    id?: string
    medicationId: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyInput = {
    medicationId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccinations?: VaccinationCreateNestedManyWithoutCampaignInput
    notifications?: NotificationCreateNestedManyWithoutVaccinationCampaignInput
  }

  export type VaccinationCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutCampaignInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutVaccinationCampaignInput
  }

  export type VaccinationCampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUpdateManyWithoutCampaignNestedInput
    notifications?: NotificationUpdateManyWithoutVaccinationCampaignNestedInput
  }

  export type VaccinationCampaignUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUncheckedUpdateManyWithoutCampaignNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutVaccinationCampaignNestedInput
  }

  export type VaccinationCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCampaignUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateInput = {
    id?: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutVaccinationsInput
    campaign: VaccinationCampaignCreateNestedOneWithoutVaccinationsInput
    nurse?: SchoolNurseCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateInput = {
    id?: string
    studentId: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationUpdateInput = {
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutVaccinationsNestedInput
    campaign?: VaccinationCampaignUpdateOneRequiredWithoutVaccinationsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateManyInput = {
    id?: string
    studentId: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationUpdateManyMutationInput = {
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckCampaignCreateInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalChecks?: MedicalCheckCreateNestedManyWithoutCampaignInput
    notifications?: NotificationCreateNestedManyWithoutMedicalCheckCampaignInput
  }

  export type MedicalCheckCampaignUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutCampaignInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMedicalCheckCampaignInput
  }

  export type MedicalCheckCampaignUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalChecks?: MedicalCheckUpdateManyWithoutCampaignNestedInput
    notifications?: NotificationUpdateManyWithoutMedicalCheckCampaignNestedInput
  }

  export type MedicalCheckCampaignUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutCampaignNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMedicalCheckCampaignNestedInput
  }

  export type MedicalCheckCampaignCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCampaignUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckCampaignUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckCreateInput = {
    id?: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalChecksInput
    campaign: MedicalCheckCampaignCreateNestedOneWithoutMedicalChecksInput
    nurse?: SchoolNurseCreateNestedOneWithoutMedicalChecksInput
  }

  export type MedicalCheckUncheckedCreateInput = {
    id?: string
    studentId: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckUpdateInput = {
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalChecksNestedInput
    campaign?: MedicalCheckCampaignUpdateOneRequiredWithoutMedicalChecksNestedInput
    nurse?: SchoolNurseUpdateOneWithoutMedicalChecksNestedInput
  }

  export type MedicalCheckUncheckedUpdateInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckCreateManyInput = {
    id?: string
    studentId: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckUpdateManyMutationInput = {
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUncheckedUpdateManyInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalDocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
    medicalEvent?: MedicalEventCreateNestedOneWithoutDocumentsInput
  }

  export type MedicalDocumentUncheckedCreateInput = {
    id?: string
    medicalEventId?: string | null
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MedicalDocumentUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalEvent?: MedicalEventUpdateOneWithoutDocumentsNestedInput
  }

  export type MedicalDocumentUncheckedUpdateInput = {
    medicalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalDocumentCreateManyInput = {
    id?: string
    medicalEventId?: string | null
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MedicalDocumentUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalDocumentUncheckedUpdateManyInput = {
    medicalEventId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: usersCreateNestedOneWithoutCreatedPostsInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    authorId: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: usersUpdateOneRequiredWithoutCreatedPostsNestedInput
  }

  export type PostUncheckedUpdateInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateManyInput = {
    id?: string
    authorId: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutNotificationsInput
    vaccinationCampaign?: VaccinationCampaignCreateNestedOneWithoutNotificationsInput
    medicalCheckCampaign?: MedicalCheckCampaignCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    vaccinationCampaignId?: string | null
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNotificationsNestedInput
    vaccinationCampaign?: VaccinationCampaignUpdateOneWithoutNotificationsNestedInput
    medicalCheckCampaign?: MedicalCheckCampaignUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    vaccinationCampaignId?: string | null
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolInfoCreateInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    description?: string | null
    healthDeptHead?: string | null
    healthDeptPhone?: string | null
    healthDeptEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolInfoUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    description?: string | null
    healthDeptHead?: string | null
    healthDeptPhone?: string | null
    healthDeptEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolInfoUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptHead?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptPhone?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolInfoUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptHead?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptPhone?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolInfoCreateManyInput = {
    id?: string
    name: string
    address: string
    phone?: string | null
    email?: string | null
    website?: string | null
    logo?: string | null
    description?: string | null
    healthDeptHead?: string | null
    healthDeptPhone?: string | null
    healthDeptEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SchoolInfoUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptHead?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptPhone?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SchoolInfoUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    website?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptHead?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptPhone?: NullableStringFieldUpdateOperationsInput | string | null
    healthDeptEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StudentNullableScalarRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type ParentNullableScalarRelationFilter = {
    is?: ParentWhereInput | null
    isNot?: ParentWhereInput | null
  }

  export type SchoolNurseNullableScalarRelationFilter = {
    is?: SchoolNurseWhereInput | null
    isNot?: SchoolNurseWhereInput | null
  }

  export type ManagerNullableScalarRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type AdminNullableScalarRelationFilter = {
    is?: AdminWhereInput | null
    isNot?: AdminWhereInput | null
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type MedicalEventListRelationFilter = {
    every?: MedicalEventWhereInput
    some?: MedicalEventWhereInput
    none?: MedicalEventWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    password?: SortOrder
    email?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type StudentParentListRelationFilter = {
    every?: StudentParentWhereInput
    some?: StudentParentWhereInput
    none?: StudentParentWhereInput
  }

  export type HealthProfileNullableScalarRelationFilter = {
    is?: HealthProfileWhereInput | null
    isNot?: HealthProfileWhereInput | null
  }

  export type VaccinationListRelationFilter = {
    every?: VaccinationWhereInput
    some?: VaccinationWhereInput
    none?: VaccinationWhereInput
  }

  export type MedicalCheckListRelationFilter = {
    every?: MedicalCheckWhereInput
    some?: MedicalCheckWhereInput
    none?: MedicalCheckWhereInput
  }

  export type StudentMedicationListRelationFilter = {
    every?: StudentMedicationWhereInput
    some?: StudentMedicationWhereInput
    none?: StudentMedicationWhereInput
  }

  export type StudentParentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VaccinationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalCheckOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentMedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentCode?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    class?: SortOrder
    grade?: SortOrder
    bloodType?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentCode?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    class?: SortOrder
    grade?: SortOrder
    bloodType?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    studentCode?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    class?: SortOrder
    grade?: SortOrder
    bloodType?: SortOrder
    emergencyContact?: SortOrder
    emergencyPhone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    occupation?: SortOrder
    workplace?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type SchoolNurseCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolNurseAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type SchoolNurseMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolNurseMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    licenseNumber?: SortOrder
    specialization?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolNurseSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
    position?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AdminCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentScalarRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ParentScalarRelationFilter = {
    is?: ParentWhereInput
    isNot?: ParentWhereInput
  }

  export type StudentParentStudentIdParentIdCompoundUniqueInput = {
    studentId: string
    parentId: string
  }

  export type StudentParentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
  }

  export type StudentParentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
  }

  export type StudentParentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    relationship?: SortOrder
    isPrimary?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type HealthProfileCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    allergies?: SortOrder
    chronicDiseases?: SortOrder
    medications?: SortOrder
    treatmentHistory?: SortOrder
    vision?: SortOrder
    hearing?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileAvgOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type HealthProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    treatmentHistory?: SortOrder
    vision?: SortOrder
    hearing?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    treatmentHistory?: SortOrder
    vision?: SortOrder
    hearing?: SortOrder
    height?: SortOrder
    weight?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileSumOrderByAggregateInput = {
    height?: SortOrder
    weight?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumMedicalEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventType | EnumMedicalEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventTypeFilter<$PrismaModel> | $Enums.MedicalEventType
  }

  export type EnumMedicalEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventStatus | EnumMedicalEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventStatusFilter<$PrismaModel> | $Enums.MedicalEventStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type MedicalEventMedicationListRelationFilter = {
    every?: MedicalEventMedicationWhereInput
    some?: MedicalEventMedicationWhereInput
    none?: MedicalEventMedicationWhereInput
  }

  export type MedicalDocumentListRelationFilter = {
    every?: MedicalDocumentWhereInput
    some?: MedicalDocumentWhereInput
    none?: MedicalDocumentWhereInput
  }

  export type MedicalEventMedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicalEventCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    nurseId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    location?: SortOrder
    symptoms?: SortOrder
    treatment?: SortOrder
    outcome?: SortOrder
    occurredAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalEventMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    nurseId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    location?: SortOrder
    treatment?: SortOrder
    outcome?: SortOrder
    occurredAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalEventMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    nurseId?: SortOrder
    createdById?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    severity?: SortOrder
    location?: SortOrder
    treatment?: SortOrder
    outcome?: SortOrder
    occurredAt?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMedicalEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventType | EnumMedicalEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.MedicalEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalEventTypeFilter<$PrismaModel>
    _max?: NestedEnumMedicalEventTypeFilter<$PrismaModel>
  }

  export type EnumMedicalEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventStatus | EnumMedicalEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalEventStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalEventStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StockMovementListRelationFilter = {
    every?: StockMovementWhereInput
    some?: StockMovementWhereInput
    none?: StockMovementWhereInput
  }

  export type StockMovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dosage?: SortOrder
    unit?: SortOrder
    manufacturer?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationAvgOrderByAggregateInput = {
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dosage?: SortOrder
    unit?: SortOrder
    manufacturer?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    dosage?: SortOrder
    unit?: SortOrder
    manufacturer?: SortOrder
    expiryDate?: SortOrder
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationSumOrderByAggregateInput = {
    stockQuantity?: SortOrder
    minStockLevel?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMedicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusFilter<$PrismaModel> | $Enums.MedicationStatus
  }

  export type MedicationScalarRelationFilter = {
    is?: MedicationWhereInput
    isNot?: MedicationWhereInput
  }

  export type StudentMedicationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    medicationId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    medicationId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMedicationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    parentId?: SortOrder
    medicationId?: SortOrder
    dosage?: SortOrder
    frequency?: SortOrder
    duration?: SortOrder
    instructions?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMedicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicationStatusFilter<$PrismaModel>
  }

  export type MedicalEventScalarRelationFilter = {
    is?: MedicalEventWhereInput
    isNot?: MedicalEventWhereInput
  }

  export type MedicalEventMedicationCountOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    medicationId?: SortOrder
    quantityUsed?: SortOrder
    dosageGiven?: SortOrder
    administeredAt?: SortOrder
    notes?: SortOrder
  }

  export type MedicalEventMedicationAvgOrderByAggregateInput = {
    quantityUsed?: SortOrder
  }

  export type MedicalEventMedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    medicationId?: SortOrder
    quantityUsed?: SortOrder
    dosageGiven?: SortOrder
    administeredAt?: SortOrder
    notes?: SortOrder
  }

  export type MedicalEventMedicationMinOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    medicationId?: SortOrder
    quantityUsed?: SortOrder
    dosageGiven?: SortOrder
    administeredAt?: SortOrder
    notes?: SortOrder
  }

  export type MedicalEventMedicationSumOrderByAggregateInput = {
    quantityUsed?: SortOrder
  }

  export type StockMovementCountOrderByAggregateInput = {
    id?: SortOrder
    medicationId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type StockMovementMaxOrderByAggregateInput = {
    id?: SortOrder
    medicationId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementMinOrderByAggregateInput = {
    id?: SortOrder
    medicationId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reason?: SortOrder
    reference?: SortOrder
    createdAt?: SortOrder
  }

  export type StockMovementSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type VaccinationCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    vaccineName?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaccinationCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    vaccineName?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaccinationCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    vaccineName?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVaccinationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VaccinationStatus | EnumVaccinationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVaccinationStatusFilter<$PrismaModel> | $Enums.VaccinationStatus
  }

  export type VaccinationCampaignScalarRelationFilter = {
    is?: VaccinationCampaignWhereInput
    isNot?: VaccinationCampaignWhereInput
  }

  export type VaccinationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    administeredDate?: SortOrder
    dose?: SortOrder
    batch?: SortOrder
    sideEffects?: SortOrder
    notes?: SortOrder
    parentConsent?: SortOrder
    consentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaccinationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    administeredDate?: SortOrder
    dose?: SortOrder
    batch?: SortOrder
    sideEffects?: SortOrder
    notes?: SortOrder
    parentConsent?: SortOrder
    consentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VaccinationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    administeredDate?: SortOrder
    dose?: SortOrder
    batch?: SortOrder
    sideEffects?: SortOrder
    notes?: SortOrder
    parentConsent?: SortOrder
    consentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumVaccinationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VaccinationStatus | EnumVaccinationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVaccinationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VaccinationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVaccinationStatusFilter<$PrismaModel>
    _max?: NestedEnumVaccinationStatusFilter<$PrismaModel>
  }

  export type MedicalCheckCampaignCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    checkTypes?: SortOrder
    targetGrades?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalCheckCampaignMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalCheckCampaignMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    scheduledDate?: SortOrder
    deadline?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMedicalCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCheckStatus | EnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCheckStatusFilter<$PrismaModel> | $Enums.MedicalCheckStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type MedicalCheckCampaignScalarRelationFilter = {
    is?: MedicalCheckCampaignWhereInput
    isNot?: MedicalCheckCampaignWhereInput
  }

  export type MedicalCheckCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    visionResult?: SortOrder
    hearingResult?: SortOrder
    dentalResult?: SortOrder
    heightWeight?: SortOrder
    generalHealth?: SortOrder
    recommendations?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    parentResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalCheckMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    visionResult?: SortOrder
    hearingResult?: SortOrder
    dentalResult?: SortOrder
    generalHealth?: SortOrder
    recommendations?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    parentResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicalCheckMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    campaignId?: SortOrder
    nurseId?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completedDate?: SortOrder
    visionResult?: SortOrder
    hearingResult?: SortOrder
    dentalResult?: SortOrder
    generalHealth?: SortOrder
    recommendations?: SortOrder
    requiresFollowUp?: SortOrder
    followUpDate?: SortOrder
    notes?: SortOrder
    parentNotified?: SortOrder
    parentResponse?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMedicalCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCheckStatus | EnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalCheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalCheckStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type MedicalEventNullableScalarRelationFilter = {
    is?: MedicalEventWhereInput | null
    isNot?: MedicalEventWhereInput | null
  }

  export type MedicalDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalDocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type MedicalDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    medicalEventId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileName?: SortOrder
    filePath?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicalDocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    excerpt?: SortOrder
    coverImage?: SortOrder
    category?: SortOrder
    isPublished?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type VaccinationCampaignNullableScalarRelationFilter = {
    is?: VaccinationCampaignWhereInput | null
    isNot?: VaccinationCampaignWhereInput | null
  }

  export type MedicalCheckCampaignNullableScalarRelationFilter = {
    is?: MedicalCheckCampaignWhereInput | null
    isNot?: MedicalCheckCampaignWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vaccinationCampaignId?: SortOrder
    medicalCheckCampaignId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vaccinationCampaignId?: SortOrder
    medicalCheckCampaignId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    vaccinationCampaignId?: SortOrder
    medicalCheckCampaignId?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type SchoolInfoCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    healthDeptHead?: SortOrder
    healthDeptPhone?: SortOrder
    healthDeptEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    healthDeptHead?: SortOrder
    healthDeptPhone?: SortOrder
    healthDeptEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SchoolInfoMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    website?: SortOrder
    logo?: SortOrder
    description?: SortOrder
    healthDeptHead?: SortOrder
    healthDeptPhone?: SortOrder
    healthDeptEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type SchoolNurseCreateNestedOneWithoutUserInput = {
    create?: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutUserInput
    connect?: SchoolNurseWhereUniqueInput
  }

  export type ManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type AdminCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type MedicalEventCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput> | MedicalEventCreateWithoutCreatedByInput[] | MedicalEventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutCreatedByInput | MedicalEventCreateOrConnectWithoutCreatedByInput[]
    createMany?: MedicalEventCreateManyCreatedByInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    connect?: ParentWhereUniqueInput
  }

  export type SchoolNurseUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutUserInput
    connect?: SchoolNurseWhereUniqueInput
  }

  export type ManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type AdminUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    connect?: AdminWhereUniqueInput
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput> | MedicalEventCreateWithoutCreatedByInput[] | MedicalEventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutCreatedByInput | MedicalEventCreateOrConnectWithoutCreatedByInput[]
    createMany?: MedicalEventCreateManyCreatedByInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type SchoolNurseUpdateOneWithoutUserNestedInput = {
    create?: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutUserInput
    upsert?: SchoolNurseUpsertWithoutUserInput
    disconnect?: SchoolNurseWhereInput | boolean
    delete?: SchoolNurseWhereInput | boolean
    connect?: SchoolNurseWhereUniqueInput
    update?: XOR<XOR<SchoolNurseUpdateToOneWithWhereWithoutUserInput, SchoolNurseUpdateWithoutUserInput>, SchoolNurseUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type MedicalEventUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput> | MedicalEventCreateWithoutCreatedByInput[] | MedicalEventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutCreatedByInput | MedicalEventCreateOrConnectWithoutCreatedByInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutCreatedByInput | MedicalEventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MedicalEventCreateManyCreatedByInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutCreatedByInput | MedicalEventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutCreatedByInput | MedicalEventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    connectOrCreate?: ParentCreateOrConnectWithoutUserInput
    upsert?: ParentUpsertWithoutUserInput
    disconnect?: ParentWhereInput | boolean
    delete?: ParentWhereInput | boolean
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutUserInput, ParentUpdateWithoutUserInput>, ParentUncheckedUpdateWithoutUserInput>
  }

  export type SchoolNurseUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutUserInput
    upsert?: SchoolNurseUpsertWithoutUserInput
    disconnect?: SchoolNurseWhereInput | boolean
    delete?: SchoolNurseWhereInput | boolean
    connect?: SchoolNurseWhereUniqueInput
    update?: XOR<XOR<SchoolNurseUpdateToOneWithWhereWithoutUserInput, SchoolNurseUpdateWithoutUserInput>, SchoolNurseUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type AdminUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    connectOrCreate?: AdminCreateOrConnectWithoutUserInput
    upsert?: AdminUpsertWithoutUserInput
    disconnect?: AdminWhereInput | boolean
    delete?: AdminWhereInput | boolean
    connect?: AdminWhereUniqueInput
    update?: XOR<XOR<AdminUpdateToOneWithWhereWithoutUserInput, AdminUpdateWithoutUserInput>, AdminUncheckedUpdateWithoutUserInput>
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput> | MedicalEventCreateWithoutCreatedByInput[] | MedicalEventUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutCreatedByInput | MedicalEventCreateOrConnectWithoutCreatedByInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutCreatedByInput | MedicalEventUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: MedicalEventCreateManyCreatedByInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutCreatedByInput | MedicalEventUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutCreatedByInput | MedicalEventUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<usersCreateWithoutStudentProfileInput, usersUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentProfileInput
    connect?: usersWhereUniqueInput
  }

  export type StudentParentCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type HealthProfileCreateNestedOneWithoutStudentInput = {
    create?: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutStudentInput
    connect?: HealthProfileWhereUniqueInput
  }

  export type MedicalEventCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput> | MedicalEventCreateWithoutStudentInput[] | MedicalEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutStudentInput | MedicalEventCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalEventCreateManyStudentInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type VaccinationCreateNestedManyWithoutStudentInput = {
    create?: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput> | VaccinationCreateWithoutStudentInput[] | VaccinationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutStudentInput | VaccinationCreateOrConnectWithoutStudentInput[]
    createMany?: VaccinationCreateManyStudentInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type MedicalCheckCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput> | MedicalCheckCreateWithoutStudentInput[] | MedicalCheckUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutStudentInput | MedicalCheckCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalCheckCreateManyStudentInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type StudentMedicationCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput> | StudentMedicationCreateWithoutStudentInput[] | StudentMedicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutStudentInput | StudentMedicationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentMedicationCreateManyStudentInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type HealthProfileUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutStudentInput
    connect?: HealthProfileWhereUniqueInput
  }

  export type MedicalEventUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput> | MedicalEventCreateWithoutStudentInput[] | MedicalEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutStudentInput | MedicalEventCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalEventCreateManyStudentInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput> | VaccinationCreateWithoutStudentInput[] | VaccinationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutStudentInput | VaccinationCreateOrConnectWithoutStudentInput[]
    createMany?: VaccinationCreateManyStudentInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type MedicalCheckUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput> | MedicalCheckCreateWithoutStudentInput[] | MedicalCheckUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutStudentInput | MedicalCheckCreateOrConnectWithoutStudentInput[]
    createMany?: MedicalCheckCreateManyStudentInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type StudentMedicationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput> | StudentMedicationCreateWithoutStudentInput[] | StudentMedicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutStudentInput | StudentMedicationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentMedicationCreateManyStudentInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutStudentProfileNestedInput = {
    create?: XOR<usersCreateWithoutStudentProfileInput, usersUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutStudentProfileInput
    upsert?: usersUpsertWithoutStudentProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutStudentProfileInput, usersUpdateWithoutStudentProfileInput>, usersUncheckedUpdateWithoutStudentProfileInput>
  }

  export type StudentParentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type HealthProfileUpdateOneWithoutStudentNestedInput = {
    create?: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutStudentInput
    upsert?: HealthProfileUpsertWithoutStudentInput
    disconnect?: HealthProfileWhereInput | boolean
    delete?: HealthProfileWhereInput | boolean
    connect?: HealthProfileWhereUniqueInput
    update?: XOR<XOR<HealthProfileUpdateToOneWithWhereWithoutStudentInput, HealthProfileUpdateWithoutStudentInput>, HealthProfileUncheckedUpdateWithoutStudentInput>
  }

  export type MedicalEventUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput> | MedicalEventCreateWithoutStudentInput[] | MedicalEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutStudentInput | MedicalEventCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutStudentInput | MedicalEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalEventCreateManyStudentInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutStudentInput | MedicalEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutStudentInput | MedicalEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type VaccinationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput> | VaccinationCreateWithoutStudentInput[] | VaccinationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutStudentInput | VaccinationCreateOrConnectWithoutStudentInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutStudentInput | VaccinationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: VaccinationCreateManyStudentInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutStudentInput | VaccinationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutStudentInput | VaccinationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type MedicalCheckUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput> | MedicalCheckCreateWithoutStudentInput[] | MedicalCheckUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutStudentInput | MedicalCheckCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutStudentInput | MedicalCheckUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalCheckCreateManyStudentInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutStudentInput | MedicalCheckUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutStudentInput | MedicalCheckUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type StudentMedicationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput> | StudentMedicationCreateWithoutStudentInput[] | StudentMedicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutStudentInput | StudentMedicationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutStudentInput | StudentMedicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentMedicationCreateManyStudentInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutStudentInput | StudentMedicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutStudentInput | StudentMedicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput> | StudentParentCreateWithoutStudentInput[] | StudentParentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutStudentInput | StudentParentCreateOrConnectWithoutStudentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutStudentInput | StudentParentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentParentCreateManyStudentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutStudentInput | StudentParentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutStudentInput | StudentParentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type HealthProfileUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutStudentInput
    upsert?: HealthProfileUpsertWithoutStudentInput
    disconnect?: HealthProfileWhereInput | boolean
    delete?: HealthProfileWhereInput | boolean
    connect?: HealthProfileWhereUniqueInput
    update?: XOR<XOR<HealthProfileUpdateToOneWithWhereWithoutStudentInput, HealthProfileUpdateWithoutStudentInput>, HealthProfileUncheckedUpdateWithoutStudentInput>
  }

  export type MedicalEventUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput> | MedicalEventCreateWithoutStudentInput[] | MedicalEventUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutStudentInput | MedicalEventCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutStudentInput | MedicalEventUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalEventCreateManyStudentInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutStudentInput | MedicalEventUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutStudentInput | MedicalEventUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput> | VaccinationCreateWithoutStudentInput[] | VaccinationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutStudentInput | VaccinationCreateOrConnectWithoutStudentInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutStudentInput | VaccinationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: VaccinationCreateManyStudentInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutStudentInput | VaccinationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutStudentInput | VaccinationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput> | MedicalCheckCreateWithoutStudentInput[] | MedicalCheckUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutStudentInput | MedicalCheckCreateOrConnectWithoutStudentInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutStudentInput | MedicalCheckUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MedicalCheckCreateManyStudentInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutStudentInput | MedicalCheckUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutStudentInput | MedicalCheckUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput> | StudentMedicationCreateWithoutStudentInput[] | StudentMedicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutStudentInput | StudentMedicationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutStudentInput | StudentMedicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentMedicationCreateManyStudentInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutStudentInput | StudentMedicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutStudentInput | StudentMedicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutParentProfileInput = {
    create?: XOR<usersCreateWithoutParentProfileInput, usersUncheckedCreateWithoutParentProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutParentProfileInput
    connect?: usersWhereUniqueInput
  }

  export type StudentParentCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentMedicationCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput> | StudentMedicationCreateWithoutParentInput[] | StudentMedicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutParentInput | StudentMedicationCreateOrConnectWithoutParentInput[]
    createMany?: StudentMedicationCreateManyParentInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type StudentParentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
  }

  export type StudentMedicationUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput> | StudentMedicationCreateWithoutParentInput[] | StudentMedicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutParentInput | StudentMedicationCreateOrConnectWithoutParentInput[]
    createMany?: StudentMedicationCreateManyParentInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type usersUpdateOneRequiredWithoutParentProfileNestedInput = {
    create?: XOR<usersCreateWithoutParentProfileInput, usersUncheckedCreateWithoutParentProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutParentProfileInput
    upsert?: usersUpsertWithoutParentProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutParentProfileInput, usersUpdateWithoutParentProfileInput>, usersUncheckedUpdateWithoutParentProfileInput>
  }

  export type StudentParentUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentMedicationUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput> | StudentMedicationCreateWithoutParentInput[] | StudentMedicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutParentInput | StudentMedicationCreateOrConnectWithoutParentInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutParentInput | StudentMedicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentMedicationCreateManyParentInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutParentInput | StudentMedicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutParentInput | StudentMedicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type StudentParentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput> | StudentParentCreateWithoutParentInput[] | StudentParentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentParentCreateOrConnectWithoutParentInput | StudentParentCreateOrConnectWithoutParentInput[]
    upsert?: StudentParentUpsertWithWhereUniqueWithoutParentInput | StudentParentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentParentCreateManyParentInputEnvelope
    set?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    disconnect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    delete?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    connect?: StudentParentWhereUniqueInput | StudentParentWhereUniqueInput[]
    update?: StudentParentUpdateWithWhereUniqueWithoutParentInput | StudentParentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentParentUpdateManyWithWhereWithoutParentInput | StudentParentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
  }

  export type StudentMedicationUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput> | StudentMedicationCreateWithoutParentInput[] | StudentMedicationUncheckedCreateWithoutParentInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutParentInput | StudentMedicationCreateOrConnectWithoutParentInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutParentInput | StudentMedicationUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: StudentMedicationCreateManyParentInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutParentInput | StudentMedicationUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutParentInput | StudentMedicationUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutNurseProfileInput = {
    create?: XOR<usersCreateWithoutNurseProfileInput, usersUncheckedCreateWithoutNurseProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutNurseProfileInput
    connect?: usersWhereUniqueInput
  }

  export type MedicalEventCreateNestedManyWithoutNurseInput = {
    create?: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput> | MedicalEventCreateWithoutNurseInput[] | MedicalEventUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutNurseInput | MedicalEventCreateOrConnectWithoutNurseInput[]
    createMany?: MedicalEventCreateManyNurseInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type VaccinationCreateNestedManyWithoutNurseInput = {
    create?: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput> | VaccinationCreateWithoutNurseInput[] | VaccinationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutNurseInput | VaccinationCreateOrConnectWithoutNurseInput[]
    createMany?: VaccinationCreateManyNurseInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type MedicalCheckCreateNestedManyWithoutNurseInput = {
    create?: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput> | MedicalCheckCreateWithoutNurseInput[] | MedicalCheckUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutNurseInput | MedicalCheckCreateOrConnectWithoutNurseInput[]
    createMany?: MedicalCheckCreateManyNurseInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type MedicalEventUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput> | MedicalEventCreateWithoutNurseInput[] | MedicalEventUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutNurseInput | MedicalEventCreateOrConnectWithoutNurseInput[]
    createMany?: MedicalEventCreateManyNurseInputEnvelope
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput> | VaccinationCreateWithoutNurseInput[] | VaccinationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutNurseInput | VaccinationCreateOrConnectWithoutNurseInput[]
    createMany?: VaccinationCreateManyNurseInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type MedicalCheckUncheckedCreateNestedManyWithoutNurseInput = {
    create?: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput> | MedicalCheckCreateWithoutNurseInput[] | MedicalCheckUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutNurseInput | MedicalCheckCreateOrConnectWithoutNurseInput[]
    createMany?: MedicalCheckCreateManyNurseInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type usersUpdateOneRequiredWithoutNurseProfileNestedInput = {
    create?: XOR<usersCreateWithoutNurseProfileInput, usersUncheckedCreateWithoutNurseProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutNurseProfileInput
    upsert?: usersUpsertWithoutNurseProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNurseProfileInput, usersUpdateWithoutNurseProfileInput>, usersUncheckedUpdateWithoutNurseProfileInput>
  }

  export type MedicalEventUpdateManyWithoutNurseNestedInput = {
    create?: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput> | MedicalEventCreateWithoutNurseInput[] | MedicalEventUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutNurseInput | MedicalEventCreateOrConnectWithoutNurseInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutNurseInput | MedicalEventUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: MedicalEventCreateManyNurseInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutNurseInput | MedicalEventUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutNurseInput | MedicalEventUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type VaccinationUpdateManyWithoutNurseNestedInput = {
    create?: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput> | VaccinationCreateWithoutNurseInput[] | VaccinationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutNurseInput | VaccinationCreateOrConnectWithoutNurseInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutNurseInput | VaccinationUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: VaccinationCreateManyNurseInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutNurseInput | VaccinationUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutNurseInput | VaccinationUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type MedicalCheckUpdateManyWithoutNurseNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput> | MedicalCheckCreateWithoutNurseInput[] | MedicalCheckUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutNurseInput | MedicalCheckCreateOrConnectWithoutNurseInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutNurseInput | MedicalCheckUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: MedicalCheckCreateManyNurseInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutNurseInput | MedicalCheckUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutNurseInput | MedicalCheckUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type MedicalEventUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput> | MedicalEventCreateWithoutNurseInput[] | MedicalEventUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalEventCreateOrConnectWithoutNurseInput | MedicalEventCreateOrConnectWithoutNurseInput[]
    upsert?: MedicalEventUpsertWithWhereUniqueWithoutNurseInput | MedicalEventUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: MedicalEventCreateManyNurseInputEnvelope
    set?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    disconnect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    delete?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    connect?: MedicalEventWhereUniqueInput | MedicalEventWhereUniqueInput[]
    update?: MedicalEventUpdateWithWhereUniqueWithoutNurseInput | MedicalEventUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: MedicalEventUpdateManyWithWhereWithoutNurseInput | MedicalEventUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput> | VaccinationCreateWithoutNurseInput[] | VaccinationUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutNurseInput | VaccinationCreateOrConnectWithoutNurseInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutNurseInput | VaccinationUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: VaccinationCreateManyNurseInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutNurseInput | VaccinationUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutNurseInput | VaccinationUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type MedicalCheckUncheckedUpdateManyWithoutNurseNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput> | MedicalCheckCreateWithoutNurseInput[] | MedicalCheckUncheckedCreateWithoutNurseInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutNurseInput | MedicalCheckCreateOrConnectWithoutNurseInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutNurseInput | MedicalCheckUpsertWithWhereUniqueWithoutNurseInput[]
    createMany?: MedicalCheckCreateManyNurseInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutNurseInput | MedicalCheckUpdateWithWhereUniqueWithoutNurseInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutNurseInput | MedicalCheckUpdateManyWithWhereWithoutNurseInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutManagerProfileInput = {
    create?: XOR<usersCreateWithoutManagerProfileInput, usersUncheckedCreateWithoutManagerProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutManagerProfileInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutManagerProfileNestedInput = {
    create?: XOR<usersCreateWithoutManagerProfileInput, usersUncheckedCreateWithoutManagerProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutManagerProfileInput
    upsert?: usersUpsertWithoutManagerProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutManagerProfileInput, usersUpdateWithoutManagerProfileInput>, usersUncheckedUpdateWithoutManagerProfileInput>
  }

  export type AdminCreatepermissionsInput = {
    set: string[]
  }

  export type usersCreateNestedOneWithoutAdminProfileInput = {
    create?: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminProfileInput
    connect?: usersWhereUniqueInput
  }

  export type AdminUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdateOneRequiredWithoutAdminProfileNestedInput = {
    create?: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    connectOrCreate?: usersCreateOrConnectWithoutAdminProfileInput
    upsert?: usersUpsertWithoutAdminProfileInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAdminProfileInput, usersUpdateWithoutAdminProfileInput>, usersUncheckedUpdateWithoutAdminProfileInput>
  }

  export type StudentCreateNestedOneWithoutParentsInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    connect?: ParentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutParentsNestedInput = {
    create?: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutParentsInput
    upsert?: StudentUpsertWithoutParentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutParentsInput, StudentUpdateWithoutParentsInput>, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type ParentUpdateOneRequiredWithoutChildrenNestedInput = {
    create?: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: ParentCreateOrConnectWithoutChildrenInput
    upsert?: ParentUpsertWithoutChildrenInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutChildrenInput, ParentUpdateWithoutChildrenInput>, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type HealthProfileCreateallergiesInput = {
    set: string[]
  }

  export type HealthProfileCreatechronicDiseasesInput = {
    set: string[]
  }

  export type HealthProfileCreatemedicationsInput = {
    set: string[]
  }

  export type StudentCreateNestedOneWithoutHealthProfileInput = {
    create?: XOR<StudentCreateWithoutHealthProfileInput, StudentUncheckedCreateWithoutHealthProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHealthProfileInput
    connect?: StudentWhereUniqueInput
  }

  export type HealthProfileUpdateallergiesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HealthProfileUpdatechronicDiseasesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type HealthProfileUpdatemedicationsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type StudentUpdateOneRequiredWithoutHealthProfileNestedInput = {
    create?: XOR<StudentCreateWithoutHealthProfileInput, StudentUncheckedCreateWithoutHealthProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutHealthProfileInput
    upsert?: StudentUpsertWithoutHealthProfileInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutHealthProfileInput, StudentUpdateWithoutHealthProfileInput>, StudentUncheckedUpdateWithoutHealthProfileInput>
  }

  export type MedicalEventCreatesymptomsInput = {
    set: string[]
  }

  export type StudentCreateNestedOneWithoutMedicalEventsInput = {
    create?: XOR<StudentCreateWithoutMedicalEventsInput, StudentUncheckedCreateWithoutMedicalEventsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalEventsInput
    connect?: StudentWhereUniqueInput
  }

  export type SchoolNurseCreateNestedOneWithoutHandledEventsInput = {
    create?: XOR<SchoolNurseCreateWithoutHandledEventsInput, SchoolNurseUncheckedCreateWithoutHandledEventsInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutHandledEventsInput
    connect?: SchoolNurseWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCreatedEventsInput = {
    create?: XOR<usersCreateWithoutCreatedEventsInput, usersUncheckedCreateWithoutCreatedEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedEventsInput
    connect?: usersWhereUniqueInput
  }

  export type MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput> | MedicalEventMedicationCreateWithoutMedicalEventInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput | MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput[]
    createMany?: MedicalEventMedicationCreateManyMedicalEventInputEnvelope
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
  }

  export type MedicalDocumentCreateNestedManyWithoutMedicalEventInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput> | MedicalDocumentCreateWithoutMedicalEventInput[] | MedicalDocumentUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalEventInput | MedicalDocumentCreateOrConnectWithoutMedicalEventInput[]
    createMany?: MedicalDocumentCreateManyMedicalEventInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput> | MedicalEventMedicationCreateWithoutMedicalEventInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput | MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput[]
    createMany?: MedicalEventMedicationCreateManyMedicalEventInputEnvelope
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
  }

  export type MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput> | MedicalDocumentCreateWithoutMedicalEventInput[] | MedicalDocumentUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalEventInput | MedicalDocumentCreateOrConnectWithoutMedicalEventInput[]
    createMany?: MedicalDocumentCreateManyMedicalEventInputEnvelope
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
  }

  export type EnumMedicalEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.MedicalEventType
  }

  export type EnumMedicalEventStatusFieldUpdateOperationsInput = {
    set?: $Enums.MedicalEventStatus
  }

  export type MedicalEventUpdatesymptomsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type StudentUpdateOneRequiredWithoutMedicalEventsNestedInput = {
    create?: XOR<StudentCreateWithoutMedicalEventsInput, StudentUncheckedCreateWithoutMedicalEventsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalEventsInput
    upsert?: StudentUpsertWithoutMedicalEventsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMedicalEventsInput, StudentUpdateWithoutMedicalEventsInput>, StudentUncheckedUpdateWithoutMedicalEventsInput>
  }

  export type SchoolNurseUpdateOneWithoutHandledEventsNestedInput = {
    create?: XOR<SchoolNurseCreateWithoutHandledEventsInput, SchoolNurseUncheckedCreateWithoutHandledEventsInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutHandledEventsInput
    upsert?: SchoolNurseUpsertWithoutHandledEventsInput
    disconnect?: boolean
    delete?: SchoolNurseWhereInput | boolean
    connect?: SchoolNurseWhereUniqueInput
    update?: XOR<XOR<SchoolNurseUpdateToOneWithWhereWithoutHandledEventsInput, SchoolNurseUpdateWithoutHandledEventsInput>, SchoolNurseUncheckedUpdateWithoutHandledEventsInput>
  }

  export type usersUpdateOneRequiredWithoutCreatedEventsNestedInput = {
    create?: XOR<usersCreateWithoutCreatedEventsInput, usersUncheckedCreateWithoutCreatedEventsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedEventsInput
    upsert?: usersUpsertWithoutCreatedEventsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCreatedEventsInput, usersUpdateWithoutCreatedEventsInput>, usersUncheckedUpdateWithoutCreatedEventsInput>
  }

  export type MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput> | MedicalEventMedicationCreateWithoutMedicalEventInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput | MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput[]
    upsert?: MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicalEventInput | MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicalEventInput[]
    createMany?: MedicalEventMedicationCreateManyMedicalEventInputEnvelope
    set?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    disconnect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    delete?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    update?: MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicalEventInput | MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicalEventInput[]
    updateMany?: MedicalEventMedicationUpdateManyWithWhereWithoutMedicalEventInput | MedicalEventMedicationUpdateManyWithWhereWithoutMedicalEventInput[]
    deleteMany?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
  }

  export type MedicalDocumentUpdateManyWithoutMedicalEventNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput> | MedicalDocumentCreateWithoutMedicalEventInput[] | MedicalDocumentUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalEventInput | MedicalDocumentCreateOrConnectWithoutMedicalEventInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutMedicalEventInput | MedicalDocumentUpsertWithWhereUniqueWithoutMedicalEventInput[]
    createMany?: MedicalDocumentCreateManyMedicalEventInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutMedicalEventInput | MedicalDocumentUpdateWithWhereUniqueWithoutMedicalEventInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutMedicalEventInput | MedicalDocumentUpdateManyWithWhereWithoutMedicalEventInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput> | MedicalEventMedicationCreateWithoutMedicalEventInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput | MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput[]
    upsert?: MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicalEventInput | MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicalEventInput[]
    createMany?: MedicalEventMedicationCreateManyMedicalEventInputEnvelope
    set?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    disconnect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    delete?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    update?: MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicalEventInput | MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicalEventInput[]
    updateMany?: MedicalEventMedicationUpdateManyWithWhereWithoutMedicalEventInput | MedicalEventMedicationUpdateManyWithWhereWithoutMedicalEventInput[]
    deleteMany?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput = {
    create?: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput> | MedicalDocumentCreateWithoutMedicalEventInput[] | MedicalDocumentUncheckedCreateWithoutMedicalEventInput[]
    connectOrCreate?: MedicalDocumentCreateOrConnectWithoutMedicalEventInput | MedicalDocumentCreateOrConnectWithoutMedicalEventInput[]
    upsert?: MedicalDocumentUpsertWithWhereUniqueWithoutMedicalEventInput | MedicalDocumentUpsertWithWhereUniqueWithoutMedicalEventInput[]
    createMany?: MedicalDocumentCreateManyMedicalEventInputEnvelope
    set?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    disconnect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    delete?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    connect?: MedicalDocumentWhereUniqueInput | MedicalDocumentWhereUniqueInput[]
    update?: MedicalDocumentUpdateWithWhereUniqueWithoutMedicalEventInput | MedicalDocumentUpdateWithWhereUniqueWithoutMedicalEventInput[]
    updateMany?: MedicalDocumentUpdateManyWithWhereWithoutMedicalEventInput | MedicalDocumentUpdateManyWithWhereWithoutMedicalEventInput[]
    deleteMany?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
  }

  export type StudentMedicationCreateNestedManyWithoutMedicationInput = {
    create?: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput> | StudentMedicationCreateWithoutMedicationInput[] | StudentMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutMedicationInput | StudentMedicationCreateOrConnectWithoutMedicationInput[]
    createMany?: StudentMedicationCreateManyMedicationInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type MedicalEventMedicationCreateNestedManyWithoutMedicationInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput> | MedicalEventMedicationCreateWithoutMedicationInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicationInput | MedicalEventMedicationCreateOrConnectWithoutMedicationInput[]
    createMany?: MedicalEventMedicationCreateManyMedicationInputEnvelope
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
  }

  export type StockMovementCreateNestedManyWithoutMedicationInput = {
    create?: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput> | StockMovementCreateWithoutMedicationInput[] | StockMovementUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutMedicationInput | StockMovementCreateOrConnectWithoutMedicationInput[]
    createMany?: StockMovementCreateManyMedicationInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type StudentMedicationUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput> | StudentMedicationCreateWithoutMedicationInput[] | StudentMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutMedicationInput | StudentMedicationCreateOrConnectWithoutMedicationInput[]
    createMany?: StudentMedicationCreateManyMedicationInputEnvelope
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
  }

  export type MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput> | MedicalEventMedicationCreateWithoutMedicationInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicationInput | MedicalEventMedicationCreateOrConnectWithoutMedicationInput[]
    createMany?: MedicalEventMedicationCreateManyMedicationInputEnvelope
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
  }

  export type StockMovementUncheckedCreateNestedManyWithoutMedicationInput = {
    create?: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput> | StockMovementCreateWithoutMedicationInput[] | StockMovementUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutMedicationInput | StockMovementCreateOrConnectWithoutMedicationInput[]
    createMany?: StockMovementCreateManyMedicationInputEnvelope
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentMedicationUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput> | StudentMedicationCreateWithoutMedicationInput[] | StudentMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutMedicationInput | StudentMedicationCreateOrConnectWithoutMedicationInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutMedicationInput | StudentMedicationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: StudentMedicationCreateManyMedicationInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutMedicationInput | StudentMedicationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutMedicationInput | StudentMedicationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type MedicalEventMedicationUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput> | MedicalEventMedicationCreateWithoutMedicationInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicationInput | MedicalEventMedicationCreateOrConnectWithoutMedicationInput[]
    upsert?: MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicationInput | MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: MedicalEventMedicationCreateManyMedicationInputEnvelope
    set?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    disconnect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    delete?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    update?: MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicationInput | MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: MedicalEventMedicationUpdateManyWithWhereWithoutMedicationInput | MedicalEventMedicationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
  }

  export type StockMovementUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput> | StockMovementCreateWithoutMedicationInput[] | StockMovementUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutMedicationInput | StockMovementCreateOrConnectWithoutMedicationInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutMedicationInput | StockMovementUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: StockMovementCreateManyMedicationInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutMedicationInput | StockMovementUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutMedicationInput | StockMovementUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StudentMedicationUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput> | StudentMedicationCreateWithoutMedicationInput[] | StudentMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StudentMedicationCreateOrConnectWithoutMedicationInput | StudentMedicationCreateOrConnectWithoutMedicationInput[]
    upsert?: StudentMedicationUpsertWithWhereUniqueWithoutMedicationInput | StudentMedicationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: StudentMedicationCreateManyMedicationInputEnvelope
    set?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    disconnect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    delete?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    connect?: StudentMedicationWhereUniqueInput | StudentMedicationWhereUniqueInput[]
    update?: StudentMedicationUpdateWithWhereUniqueWithoutMedicationInput | StudentMedicationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: StudentMedicationUpdateManyWithWhereWithoutMedicationInput | StudentMedicationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
  }

  export type MedicalEventMedicationUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput> | MedicalEventMedicationCreateWithoutMedicationInput[] | MedicalEventMedicationUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: MedicalEventMedicationCreateOrConnectWithoutMedicationInput | MedicalEventMedicationCreateOrConnectWithoutMedicationInput[]
    upsert?: MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicationInput | MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: MedicalEventMedicationCreateManyMedicationInputEnvelope
    set?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    disconnect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    delete?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    connect?: MedicalEventMedicationWhereUniqueInput | MedicalEventMedicationWhereUniqueInput[]
    update?: MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicationInput | MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: MedicalEventMedicationUpdateManyWithWhereWithoutMedicationInput | MedicalEventMedicationUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
  }

  export type StockMovementUncheckedUpdateManyWithoutMedicationNestedInput = {
    create?: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput> | StockMovementCreateWithoutMedicationInput[] | StockMovementUncheckedCreateWithoutMedicationInput[]
    connectOrCreate?: StockMovementCreateOrConnectWithoutMedicationInput | StockMovementCreateOrConnectWithoutMedicationInput[]
    upsert?: StockMovementUpsertWithWhereUniqueWithoutMedicationInput | StockMovementUpsertWithWhereUniqueWithoutMedicationInput[]
    createMany?: StockMovementCreateManyMedicationInputEnvelope
    set?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    disconnect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    delete?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    connect?: StockMovementWhereUniqueInput | StockMovementWhereUniqueInput[]
    update?: StockMovementUpdateWithWhereUniqueWithoutMedicationInput | StockMovementUpdateWithWhereUniqueWithoutMedicationInput[]
    updateMany?: StockMovementUpdateManyWithWhereWithoutMedicationInput | StockMovementUpdateManyWithWhereWithoutMedicationInput[]
    deleteMany?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<StudentCreateWithoutMedicationsInput, StudentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicationsInput
    connect?: StudentWhereUniqueInput
  }

  export type ParentCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<ParentCreateWithoutMedicationsInput, ParentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutMedicationsInput
    connect?: ParentWhereUniqueInput
  }

  export type MedicationCreateNestedOneWithoutStudentMedicationsInput = {
    create?: XOR<MedicationCreateWithoutStudentMedicationsInput, MedicationUncheckedCreateWithoutStudentMedicationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutStudentMedicationsInput
    connect?: MedicationWhereUniqueInput
  }

  export type EnumMedicationStatusFieldUpdateOperationsInput = {
    set?: $Enums.MedicationStatus
  }

  export type StudentUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<StudentCreateWithoutMedicationsInput, StudentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicationsInput
    upsert?: StudentUpsertWithoutMedicationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMedicationsInput, StudentUpdateWithoutMedicationsInput>, StudentUncheckedUpdateWithoutMedicationsInput>
  }

  export type ParentUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<ParentCreateWithoutMedicationsInput, ParentUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: ParentCreateOrConnectWithoutMedicationsInput
    upsert?: ParentUpsertWithoutMedicationsInput
    connect?: ParentWhereUniqueInput
    update?: XOR<XOR<ParentUpdateToOneWithWhereWithoutMedicationsInput, ParentUpdateWithoutMedicationsInput>, ParentUncheckedUpdateWithoutMedicationsInput>
  }

  export type MedicationUpdateOneRequiredWithoutStudentMedicationsNestedInput = {
    create?: XOR<MedicationCreateWithoutStudentMedicationsInput, MedicationUncheckedCreateWithoutStudentMedicationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutStudentMedicationsInput
    upsert?: MedicationUpsertWithoutStudentMedicationsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutStudentMedicationsInput, MedicationUpdateWithoutStudentMedicationsInput>, MedicationUncheckedUpdateWithoutStudentMedicationsInput>
  }

  export type MedicalEventCreateNestedOneWithoutMedicationsUsedInput = {
    create?: XOR<MedicalEventCreateWithoutMedicationsUsedInput, MedicalEventUncheckedCreateWithoutMedicationsUsedInput>
    connectOrCreate?: MedicalEventCreateOrConnectWithoutMedicationsUsedInput
    connect?: MedicalEventWhereUniqueInput
  }

  export type MedicationCreateNestedOneWithoutMedicalEventMedicationsInput = {
    create?: XOR<MedicationCreateWithoutMedicalEventMedicationsInput, MedicationUncheckedCreateWithoutMedicalEventMedicationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutMedicalEventMedicationsInput
    connect?: MedicationWhereUniqueInput
  }

  export type MedicalEventUpdateOneRequiredWithoutMedicationsUsedNestedInput = {
    create?: XOR<MedicalEventCreateWithoutMedicationsUsedInput, MedicalEventUncheckedCreateWithoutMedicationsUsedInput>
    connectOrCreate?: MedicalEventCreateOrConnectWithoutMedicationsUsedInput
    upsert?: MedicalEventUpsertWithoutMedicationsUsedInput
    connect?: MedicalEventWhereUniqueInput
    update?: XOR<XOR<MedicalEventUpdateToOneWithWhereWithoutMedicationsUsedInput, MedicalEventUpdateWithoutMedicationsUsedInput>, MedicalEventUncheckedUpdateWithoutMedicationsUsedInput>
  }

  export type MedicationUpdateOneRequiredWithoutMedicalEventMedicationsNestedInput = {
    create?: XOR<MedicationCreateWithoutMedicalEventMedicationsInput, MedicationUncheckedCreateWithoutMedicalEventMedicationsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutMedicalEventMedicationsInput
    upsert?: MedicationUpsertWithoutMedicalEventMedicationsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutMedicalEventMedicationsInput, MedicationUpdateWithoutMedicalEventMedicationsInput>, MedicationUncheckedUpdateWithoutMedicalEventMedicationsInput>
  }

  export type MedicationCreateNestedOneWithoutStockMovementsInput = {
    create?: XOR<MedicationCreateWithoutStockMovementsInput, MedicationUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutStockMovementsInput
    connect?: MedicationWhereUniqueInput
  }

  export type MedicationUpdateOneRequiredWithoutStockMovementsNestedInput = {
    create?: XOR<MedicationCreateWithoutStockMovementsInput, MedicationUncheckedCreateWithoutStockMovementsInput>
    connectOrCreate?: MedicationCreateOrConnectWithoutStockMovementsInput
    upsert?: MedicationUpsertWithoutStockMovementsInput
    connect?: MedicationWhereUniqueInput
    update?: XOR<XOR<MedicationUpdateToOneWithWhereWithoutStockMovementsInput, MedicationUpdateWithoutStockMovementsInput>, MedicationUncheckedUpdateWithoutStockMovementsInput>
  }

  export type VaccinationCampaignCreatetargetGradesInput = {
    set: string[]
  }

  export type VaccinationCreateNestedManyWithoutCampaignInput = {
    create?: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput> | VaccinationCreateWithoutCampaignInput[] | VaccinationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutCampaignInput | VaccinationCreateOrConnectWithoutCampaignInput[]
    createMany?: VaccinationCreateManyCampaignInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutVaccinationCampaignInput = {
    create?: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput> | NotificationCreateWithoutVaccinationCampaignInput[] | NotificationUncheckedCreateWithoutVaccinationCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVaccinationCampaignInput | NotificationCreateOrConnectWithoutVaccinationCampaignInput[]
    createMany?: NotificationCreateManyVaccinationCampaignInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VaccinationUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput> | VaccinationCreateWithoutCampaignInput[] | VaccinationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutCampaignInput | VaccinationCreateOrConnectWithoutCampaignInput[]
    createMany?: VaccinationCreateManyCampaignInputEnvelope
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutVaccinationCampaignInput = {
    create?: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput> | NotificationCreateWithoutVaccinationCampaignInput[] | NotificationUncheckedCreateWithoutVaccinationCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVaccinationCampaignInput | NotificationCreateOrConnectWithoutVaccinationCampaignInput[]
    createMany?: NotificationCreateManyVaccinationCampaignInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type VaccinationCampaignUpdatetargetGradesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type VaccinationUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput> | VaccinationCreateWithoutCampaignInput[] | VaccinationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutCampaignInput | VaccinationCreateOrConnectWithoutCampaignInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutCampaignInput | VaccinationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: VaccinationCreateManyCampaignInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutCampaignInput | VaccinationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutCampaignInput | VaccinationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutVaccinationCampaignNestedInput = {
    create?: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput> | NotificationCreateWithoutVaccinationCampaignInput[] | NotificationUncheckedCreateWithoutVaccinationCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVaccinationCampaignInput | NotificationCreateOrConnectWithoutVaccinationCampaignInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVaccinationCampaignInput | NotificationUpsertWithWhereUniqueWithoutVaccinationCampaignInput[]
    createMany?: NotificationCreateManyVaccinationCampaignInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVaccinationCampaignInput | NotificationUpdateWithWhereUniqueWithoutVaccinationCampaignInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVaccinationCampaignInput | NotificationUpdateManyWithWhereWithoutVaccinationCampaignInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type VaccinationUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput> | VaccinationCreateWithoutCampaignInput[] | VaccinationUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: VaccinationCreateOrConnectWithoutCampaignInput | VaccinationCreateOrConnectWithoutCampaignInput[]
    upsert?: VaccinationUpsertWithWhereUniqueWithoutCampaignInput | VaccinationUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: VaccinationCreateManyCampaignInputEnvelope
    set?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    disconnect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    delete?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    connect?: VaccinationWhereUniqueInput | VaccinationWhereUniqueInput[]
    update?: VaccinationUpdateWithWhereUniqueWithoutCampaignInput | VaccinationUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: VaccinationUpdateManyWithWhereWithoutCampaignInput | VaccinationUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutVaccinationCampaignNestedInput = {
    create?: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput> | NotificationCreateWithoutVaccinationCampaignInput[] | NotificationUncheckedCreateWithoutVaccinationCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutVaccinationCampaignInput | NotificationCreateOrConnectWithoutVaccinationCampaignInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutVaccinationCampaignInput | NotificationUpsertWithWhereUniqueWithoutVaccinationCampaignInput[]
    createMany?: NotificationCreateManyVaccinationCampaignInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutVaccinationCampaignInput | NotificationUpdateWithWhereUniqueWithoutVaccinationCampaignInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutVaccinationCampaignInput | NotificationUpdateManyWithWhereWithoutVaccinationCampaignInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<StudentCreateWithoutVaccinationsInput, StudentUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutVaccinationsInput
    connect?: StudentWhereUniqueInput
  }

  export type VaccinationCampaignCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<VaccinationCampaignCreateWithoutVaccinationsInput, VaccinationCampaignUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: VaccinationCampaignCreateOrConnectWithoutVaccinationsInput
    connect?: VaccinationCampaignWhereUniqueInput
  }

  export type SchoolNurseCreateNestedOneWithoutVaccinationsInput = {
    create?: XOR<SchoolNurseCreateWithoutVaccinationsInput, SchoolNurseUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutVaccinationsInput
    connect?: SchoolNurseWhereUniqueInput
  }

  export type EnumVaccinationStatusFieldUpdateOperationsInput = {
    set?: $Enums.VaccinationStatus
  }

  export type StudentUpdateOneRequiredWithoutVaccinationsNestedInput = {
    create?: XOR<StudentCreateWithoutVaccinationsInput, StudentUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutVaccinationsInput
    upsert?: StudentUpsertWithoutVaccinationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutVaccinationsInput, StudentUpdateWithoutVaccinationsInput>, StudentUncheckedUpdateWithoutVaccinationsInput>
  }

  export type VaccinationCampaignUpdateOneRequiredWithoutVaccinationsNestedInput = {
    create?: XOR<VaccinationCampaignCreateWithoutVaccinationsInput, VaccinationCampaignUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: VaccinationCampaignCreateOrConnectWithoutVaccinationsInput
    upsert?: VaccinationCampaignUpsertWithoutVaccinationsInput
    connect?: VaccinationCampaignWhereUniqueInput
    update?: XOR<XOR<VaccinationCampaignUpdateToOneWithWhereWithoutVaccinationsInput, VaccinationCampaignUpdateWithoutVaccinationsInput>, VaccinationCampaignUncheckedUpdateWithoutVaccinationsInput>
  }

  export type SchoolNurseUpdateOneWithoutVaccinationsNestedInput = {
    create?: XOR<SchoolNurseCreateWithoutVaccinationsInput, SchoolNurseUncheckedCreateWithoutVaccinationsInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutVaccinationsInput
    upsert?: SchoolNurseUpsertWithoutVaccinationsInput
    disconnect?: boolean
    delete?: SchoolNurseWhereInput | boolean
    connect?: SchoolNurseWhereUniqueInput
    update?: XOR<XOR<SchoolNurseUpdateToOneWithWhereWithoutVaccinationsInput, SchoolNurseUpdateWithoutVaccinationsInput>, SchoolNurseUncheckedUpdateWithoutVaccinationsInput>
  }

  export type MedicalCheckCampaignCreatecheckTypesInput = {
    set: string[]
  }

  export type MedicalCheckCampaignCreatetargetGradesInput = {
    set: string[]
  }

  export type MedicalCheckCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput> | MedicalCheckCreateWithoutCampaignInput[] | MedicalCheckUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutCampaignInput | MedicalCheckCreateOrConnectWithoutCampaignInput[]
    createMany?: MedicalCheckCreateManyCampaignInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutMedicalCheckCampaignInput = {
    create?: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput> | NotificationCreateWithoutMedicalCheckCampaignInput[] | NotificationUncheckedCreateWithoutMedicalCheckCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMedicalCheckCampaignInput | NotificationCreateOrConnectWithoutMedicalCheckCampaignInput[]
    createMany?: NotificationCreateManyMedicalCheckCampaignInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MedicalCheckUncheckedCreateNestedManyWithoutCampaignInput = {
    create?: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput> | MedicalCheckCreateWithoutCampaignInput[] | MedicalCheckUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutCampaignInput | MedicalCheckCreateOrConnectWithoutCampaignInput[]
    createMany?: MedicalCheckCreateManyCampaignInputEnvelope
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutMedicalCheckCampaignInput = {
    create?: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput> | NotificationCreateWithoutMedicalCheckCampaignInput[] | NotificationUncheckedCreateWithoutMedicalCheckCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMedicalCheckCampaignInput | NotificationCreateOrConnectWithoutMedicalCheckCampaignInput[]
    createMany?: NotificationCreateManyMedicalCheckCampaignInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MedicalCheckCampaignUpdatecheckTypesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MedicalCheckCampaignUpdatetargetGradesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type MedicalCheckUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput> | MedicalCheckCreateWithoutCampaignInput[] | MedicalCheckUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutCampaignInput | MedicalCheckCreateOrConnectWithoutCampaignInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutCampaignInput | MedicalCheckUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MedicalCheckCreateManyCampaignInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutCampaignInput | MedicalCheckUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutCampaignInput | MedicalCheckUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutMedicalCheckCampaignNestedInput = {
    create?: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput> | NotificationCreateWithoutMedicalCheckCampaignInput[] | NotificationUncheckedCreateWithoutMedicalCheckCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMedicalCheckCampaignInput | NotificationCreateOrConnectWithoutMedicalCheckCampaignInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMedicalCheckCampaignInput | NotificationUpsertWithWhereUniqueWithoutMedicalCheckCampaignInput[]
    createMany?: NotificationCreateManyMedicalCheckCampaignInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMedicalCheckCampaignInput | NotificationUpdateWithWhereUniqueWithoutMedicalCheckCampaignInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMedicalCheckCampaignInput | NotificationUpdateManyWithWhereWithoutMedicalCheckCampaignInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MedicalCheckUncheckedUpdateManyWithoutCampaignNestedInput = {
    create?: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput> | MedicalCheckCreateWithoutCampaignInput[] | MedicalCheckUncheckedCreateWithoutCampaignInput[]
    connectOrCreate?: MedicalCheckCreateOrConnectWithoutCampaignInput | MedicalCheckCreateOrConnectWithoutCampaignInput[]
    upsert?: MedicalCheckUpsertWithWhereUniqueWithoutCampaignInput | MedicalCheckUpsertWithWhereUniqueWithoutCampaignInput[]
    createMany?: MedicalCheckCreateManyCampaignInputEnvelope
    set?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    disconnect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    delete?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    connect?: MedicalCheckWhereUniqueInput | MedicalCheckWhereUniqueInput[]
    update?: MedicalCheckUpdateWithWhereUniqueWithoutCampaignInput | MedicalCheckUpdateWithWhereUniqueWithoutCampaignInput[]
    updateMany?: MedicalCheckUpdateManyWithWhereWithoutCampaignInput | MedicalCheckUpdateManyWithWhereWithoutCampaignInput[]
    deleteMany?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutMedicalCheckCampaignNestedInput = {
    create?: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput> | NotificationCreateWithoutMedicalCheckCampaignInput[] | NotificationUncheckedCreateWithoutMedicalCheckCampaignInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMedicalCheckCampaignInput | NotificationCreateOrConnectWithoutMedicalCheckCampaignInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMedicalCheckCampaignInput | NotificationUpsertWithWhereUniqueWithoutMedicalCheckCampaignInput[]
    createMany?: NotificationCreateManyMedicalCheckCampaignInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMedicalCheckCampaignInput | NotificationUpdateWithWhereUniqueWithoutMedicalCheckCampaignInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMedicalCheckCampaignInput | NotificationUpdateManyWithWhereWithoutMedicalCheckCampaignInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutMedicalChecksInput = {
    create?: XOR<StudentCreateWithoutMedicalChecksInput, StudentUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalChecksInput
    connect?: StudentWhereUniqueInput
  }

  export type MedicalCheckCampaignCreateNestedOneWithoutMedicalChecksInput = {
    create?: XOR<MedicalCheckCampaignCreateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: MedicalCheckCampaignCreateOrConnectWithoutMedicalChecksInput
    connect?: MedicalCheckCampaignWhereUniqueInput
  }

  export type SchoolNurseCreateNestedOneWithoutMedicalChecksInput = {
    create?: XOR<SchoolNurseCreateWithoutMedicalChecksInput, SchoolNurseUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutMedicalChecksInput
    connect?: SchoolNurseWhereUniqueInput
  }

  export type EnumMedicalCheckStatusFieldUpdateOperationsInput = {
    set?: $Enums.MedicalCheckStatus
  }

  export type StudentUpdateOneRequiredWithoutMedicalChecksNestedInput = {
    create?: XOR<StudentCreateWithoutMedicalChecksInput, StudentUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMedicalChecksInput
    upsert?: StudentUpsertWithoutMedicalChecksInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMedicalChecksInput, StudentUpdateWithoutMedicalChecksInput>, StudentUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type MedicalCheckCampaignUpdateOneRequiredWithoutMedicalChecksNestedInput = {
    create?: XOR<MedicalCheckCampaignCreateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: MedicalCheckCampaignCreateOrConnectWithoutMedicalChecksInput
    upsert?: MedicalCheckCampaignUpsertWithoutMedicalChecksInput
    connect?: MedicalCheckCampaignWhereUniqueInput
    update?: XOR<XOR<MedicalCheckCampaignUpdateToOneWithWhereWithoutMedicalChecksInput, MedicalCheckCampaignUpdateWithoutMedicalChecksInput>, MedicalCheckCampaignUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type SchoolNurseUpdateOneWithoutMedicalChecksNestedInput = {
    create?: XOR<SchoolNurseCreateWithoutMedicalChecksInput, SchoolNurseUncheckedCreateWithoutMedicalChecksInput>
    connectOrCreate?: SchoolNurseCreateOrConnectWithoutMedicalChecksInput
    upsert?: SchoolNurseUpsertWithoutMedicalChecksInput
    disconnect?: boolean
    delete?: SchoolNurseWhereInput | boolean
    connect?: SchoolNurseWhereUniqueInput
    update?: XOR<XOR<SchoolNurseUpdateToOneWithWhereWithoutMedicalChecksInput, SchoolNurseUpdateWithoutMedicalChecksInput>, SchoolNurseUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type MedicalEventCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<MedicalEventCreateWithoutDocumentsInput, MedicalEventUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MedicalEventCreateOrConnectWithoutDocumentsInput
    connect?: MedicalEventWhereUniqueInput
  }

  export type MedicalEventUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<MedicalEventCreateWithoutDocumentsInput, MedicalEventUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: MedicalEventCreateOrConnectWithoutDocumentsInput
    upsert?: MedicalEventUpsertWithoutDocumentsInput
    disconnect?: boolean
    delete?: MedicalEventWhereInput | boolean
    connect?: MedicalEventWhereUniqueInput
    update?: XOR<XOR<MedicalEventUpdateToOneWithWhereWithoutDocumentsInput, MedicalEventUpdateWithoutDocumentsInput>, MedicalEventUncheckedUpdateWithoutDocumentsInput>
  }

  export type PostCreatetagsInput = {
    set: string[]
  }

  export type usersCreateNestedOneWithoutCreatedPostsInput = {
    create?: XOR<usersCreateWithoutCreatedPostsInput, usersUncheckedCreateWithoutCreatedPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedPostsInput
    connect?: usersWhereUniqueInput
  }

  export type PostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type usersUpdateOneRequiredWithoutCreatedPostsNestedInput = {
    create?: XOR<usersCreateWithoutCreatedPostsInput, usersUncheckedCreateWithoutCreatedPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCreatedPostsInput
    upsert?: usersUpsertWithoutCreatedPostsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCreatedPostsInput, usersUpdateWithoutCreatedPostsInput>, usersUncheckedUpdateWithoutCreatedPostsInput>
  }

  export type usersCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type VaccinationCampaignCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<VaccinationCampaignCreateWithoutNotificationsInput, VaccinationCampaignUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VaccinationCampaignCreateOrConnectWithoutNotificationsInput
    connect?: VaccinationCampaignWhereUniqueInput
  }

  export type MedicalCheckCampaignCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<MedicalCheckCampaignCreateWithoutNotificationsInput, MedicalCheckCampaignUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MedicalCheckCampaignCreateOrConnectWithoutNotificationsInput
    connect?: MedicalCheckCampaignWhereUniqueInput
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type usersUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutNotificationsInput
    upsert?: usersUpsertWithoutNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutNotificationsInput, usersUpdateWithoutNotificationsInput>, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type VaccinationCampaignUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<VaccinationCampaignCreateWithoutNotificationsInput, VaccinationCampaignUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: VaccinationCampaignCreateOrConnectWithoutNotificationsInput
    upsert?: VaccinationCampaignUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: VaccinationCampaignWhereInput | boolean
    connect?: VaccinationCampaignWhereUniqueInput
    update?: XOR<XOR<VaccinationCampaignUpdateToOneWithWhereWithoutNotificationsInput, VaccinationCampaignUpdateWithoutNotificationsInput>, VaccinationCampaignUncheckedUpdateWithoutNotificationsInput>
  }

  export type MedicalCheckCampaignUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<MedicalCheckCampaignCreateWithoutNotificationsInput, MedicalCheckCampaignUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MedicalCheckCampaignCreateOrConnectWithoutNotificationsInput
    upsert?: MedicalCheckCampaignUpsertWithoutNotificationsInput
    disconnect?: boolean
    delete?: MedicalCheckCampaignWhereInput | boolean
    connect?: MedicalCheckCampaignWhereUniqueInput
    update?: XOR<XOR<MedicalCheckCampaignUpdateToOneWithWhereWithoutNotificationsInput, MedicalCheckCampaignUpdateWithoutNotificationsInput>, MedicalCheckCampaignUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<usersCreateWithoutAuditLogsInput, usersUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditLogsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<usersCreateWithoutAuditLogsInput, usersUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: usersCreateOrConnectWithoutAuditLogsInput
    upsert?: usersUpsertWithoutAuditLogsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAuditLogsInput, usersUpdateWithoutAuditLogsInput>, usersUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumMedicalEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventType | EnumMedicalEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventTypeFilter<$PrismaModel> | $Enums.MedicalEventType
  }

  export type NestedEnumMedicalEventStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventStatus | EnumMedicalEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventStatusFilter<$PrismaModel> | $Enums.MedicalEventStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedEnumMedicalEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventType | EnumMedicalEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventType[] | ListEnumMedicalEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.MedicalEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalEventTypeFilter<$PrismaModel>
    _max?: NestedEnumMedicalEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumMedicalEventStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalEventStatus | EnumMedicalEventStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalEventStatus[] | ListEnumMedicalEventStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalEventStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalEventStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalEventStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalEventStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMedicationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusFilter<$PrismaModel> | $Enums.MedicationStatus
  }

  export type NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicationStatus | EnumMedicationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicationStatus[] | ListEnumMedicationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicationStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicationStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicationStatusFilter<$PrismaModel>
  }

  export type NestedEnumVaccinationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VaccinationStatus | EnumVaccinationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVaccinationStatusFilter<$PrismaModel> | $Enums.VaccinationStatus
  }

  export type NestedEnumVaccinationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VaccinationStatus | EnumVaccinationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.VaccinationStatus[] | ListEnumVaccinationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumVaccinationStatusWithAggregatesFilter<$PrismaModel> | $Enums.VaccinationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVaccinationStatusFilter<$PrismaModel>
    _max?: NestedEnumVaccinationStatusFilter<$PrismaModel>
  }

  export type NestedEnumMedicalCheckStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCheckStatus | EnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCheckStatusFilter<$PrismaModel> | $Enums.MedicalCheckStatus
  }

  export type NestedEnumMedicalCheckStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MedicalCheckStatus | EnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MedicalCheckStatus[] | ListEnumMedicalCheckStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMedicalCheckStatusWithAggregatesFilter<$PrismaModel> | $Enums.MedicalCheckStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMedicalCheckStatusFilter<$PrismaModel>
    _max?: NestedEnumMedicalCheckStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type ParentCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentCreateNestedManyWithoutParentInput
    medications?: StudentMedicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutUserInput = {
    id?: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentUncheckedCreateNestedManyWithoutParentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutUserInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
  }

  export type SchoolNurseCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    handledEvents?: MedicalEventCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUncheckedCreateWithoutUserInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    handledEvents?: MedicalEventUncheckedCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseCreateOrConnectWithoutUserInput = {
    where: SchoolNurseWhereUniqueInput
    create: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
  }

  export type ManagerCreateWithoutUserInput = {
    id?: string
    department?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerUncheckedCreateWithoutUserInput = {
    id?: string
    department?: string | null
    position?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ManagerCreateOrConnectWithoutUserInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
  }

  export type AdminCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUncheckedCreateWithoutUserInput = {
    id?: string
    permissions?: AdminCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminCreateOrConnectWithoutUserInput = {
    where: AdminWhereUniqueInput
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
  }

  export type MedicalEventCreateWithoutCreatedByInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalEventsInput
    nurse?: SchoolNurseCreateNestedOneWithoutHandledEventsInput
    medicationsUsed?: MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateWithoutCreatedByInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventCreateOrConnectWithoutCreatedByInput = {
    where: MedicalEventWhereUniqueInput
    create: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput>
  }

  export type MedicalEventCreateManyCreatedByInputEnvelope = {
    data: MedicalEventCreateManyCreatedByInput | MedicalEventCreateManyCreatedByInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    vaccinationCampaign?: VaccinationCampaignCreateNestedOneWithoutNotificationsInput
    medicalCheckCampaign?: MedicalCheckCampaignCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    vaccinationCampaignId?: string | null
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutUserInput = {
    update: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
    create: XOR<ParentCreateWithoutUserInput, ParentUncheckedCreateWithoutUserInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutUserInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutUserInput, ParentUncheckedUpdateWithoutUserInput>
  }

  export type ParentUpdateWithoutUserInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUpdateManyWithoutParentNestedInput
    medications?: StudentMedicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutUserInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type SchoolNurseUpsertWithoutUserInput = {
    update: XOR<SchoolNurseUpdateWithoutUserInput, SchoolNurseUncheckedUpdateWithoutUserInput>
    create: XOR<SchoolNurseCreateWithoutUserInput, SchoolNurseUncheckedCreateWithoutUserInput>
    where?: SchoolNurseWhereInput
  }

  export type SchoolNurseUpdateToOneWithWhereWithoutUserInput = {
    where?: SchoolNurseWhereInput
    data: XOR<SchoolNurseUpdateWithoutUserInput, SchoolNurseUncheckedUpdateWithoutUserInput>
  }

  export type SchoolNurseUpdateWithoutUserInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledEvents?: MedicalEventUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseUncheckedUpdateWithoutUserInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledEvents?: MedicalEventUncheckedUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type ManagerUpsertWithoutUserInput = {
    update: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateWithoutUserInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerUncheckedUpdateWithoutUserInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUpsertWithoutUserInput = {
    update: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
    create: XOR<AdminCreateWithoutUserInput, AdminUncheckedCreateWithoutUserInput>
    where?: AdminWhereInput
  }

  export type AdminUpdateToOneWithWhereWithoutUserInput = {
    where?: AdminWhereInput
    data: XOR<AdminUpdateWithoutUserInput, AdminUncheckedUpdateWithoutUserInput>
  }

  export type AdminUpdateWithoutUserInput = {
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUncheckedUpdateWithoutUserInput = {
    permissions?: AdminUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: StringFilter<"Post"> | string
    authorId?: StringFilter<"Post"> | string
    title?: StringFilter<"Post"> | string
    content?: StringFilter<"Post"> | string
    excerpt?: StringNullableFilter<"Post"> | string | null
    coverImage?: StringNullableFilter<"Post"> | string | null
    category?: StringNullableFilter<"Post"> | string | null
    tags?: StringNullableListFilter<"Post">
    isPublished?: BoolFilter<"Post"> | boolean
    publishedAt?: DateTimeNullableFilter<"Post"> | Date | string | null
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type MedicalEventUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: MedicalEventWhereUniqueInput
    update: XOR<MedicalEventUpdateWithoutCreatedByInput, MedicalEventUncheckedUpdateWithoutCreatedByInput>
    create: XOR<MedicalEventCreateWithoutCreatedByInput, MedicalEventUncheckedCreateWithoutCreatedByInput>
  }

  export type MedicalEventUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: MedicalEventWhereUniqueInput
    data: XOR<MedicalEventUpdateWithoutCreatedByInput, MedicalEventUncheckedUpdateWithoutCreatedByInput>
  }

  export type MedicalEventUpdateManyWithWhereWithoutCreatedByInput = {
    where: MedicalEventScalarWhereInput
    data: XOR<MedicalEventUpdateManyMutationInput, MedicalEventUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type MedicalEventScalarWhereInput = {
    AND?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
    OR?: MedicalEventScalarWhereInput[]
    NOT?: MedicalEventScalarWhereInput | MedicalEventScalarWhereInput[]
    id?: StringFilter<"MedicalEvent"> | string
    studentId?: StringFilter<"MedicalEvent"> | string
    nurseId?: StringNullableFilter<"MedicalEvent"> | string | null
    createdById?: StringFilter<"MedicalEvent"> | string
    title?: StringFilter<"MedicalEvent"> | string
    description?: StringFilter<"MedicalEvent"> | string
    type?: EnumMedicalEventTypeFilter<"MedicalEvent"> | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFilter<"MedicalEvent"> | $Enums.MedicalEventStatus
    severity?: StringFilter<"MedicalEvent"> | string
    location?: StringNullableFilter<"MedicalEvent"> | string | null
    symptoms?: StringNullableListFilter<"MedicalEvent">
    treatment?: StringNullableFilter<"MedicalEvent"> | string | null
    outcome?: StringNullableFilter<"MedicalEvent"> | string | null
    occurredAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"MedicalEvent"> | Date | string | null
    createdAt?: DateTimeFilter<"MedicalEvent"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalEvent"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    vaccinationCampaignId?: StringNullableFilter<"Notification"> | string | null
    medicalCheckCampaignId?: StringNullableFilter<"Notification"> | string | null
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type usersCreateWithoutStudentProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutStudentProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutStudentProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutStudentProfileInput, usersUncheckedCreateWithoutStudentProfileInput>
  }

  export type StudentParentCreateWithoutStudentInput = {
    id?: string
    relationship: string
    isPrimary?: boolean
    parent: ParentCreateNestedOneWithoutChildrenInput
  }

  export type StudentParentUncheckedCreateWithoutStudentInput = {
    id?: string
    parentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type StudentParentCreateOrConnectWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentCreateManyStudentInputEnvelope = {
    data: StudentParentCreateManyStudentInput | StudentParentCreateManyStudentInput[]
  }

  export type HealthProfileCreateWithoutStudentInput = {
    id?: string
    allergies?: HealthProfileCreateallergiesInput | string[]
    chronicDiseases?: HealthProfileCreatechronicDiseasesInput | string[]
    medications?: HealthProfileCreatemedicationsInput | string[]
    treatmentHistory?: string | null
    vision?: string | null
    hearing?: string | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUncheckedCreateWithoutStudentInput = {
    id?: string
    allergies?: HealthProfileCreateallergiesInput | string[]
    chronicDiseases?: HealthProfileCreatechronicDiseasesInput | string[]
    medications?: HealthProfileCreatemedicationsInput | string[]
    treatmentHistory?: string | null
    vision?: string | null
    hearing?: string | null
    height?: number | null
    weight?: number | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileCreateOrConnectWithoutStudentInput = {
    where: HealthProfileWhereUniqueInput
    create: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
  }

  export type MedicalEventCreateWithoutStudentInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nurse?: SchoolNurseCreateNestedOneWithoutHandledEventsInput
    createdBy: usersCreateNestedOneWithoutCreatedEventsInput
    medicationsUsed?: MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateWithoutStudentInput = {
    id?: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventCreateOrConnectWithoutStudentInput = {
    where: MedicalEventWhereUniqueInput
    create: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput>
  }

  export type MedicalEventCreateManyStudentInputEnvelope = {
    data: MedicalEventCreateManyStudentInput | MedicalEventCreateManyStudentInput[]
  }

  export type VaccinationCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: VaccinationCampaignCreateNestedOneWithoutVaccinationsInput
    nurse?: SchoolNurseCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateWithoutStudentInput = {
    id?: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutStudentInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput>
  }

  export type VaccinationCreateManyStudentInputEnvelope = {
    data: VaccinationCreateManyStudentInput | VaccinationCreateManyStudentInput[]
  }

  export type MedicalCheckCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    campaign: MedicalCheckCampaignCreateNestedOneWithoutMedicalChecksInput
    nurse?: SchoolNurseCreateNestedOneWithoutMedicalChecksInput
  }

  export type MedicalCheckUncheckedCreateWithoutStudentInput = {
    id?: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCreateOrConnectWithoutStudentInput = {
    where: MedicalCheckWhereUniqueInput
    create: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput>
  }

  export type MedicalCheckCreateManyStudentInputEnvelope = {
    data: MedicalCheckCreateManyStudentInput | MedicalCheckCreateManyStudentInput[]
  }

  export type StudentMedicationCreateWithoutStudentInput = {
    id?: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    parent: ParentCreateNestedOneWithoutMedicationsInput
    medication: MedicationCreateNestedOneWithoutStudentMedicationsInput
  }

  export type StudentMedicationUncheckedCreateWithoutStudentInput = {
    id?: string
    parentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationCreateOrConnectWithoutStudentInput = {
    where: StudentMedicationWhereUniqueInput
    create: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput>
  }

  export type StudentMedicationCreateManyStudentInputEnvelope = {
    data: StudentMedicationCreateManyStudentInput | StudentMedicationCreateManyStudentInput[]
  }

  export type usersUpsertWithoutStudentProfileInput = {
    update: XOR<usersUpdateWithoutStudentProfileInput, usersUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<usersCreateWithoutStudentProfileInput, usersUncheckedCreateWithoutStudentProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutStudentProfileInput, usersUncheckedUpdateWithoutStudentProfileInput>
  }

  export type usersUpdateWithoutStudentProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutStudentProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentParentUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentParentCreateWithoutStudentInput, StudentParentUncheckedCreateWithoutStudentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutStudentInput, StudentParentUncheckedUpdateWithoutStudentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutStudentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentParentScalarWhereInput = {
    AND?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    OR?: StudentParentScalarWhereInput[]
    NOT?: StudentParentScalarWhereInput | StudentParentScalarWhereInput[]
    id?: StringFilter<"StudentParent"> | string
    studentId?: StringFilter<"StudentParent"> | string
    parentId?: StringFilter<"StudentParent"> | string
    relationship?: StringFilter<"StudentParent"> | string
    isPrimary?: BoolFilter<"StudentParent"> | boolean
  }

  export type HealthProfileUpsertWithoutStudentInput = {
    update: XOR<HealthProfileUpdateWithoutStudentInput, HealthProfileUncheckedUpdateWithoutStudentInput>
    create: XOR<HealthProfileCreateWithoutStudentInput, HealthProfileUncheckedCreateWithoutStudentInput>
    where?: HealthProfileWhereInput
  }

  export type HealthProfileUpdateToOneWithWhereWithoutStudentInput = {
    where?: HealthProfileWhereInput
    data: XOR<HealthProfileUpdateWithoutStudentInput, HealthProfileUncheckedUpdateWithoutStudentInput>
  }

  export type HealthProfileUpdateWithoutStudentInput = {
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileUncheckedUpdateWithoutStudentInput = {
    allergies?: HealthProfileUpdateallergiesInput | string[]
    chronicDiseases?: HealthProfileUpdatechronicDiseasesInput | string[]
    medications?: HealthProfileUpdatemedicationsInput | string[]
    treatmentHistory?: NullableStringFieldUpdateOperationsInput | string | null
    vision?: NullableStringFieldUpdateOperationsInput | string | null
    hearing?: NullableStringFieldUpdateOperationsInput | string | null
    height?: NullableFloatFieldUpdateOperationsInput | number | null
    weight?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventUpsertWithWhereUniqueWithoutStudentInput = {
    where: MedicalEventWhereUniqueInput
    update: XOR<MedicalEventUpdateWithoutStudentInput, MedicalEventUncheckedUpdateWithoutStudentInput>
    create: XOR<MedicalEventCreateWithoutStudentInput, MedicalEventUncheckedCreateWithoutStudentInput>
  }

  export type MedicalEventUpdateWithWhereUniqueWithoutStudentInput = {
    where: MedicalEventWhereUniqueInput
    data: XOR<MedicalEventUpdateWithoutStudentInput, MedicalEventUncheckedUpdateWithoutStudentInput>
  }

  export type MedicalEventUpdateManyWithWhereWithoutStudentInput = {
    where: MedicalEventScalarWhereInput
    data: XOR<MedicalEventUpdateManyMutationInput, MedicalEventUncheckedUpdateManyWithoutStudentInput>
  }

  export type VaccinationUpsertWithWhereUniqueWithoutStudentInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutStudentInput, VaccinationUncheckedUpdateWithoutStudentInput>
    create: XOR<VaccinationCreateWithoutStudentInput, VaccinationUncheckedCreateWithoutStudentInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutStudentInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutStudentInput, VaccinationUncheckedUpdateWithoutStudentInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutStudentInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutStudentInput>
  }

  export type VaccinationScalarWhereInput = {
    AND?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    OR?: VaccinationScalarWhereInput[]
    NOT?: VaccinationScalarWhereInput | VaccinationScalarWhereInput[]
    id?: StringFilter<"Vaccination"> | string
    studentId?: StringFilter<"Vaccination"> | string
    campaignId?: StringFilter<"Vaccination"> | string
    nurseId?: StringNullableFilter<"Vaccination"> | string | null
    status?: EnumVaccinationStatusFilter<"Vaccination"> | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFilter<"Vaccination"> | Date | string
    administeredDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    dose?: StringNullableFilter<"Vaccination"> | string | null
    batch?: StringNullableFilter<"Vaccination"> | string | null
    sideEffects?: StringNullableFilter<"Vaccination"> | string | null
    notes?: StringNullableFilter<"Vaccination"> | string | null
    parentConsent?: BoolFilter<"Vaccination"> | boolean
    consentDate?: DateTimeNullableFilter<"Vaccination"> | Date | string | null
    createdAt?: DateTimeFilter<"Vaccination"> | Date | string
    updatedAt?: DateTimeFilter<"Vaccination"> | Date | string
  }

  export type MedicalCheckUpsertWithWhereUniqueWithoutStudentInput = {
    where: MedicalCheckWhereUniqueInput
    update: XOR<MedicalCheckUpdateWithoutStudentInput, MedicalCheckUncheckedUpdateWithoutStudentInput>
    create: XOR<MedicalCheckCreateWithoutStudentInput, MedicalCheckUncheckedCreateWithoutStudentInput>
  }

  export type MedicalCheckUpdateWithWhereUniqueWithoutStudentInput = {
    where: MedicalCheckWhereUniqueInput
    data: XOR<MedicalCheckUpdateWithoutStudentInput, MedicalCheckUncheckedUpdateWithoutStudentInput>
  }

  export type MedicalCheckUpdateManyWithWhereWithoutStudentInput = {
    where: MedicalCheckScalarWhereInput
    data: XOR<MedicalCheckUpdateManyMutationInput, MedicalCheckUncheckedUpdateManyWithoutStudentInput>
  }

  export type MedicalCheckScalarWhereInput = {
    AND?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
    OR?: MedicalCheckScalarWhereInput[]
    NOT?: MedicalCheckScalarWhereInput | MedicalCheckScalarWhereInput[]
    id?: StringFilter<"MedicalCheck"> | string
    studentId?: StringFilter<"MedicalCheck"> | string
    campaignId?: StringFilter<"MedicalCheck"> | string
    nurseId?: StringNullableFilter<"MedicalCheck"> | string | null
    status?: EnumMedicalCheckStatusFilter<"MedicalCheck"> | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFilter<"MedicalCheck"> | Date | string
    completedDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    visionResult?: StringNullableFilter<"MedicalCheck"> | string | null
    hearingResult?: StringNullableFilter<"MedicalCheck"> | string | null
    dentalResult?: StringNullableFilter<"MedicalCheck"> | string | null
    heightWeight?: JsonNullableFilter<"MedicalCheck">
    generalHealth?: StringNullableFilter<"MedicalCheck"> | string | null
    recommendations?: StringNullableFilter<"MedicalCheck"> | string | null
    requiresFollowUp?: BoolFilter<"MedicalCheck"> | boolean
    followUpDate?: DateTimeNullableFilter<"MedicalCheck"> | Date | string | null
    notes?: StringNullableFilter<"MedicalCheck"> | string | null
    parentNotified?: BoolFilter<"MedicalCheck"> | boolean
    parentResponse?: StringNullableFilter<"MedicalCheck"> | string | null
    createdAt?: DateTimeFilter<"MedicalCheck"> | Date | string
    updatedAt?: DateTimeFilter<"MedicalCheck"> | Date | string
  }

  export type StudentMedicationUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentMedicationWhereUniqueInput
    update: XOR<StudentMedicationUpdateWithoutStudentInput, StudentMedicationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentMedicationCreateWithoutStudentInput, StudentMedicationUncheckedCreateWithoutStudentInput>
  }

  export type StudentMedicationUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentMedicationWhereUniqueInput
    data: XOR<StudentMedicationUpdateWithoutStudentInput, StudentMedicationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentMedicationUpdateManyWithWhereWithoutStudentInput = {
    where: StudentMedicationScalarWhereInput
    data: XOR<StudentMedicationUpdateManyMutationInput, StudentMedicationUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentMedicationScalarWhereInput = {
    AND?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
    OR?: StudentMedicationScalarWhereInput[]
    NOT?: StudentMedicationScalarWhereInput | StudentMedicationScalarWhereInput[]
    id?: StringFilter<"StudentMedication"> | string
    studentId?: StringFilter<"StudentMedication"> | string
    parentId?: StringFilter<"StudentMedication"> | string
    medicationId?: StringFilter<"StudentMedication"> | string
    dosage?: StringFilter<"StudentMedication"> | string
    frequency?: StringFilter<"StudentMedication"> | string
    duration?: StringNullableFilter<"StudentMedication"> | string | null
    instructions?: StringNullableFilter<"StudentMedication"> | string | null
    status?: EnumMedicationStatusFilter<"StudentMedication"> | $Enums.MedicationStatus
    startDate?: DateTimeFilter<"StudentMedication"> | Date | string
    endDate?: DateTimeNullableFilter<"StudentMedication"> | Date | string | null
    createdAt?: DateTimeFilter<"StudentMedication"> | Date | string
    updatedAt?: DateTimeFilter<"StudentMedication"> | Date | string
  }

  export type usersCreateWithoutParentProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutParentProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutParentProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutParentProfileInput, usersUncheckedCreateWithoutParentProfileInput>
  }

  export type StudentParentCreateWithoutParentInput = {
    id?: string
    relationship: string
    isPrimary?: boolean
    student: StudentCreateNestedOneWithoutParentsInput
  }

  export type StudentParentUncheckedCreateWithoutParentInput = {
    id?: string
    studentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type StudentParentCreateOrConnectWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentCreateManyParentInputEnvelope = {
    data: StudentParentCreateManyParentInput | StudentParentCreateManyParentInput[]
  }

  export type StudentMedicationCreateWithoutParentInput = {
    id?: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicationsInput
    medication: MedicationCreateNestedOneWithoutStudentMedicationsInput
  }

  export type StudentMedicationUncheckedCreateWithoutParentInput = {
    id?: string
    studentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationCreateOrConnectWithoutParentInput = {
    where: StudentMedicationWhereUniqueInput
    create: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput>
  }

  export type StudentMedicationCreateManyParentInputEnvelope = {
    data: StudentMedicationCreateManyParentInput | StudentMedicationCreateManyParentInput[]
  }

  export type usersUpsertWithoutParentProfileInput = {
    update: XOR<usersUpdateWithoutParentProfileInput, usersUncheckedUpdateWithoutParentProfileInput>
    create: XOR<usersCreateWithoutParentProfileInput, usersUncheckedCreateWithoutParentProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutParentProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutParentProfileInput, usersUncheckedUpdateWithoutParentProfileInput>
  }

  export type usersUpdateWithoutParentProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutParentProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentParentUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    update: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
    create: XOR<StudentParentCreateWithoutParentInput, StudentParentUncheckedCreateWithoutParentInput>
  }

  export type StudentParentUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentParentWhereUniqueInput
    data: XOR<StudentParentUpdateWithoutParentInput, StudentParentUncheckedUpdateWithoutParentInput>
  }

  export type StudentParentUpdateManyWithWhereWithoutParentInput = {
    where: StudentParentScalarWhereInput
    data: XOR<StudentParentUpdateManyMutationInput, StudentParentUncheckedUpdateManyWithoutParentInput>
  }

  export type StudentMedicationUpsertWithWhereUniqueWithoutParentInput = {
    where: StudentMedicationWhereUniqueInput
    update: XOR<StudentMedicationUpdateWithoutParentInput, StudentMedicationUncheckedUpdateWithoutParentInput>
    create: XOR<StudentMedicationCreateWithoutParentInput, StudentMedicationUncheckedCreateWithoutParentInput>
  }

  export type StudentMedicationUpdateWithWhereUniqueWithoutParentInput = {
    where: StudentMedicationWhereUniqueInput
    data: XOR<StudentMedicationUpdateWithoutParentInput, StudentMedicationUncheckedUpdateWithoutParentInput>
  }

  export type StudentMedicationUpdateManyWithWhereWithoutParentInput = {
    where: StudentMedicationScalarWhereInput
    data: XOR<StudentMedicationUpdateManyMutationInput, StudentMedicationUncheckedUpdateManyWithoutParentInput>
  }

  export type usersCreateWithoutNurseProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNurseProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNurseProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNurseProfileInput, usersUncheckedCreateWithoutNurseProfileInput>
  }

  export type MedicalEventCreateWithoutNurseInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalEventsInput
    createdBy: usersCreateNestedOneWithoutCreatedEventsInput
    medicationsUsed?: MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateWithoutNurseInput = {
    id?: string
    studentId: string
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput
    documents?: MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventCreateOrConnectWithoutNurseInput = {
    where: MedicalEventWhereUniqueInput
    create: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput>
  }

  export type MedicalEventCreateManyNurseInputEnvelope = {
    data: MedicalEventCreateManyNurseInput | MedicalEventCreateManyNurseInput[]
  }

  export type VaccinationCreateWithoutNurseInput = {
    id?: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutVaccinationsInput
    campaign: VaccinationCampaignCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateWithoutNurseInput = {
    id?: string
    studentId: string
    campaignId: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutNurseInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput>
  }

  export type VaccinationCreateManyNurseInputEnvelope = {
    data: VaccinationCreateManyNurseInput | VaccinationCreateManyNurseInput[]
  }

  export type MedicalCheckCreateWithoutNurseInput = {
    id?: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalChecksInput
    campaign: MedicalCheckCampaignCreateNestedOneWithoutMedicalChecksInput
  }

  export type MedicalCheckUncheckedCreateWithoutNurseInput = {
    id?: string
    studentId: string
    campaignId: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCreateOrConnectWithoutNurseInput = {
    where: MedicalCheckWhereUniqueInput
    create: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput>
  }

  export type MedicalCheckCreateManyNurseInputEnvelope = {
    data: MedicalCheckCreateManyNurseInput | MedicalCheckCreateManyNurseInput[]
  }

  export type usersUpsertWithoutNurseProfileInput = {
    update: XOR<usersUpdateWithoutNurseProfileInput, usersUncheckedUpdateWithoutNurseProfileInput>
    create: XOR<usersCreateWithoutNurseProfileInput, usersUncheckedCreateWithoutNurseProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNurseProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNurseProfileInput, usersUncheckedUpdateWithoutNurseProfileInput>
  }

  export type usersUpdateWithoutNurseProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNurseProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MedicalEventUpsertWithWhereUniqueWithoutNurseInput = {
    where: MedicalEventWhereUniqueInput
    update: XOR<MedicalEventUpdateWithoutNurseInput, MedicalEventUncheckedUpdateWithoutNurseInput>
    create: XOR<MedicalEventCreateWithoutNurseInput, MedicalEventUncheckedCreateWithoutNurseInput>
  }

  export type MedicalEventUpdateWithWhereUniqueWithoutNurseInput = {
    where: MedicalEventWhereUniqueInput
    data: XOR<MedicalEventUpdateWithoutNurseInput, MedicalEventUncheckedUpdateWithoutNurseInput>
  }

  export type MedicalEventUpdateManyWithWhereWithoutNurseInput = {
    where: MedicalEventScalarWhereInput
    data: XOR<MedicalEventUpdateManyMutationInput, MedicalEventUncheckedUpdateManyWithoutNurseInput>
  }

  export type VaccinationUpsertWithWhereUniqueWithoutNurseInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutNurseInput, VaccinationUncheckedUpdateWithoutNurseInput>
    create: XOR<VaccinationCreateWithoutNurseInput, VaccinationUncheckedCreateWithoutNurseInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutNurseInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutNurseInput, VaccinationUncheckedUpdateWithoutNurseInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutNurseInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutNurseInput>
  }

  export type MedicalCheckUpsertWithWhereUniqueWithoutNurseInput = {
    where: MedicalCheckWhereUniqueInput
    update: XOR<MedicalCheckUpdateWithoutNurseInput, MedicalCheckUncheckedUpdateWithoutNurseInput>
    create: XOR<MedicalCheckCreateWithoutNurseInput, MedicalCheckUncheckedCreateWithoutNurseInput>
  }

  export type MedicalCheckUpdateWithWhereUniqueWithoutNurseInput = {
    where: MedicalCheckWhereUniqueInput
    data: XOR<MedicalCheckUpdateWithoutNurseInput, MedicalCheckUncheckedUpdateWithoutNurseInput>
  }

  export type MedicalCheckUpdateManyWithWhereWithoutNurseInput = {
    where: MedicalCheckScalarWhereInput
    data: XOR<MedicalCheckUpdateManyMutationInput, MedicalCheckUncheckedUpdateManyWithoutNurseInput>
  }

  export type usersCreateWithoutManagerProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutManagerProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutManagerProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutManagerProfileInput, usersUncheckedCreateWithoutManagerProfileInput>
  }

  export type usersUpsertWithoutManagerProfileInput = {
    update: XOR<usersUpdateWithoutManagerProfileInput, usersUncheckedUpdateWithoutManagerProfileInput>
    create: XOR<usersCreateWithoutManagerProfileInput, usersUncheckedCreateWithoutManagerProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutManagerProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutManagerProfileInput, usersUncheckedUpdateWithoutManagerProfileInput>
  }

  export type usersUpdateWithoutManagerProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutManagerProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAdminProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAdminProfileInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAdminProfileInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
  }

  export type usersUpsertWithoutAdminProfileInput = {
    update: XOR<usersUpdateWithoutAdminProfileInput, usersUncheckedUpdateWithoutAdminProfileInput>
    create: XOR<usersCreateWithoutAdminProfileInput, usersUncheckedCreateWithoutAdminProfileInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAdminProfileInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAdminProfileInput, usersUncheckedUpdateWithoutAdminProfileInput>
  }

  export type usersUpdateWithoutAdminProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAdminProfileInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StudentCreateWithoutParentsInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutParentsInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutParentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
  }

  export type ParentCreateWithoutChildrenInput = {
    id?: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutParentProfileInput
    medications?: StudentMedicationCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutChildrenInput = {
    id?: string
    userId: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutChildrenInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
  }

  export type StudentUpsertWithoutParentsInput = {
    update: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
    create: XOR<StudentCreateWithoutParentsInput, StudentUncheckedCreateWithoutParentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutParentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutParentsInput, StudentUncheckedUpdateWithoutParentsInput>
  }

  export type StudentUpdateWithoutParentsInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutParentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutChildrenInput = {
    update: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
    create: XOR<ParentCreateWithoutChildrenInput, ParentUncheckedCreateWithoutChildrenInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutChildrenInput, ParentUncheckedUpdateWithoutChildrenInput>
  }

  export type ParentUpdateWithoutChildrenInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutParentProfileNestedInput
    medications?: StudentMedicationUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutChildrenInput = {
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medications?: StudentMedicationUncheckedUpdateManyWithoutParentNestedInput
  }

  export type StudentCreateWithoutHealthProfileInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutHealthProfileInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutHealthProfileInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutHealthProfileInput, StudentUncheckedCreateWithoutHealthProfileInput>
  }

  export type StudentUpsertWithoutHealthProfileInput = {
    update: XOR<StudentUpdateWithoutHealthProfileInput, StudentUncheckedUpdateWithoutHealthProfileInput>
    create: XOR<StudentCreateWithoutHealthProfileInput, StudentUncheckedCreateWithoutHealthProfileInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutHealthProfileInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutHealthProfileInput, StudentUncheckedUpdateWithoutHealthProfileInput>
  }

  export type StudentUpdateWithoutHealthProfileInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutHealthProfileInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutMedicalEventsInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMedicalEventsInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMedicalEventsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMedicalEventsInput, StudentUncheckedCreateWithoutMedicalEventsInput>
  }

  export type SchoolNurseCreateWithoutHandledEventsInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutNurseProfileInput
    vaccinations?: VaccinationCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUncheckedCreateWithoutHandledEventsInput = {
    id?: string
    userId: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseCreateOrConnectWithoutHandledEventsInput = {
    where: SchoolNurseWhereUniqueInput
    create: XOR<SchoolNurseCreateWithoutHandledEventsInput, SchoolNurseUncheckedCreateWithoutHandledEventsInput>
  }

  export type usersCreateWithoutCreatedEventsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCreatedEventsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCreatedEventsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCreatedEventsInput, usersUncheckedCreateWithoutCreatedEventsInput>
  }

  export type MedicalEventMedicationCreateWithoutMedicalEventInput = {
    id?: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
    medication: MedicationCreateNestedOneWithoutMedicalEventMedicationsInput
  }

  export type MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput = {
    id?: string
    medicationId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type MedicalEventMedicationCreateOrConnectWithoutMedicalEventInput = {
    where: MedicalEventMedicationWhereUniqueInput
    create: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput>
  }

  export type MedicalEventMedicationCreateManyMedicalEventInputEnvelope = {
    data: MedicalEventMedicationCreateManyMedicalEventInput | MedicalEventMedicationCreateManyMedicalEventInput[]
  }

  export type MedicalDocumentCreateWithoutMedicalEventInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MedicalDocumentUncheckedCreateWithoutMedicalEventInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MedicalDocumentCreateOrConnectWithoutMedicalEventInput = {
    where: MedicalDocumentWhereUniqueInput
    create: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput>
  }

  export type MedicalDocumentCreateManyMedicalEventInputEnvelope = {
    data: MedicalDocumentCreateManyMedicalEventInput | MedicalDocumentCreateManyMedicalEventInput[]
  }

  export type StudentUpsertWithoutMedicalEventsInput = {
    update: XOR<StudentUpdateWithoutMedicalEventsInput, StudentUncheckedUpdateWithoutMedicalEventsInput>
    create: XOR<StudentCreateWithoutMedicalEventsInput, StudentUncheckedCreateWithoutMedicalEventsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMedicalEventsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMedicalEventsInput, StudentUncheckedUpdateWithoutMedicalEventsInput>
  }

  export type StudentUpdateWithoutMedicalEventsInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMedicalEventsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SchoolNurseUpsertWithoutHandledEventsInput = {
    update: XOR<SchoolNurseUpdateWithoutHandledEventsInput, SchoolNurseUncheckedUpdateWithoutHandledEventsInput>
    create: XOR<SchoolNurseCreateWithoutHandledEventsInput, SchoolNurseUncheckedCreateWithoutHandledEventsInput>
    where?: SchoolNurseWhereInput
  }

  export type SchoolNurseUpdateToOneWithWhereWithoutHandledEventsInput = {
    where?: SchoolNurseWhereInput
    data: XOR<SchoolNurseUpdateWithoutHandledEventsInput, SchoolNurseUncheckedUpdateWithoutHandledEventsInput>
  }

  export type SchoolNurseUpdateWithoutHandledEventsInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNurseProfileNestedInput
    vaccinations?: VaccinationUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseUncheckedUpdateWithoutHandledEventsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUncheckedUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type usersUpsertWithoutCreatedEventsInput = {
    update: XOR<usersUpdateWithoutCreatedEventsInput, usersUncheckedUpdateWithoutCreatedEventsInput>
    create: XOR<usersCreateWithoutCreatedEventsInput, usersUncheckedCreateWithoutCreatedEventsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCreatedEventsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCreatedEventsInput, usersUncheckedUpdateWithoutCreatedEventsInput>
  }

  export type usersUpdateWithoutCreatedEventsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCreatedEventsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicalEventInput = {
    where: MedicalEventMedicationWhereUniqueInput
    update: XOR<MedicalEventMedicationUpdateWithoutMedicalEventInput, MedicalEventMedicationUncheckedUpdateWithoutMedicalEventInput>
    create: XOR<MedicalEventMedicationCreateWithoutMedicalEventInput, MedicalEventMedicationUncheckedCreateWithoutMedicalEventInput>
  }

  export type MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicalEventInput = {
    where: MedicalEventMedicationWhereUniqueInput
    data: XOR<MedicalEventMedicationUpdateWithoutMedicalEventInput, MedicalEventMedicationUncheckedUpdateWithoutMedicalEventInput>
  }

  export type MedicalEventMedicationUpdateManyWithWhereWithoutMedicalEventInput = {
    where: MedicalEventMedicationScalarWhereInput
    data: XOR<MedicalEventMedicationUpdateManyMutationInput, MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventInput>
  }

  export type MedicalEventMedicationScalarWhereInput = {
    AND?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
    OR?: MedicalEventMedicationScalarWhereInput[]
    NOT?: MedicalEventMedicationScalarWhereInput | MedicalEventMedicationScalarWhereInput[]
    id?: StringFilter<"MedicalEventMedication"> | string
    medicalEventId?: StringFilter<"MedicalEventMedication"> | string
    medicationId?: StringFilter<"MedicalEventMedication"> | string
    quantityUsed?: IntFilter<"MedicalEventMedication"> | number
    dosageGiven?: StringFilter<"MedicalEventMedication"> | string
    administeredAt?: DateTimeFilter<"MedicalEventMedication"> | Date | string
    notes?: StringNullableFilter<"MedicalEventMedication"> | string | null
  }

  export type MedicalDocumentUpsertWithWhereUniqueWithoutMedicalEventInput = {
    where: MedicalDocumentWhereUniqueInput
    update: XOR<MedicalDocumentUpdateWithoutMedicalEventInput, MedicalDocumentUncheckedUpdateWithoutMedicalEventInput>
    create: XOR<MedicalDocumentCreateWithoutMedicalEventInput, MedicalDocumentUncheckedCreateWithoutMedicalEventInput>
  }

  export type MedicalDocumentUpdateWithWhereUniqueWithoutMedicalEventInput = {
    where: MedicalDocumentWhereUniqueInput
    data: XOR<MedicalDocumentUpdateWithoutMedicalEventInput, MedicalDocumentUncheckedUpdateWithoutMedicalEventInput>
  }

  export type MedicalDocumentUpdateManyWithWhereWithoutMedicalEventInput = {
    where: MedicalDocumentScalarWhereInput
    data: XOR<MedicalDocumentUpdateManyMutationInput, MedicalDocumentUncheckedUpdateManyWithoutMedicalEventInput>
  }

  export type MedicalDocumentScalarWhereInput = {
    AND?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
    OR?: MedicalDocumentScalarWhereInput[]
    NOT?: MedicalDocumentScalarWhereInput | MedicalDocumentScalarWhereInput[]
    id?: StringFilter<"MedicalDocument"> | string
    medicalEventId?: StringNullableFilter<"MedicalDocument"> | string | null
    title?: StringFilter<"MedicalDocument"> | string
    description?: StringNullableFilter<"MedicalDocument"> | string | null
    fileName?: StringFilter<"MedicalDocument"> | string
    filePath?: StringFilter<"MedicalDocument"> | string
    fileSize?: IntFilter<"MedicalDocument"> | number
    mimeType?: StringFilter<"MedicalDocument"> | string
    createdAt?: DateTimeFilter<"MedicalDocument"> | Date | string
  }

  export type StudentMedicationCreateWithoutMedicationInput = {
    id?: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicationsInput
    parent: ParentCreateNestedOneWithoutMedicationsInput
  }

  export type StudentMedicationUncheckedCreateWithoutMedicationInput = {
    id?: string
    studentId: string
    parentId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationCreateOrConnectWithoutMedicationInput = {
    where: StudentMedicationWhereUniqueInput
    create: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput>
  }

  export type StudentMedicationCreateManyMedicationInputEnvelope = {
    data: StudentMedicationCreateManyMedicationInput | StudentMedicationCreateManyMedicationInput[]
  }

  export type MedicalEventMedicationCreateWithoutMedicationInput = {
    id?: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
    medicalEvent: MedicalEventCreateNestedOneWithoutMedicationsUsedInput
  }

  export type MedicalEventMedicationUncheckedCreateWithoutMedicationInput = {
    id?: string
    medicalEventId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type MedicalEventMedicationCreateOrConnectWithoutMedicationInput = {
    where: MedicalEventMedicationWhereUniqueInput
    create: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput>
  }

  export type MedicalEventMedicationCreateManyMedicationInputEnvelope = {
    data: MedicalEventMedicationCreateManyMedicationInput | MedicalEventMedicationCreateManyMedicationInput[]
  }

  export type StockMovementCreateWithoutMedicationInput = {
    id?: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementUncheckedCreateWithoutMedicationInput = {
    id?: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type StockMovementCreateOrConnectWithoutMedicationInput = {
    where: StockMovementWhereUniqueInput
    create: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput>
  }

  export type StockMovementCreateManyMedicationInputEnvelope = {
    data: StockMovementCreateManyMedicationInput | StockMovementCreateManyMedicationInput[]
  }

  export type StudentMedicationUpsertWithWhereUniqueWithoutMedicationInput = {
    where: StudentMedicationWhereUniqueInput
    update: XOR<StudentMedicationUpdateWithoutMedicationInput, StudentMedicationUncheckedUpdateWithoutMedicationInput>
    create: XOR<StudentMedicationCreateWithoutMedicationInput, StudentMedicationUncheckedCreateWithoutMedicationInput>
  }

  export type StudentMedicationUpdateWithWhereUniqueWithoutMedicationInput = {
    where: StudentMedicationWhereUniqueInput
    data: XOR<StudentMedicationUpdateWithoutMedicationInput, StudentMedicationUncheckedUpdateWithoutMedicationInput>
  }

  export type StudentMedicationUpdateManyWithWhereWithoutMedicationInput = {
    where: StudentMedicationScalarWhereInput
    data: XOR<StudentMedicationUpdateManyMutationInput, StudentMedicationUncheckedUpdateManyWithoutMedicationInput>
  }

  export type MedicalEventMedicationUpsertWithWhereUniqueWithoutMedicationInput = {
    where: MedicalEventMedicationWhereUniqueInput
    update: XOR<MedicalEventMedicationUpdateWithoutMedicationInput, MedicalEventMedicationUncheckedUpdateWithoutMedicationInput>
    create: XOR<MedicalEventMedicationCreateWithoutMedicationInput, MedicalEventMedicationUncheckedCreateWithoutMedicationInput>
  }

  export type MedicalEventMedicationUpdateWithWhereUniqueWithoutMedicationInput = {
    where: MedicalEventMedicationWhereUniqueInput
    data: XOR<MedicalEventMedicationUpdateWithoutMedicationInput, MedicalEventMedicationUncheckedUpdateWithoutMedicationInput>
  }

  export type MedicalEventMedicationUpdateManyWithWhereWithoutMedicationInput = {
    where: MedicalEventMedicationScalarWhereInput
    data: XOR<MedicalEventMedicationUpdateManyMutationInput, MedicalEventMedicationUncheckedUpdateManyWithoutMedicationInput>
  }

  export type StockMovementUpsertWithWhereUniqueWithoutMedicationInput = {
    where: StockMovementWhereUniqueInput
    update: XOR<StockMovementUpdateWithoutMedicationInput, StockMovementUncheckedUpdateWithoutMedicationInput>
    create: XOR<StockMovementCreateWithoutMedicationInput, StockMovementUncheckedCreateWithoutMedicationInput>
  }

  export type StockMovementUpdateWithWhereUniqueWithoutMedicationInput = {
    where: StockMovementWhereUniqueInput
    data: XOR<StockMovementUpdateWithoutMedicationInput, StockMovementUncheckedUpdateWithoutMedicationInput>
  }

  export type StockMovementUpdateManyWithWhereWithoutMedicationInput = {
    where: StockMovementScalarWhereInput
    data: XOR<StockMovementUpdateManyMutationInput, StockMovementUncheckedUpdateManyWithoutMedicationInput>
  }

  export type StockMovementScalarWhereInput = {
    AND?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    OR?: StockMovementScalarWhereInput[]
    NOT?: StockMovementScalarWhereInput | StockMovementScalarWhereInput[]
    id?: StringFilter<"StockMovement"> | string
    medicationId?: StringFilter<"StockMovement"> | string
    type?: StringFilter<"StockMovement"> | string
    quantity?: IntFilter<"StockMovement"> | number
    reason?: StringNullableFilter<"StockMovement"> | string | null
    reference?: StringNullableFilter<"StockMovement"> | string | null
    createdAt?: DateTimeFilter<"StockMovement"> | Date | string
  }

  export type StudentCreateWithoutMedicationsInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMedicationsInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMedicationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMedicationsInput, StudentUncheckedCreateWithoutMedicationsInput>
  }

  export type ParentCreateWithoutMedicationsInput = {
    id?: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutParentProfileInput
    children?: StudentParentCreateNestedManyWithoutParentInput
  }

  export type ParentUncheckedCreateWithoutMedicationsInput = {
    id?: string
    userId: string
    occupation?: string | null
    workplace?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: StudentParentUncheckedCreateNestedManyWithoutParentInput
  }

  export type ParentCreateOrConnectWithoutMedicationsInput = {
    where: ParentWhereUniqueInput
    create: XOR<ParentCreateWithoutMedicationsInput, ParentUncheckedCreateWithoutMedicationsInput>
  }

  export type MedicationCreateWithoutStudentMedicationsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalEventMedications?: MedicalEventMedicationCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutStudentMedicationsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalEventMedications?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutStudentMedicationsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutStudentMedicationsInput, MedicationUncheckedCreateWithoutStudentMedicationsInput>
  }

  export type StudentUpsertWithoutMedicationsInput = {
    update: XOR<StudentUpdateWithoutMedicationsInput, StudentUncheckedUpdateWithoutMedicationsInput>
    create: XOR<StudentCreateWithoutMedicationsInput, StudentUncheckedCreateWithoutMedicationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMedicationsInput, StudentUncheckedUpdateWithoutMedicationsInput>
  }

  export type StudentUpdateWithoutMedicationsInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMedicationsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type ParentUpsertWithoutMedicationsInput = {
    update: XOR<ParentUpdateWithoutMedicationsInput, ParentUncheckedUpdateWithoutMedicationsInput>
    create: XOR<ParentCreateWithoutMedicationsInput, ParentUncheckedCreateWithoutMedicationsInput>
    where?: ParentWhereInput
  }

  export type ParentUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: ParentWhereInput
    data: XOR<ParentUpdateWithoutMedicationsInput, ParentUncheckedUpdateWithoutMedicationsInput>
  }

  export type ParentUpdateWithoutMedicationsInput = {
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutParentProfileNestedInput
    children?: StudentParentUpdateManyWithoutParentNestedInput
  }

  export type ParentUncheckedUpdateWithoutMedicationsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    workplace?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: StudentParentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type MedicationUpsertWithoutStudentMedicationsInput = {
    update: XOR<MedicationUpdateWithoutStudentMedicationsInput, MedicationUncheckedUpdateWithoutStudentMedicationsInput>
    create: XOR<MedicationCreateWithoutStudentMedicationsInput, MedicationUncheckedCreateWithoutStudentMedicationsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutStudentMedicationsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutStudentMedicationsInput, MedicationUncheckedUpdateWithoutStudentMedicationsInput>
  }

  export type MedicationUpdateWithoutStudentMedicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalEventMedications?: MedicalEventMedicationUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutStudentMedicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalEventMedications?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicalEventCreateWithoutMedicationsUsedInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalEventsInput
    nurse?: SchoolNurseCreateNestedOneWithoutHandledEventsInput
    createdBy: usersCreateNestedOneWithoutCreatedEventsInput
    documents?: MedicalDocumentCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateWithoutMedicationsUsedInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: MedicalDocumentUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventCreateOrConnectWithoutMedicationsUsedInput = {
    where: MedicalEventWhereUniqueInput
    create: XOR<MedicalEventCreateWithoutMedicationsUsedInput, MedicalEventUncheckedCreateWithoutMedicationsUsedInput>
  }

  export type MedicationCreateWithoutMedicalEventMedicationsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutMedicalEventMedicationsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationUncheckedCreateNestedManyWithoutMedicationInput
    stockMovements?: StockMovementUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutMedicalEventMedicationsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutMedicalEventMedicationsInput, MedicationUncheckedCreateWithoutMedicalEventMedicationsInput>
  }

  export type MedicalEventUpsertWithoutMedicationsUsedInput = {
    update: XOR<MedicalEventUpdateWithoutMedicationsUsedInput, MedicalEventUncheckedUpdateWithoutMedicationsUsedInput>
    create: XOR<MedicalEventCreateWithoutMedicationsUsedInput, MedicalEventUncheckedCreateWithoutMedicationsUsedInput>
    where?: MedicalEventWhereInput
  }

  export type MedicalEventUpdateToOneWithWhereWithoutMedicationsUsedInput = {
    where?: MedicalEventWhereInput
    data: XOR<MedicalEventUpdateWithoutMedicationsUsedInput, MedicalEventUncheckedUpdateWithoutMedicationsUsedInput>
  }

  export type MedicalEventUpdateWithoutMedicationsUsedInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalEventsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutHandledEventsNestedInput
    createdBy?: usersUpdateOneRequiredWithoutCreatedEventsNestedInput
    documents?: MedicalDocumentUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateWithoutMedicationsUsedInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicationUpsertWithoutMedicalEventMedicationsInput = {
    update: XOR<MedicationUpdateWithoutMedicalEventMedicationsInput, MedicationUncheckedUpdateWithoutMedicalEventMedicationsInput>
    create: XOR<MedicationCreateWithoutMedicalEventMedicationsInput, MedicationUncheckedCreateWithoutMedicalEventMedicationsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutMedicalEventMedicationsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutMedicalEventMedicationsInput, MedicationUncheckedUpdateWithoutMedicalEventMedicationsInput>
  }

  export type MedicationUpdateWithoutMedicalEventMedicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutMedicalEventMedicationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUncheckedUpdateManyWithoutMedicationNestedInput
    stockMovements?: StockMovementUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationCreateNestedManyWithoutMedicationInput
    medicalEventMedications?: MedicalEventMedicationCreateNestedManyWithoutMedicationInput
  }

  export type MedicationUncheckedCreateWithoutStockMovementsInput = {
    id?: string
    name: string
    description?: string | null
    dosage: string
    unit: string
    manufacturer?: string | null
    expiryDate?: Date | string | null
    stockQuantity?: number
    minStockLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    studentMedications?: StudentMedicationUncheckedCreateNestedManyWithoutMedicationInput
    medicalEventMedications?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicationInput
  }

  export type MedicationCreateOrConnectWithoutStockMovementsInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutStockMovementsInput, MedicationUncheckedCreateWithoutStockMovementsInput>
  }

  export type MedicationUpsertWithoutStockMovementsInput = {
    update: XOR<MedicationUpdateWithoutStockMovementsInput, MedicationUncheckedUpdateWithoutStockMovementsInput>
    create: XOR<MedicationCreateWithoutStockMovementsInput, MedicationUncheckedCreateWithoutStockMovementsInput>
    where?: MedicationWhereInput
  }

  export type MedicationUpdateToOneWithWhereWithoutStockMovementsInput = {
    where?: MedicationWhereInput
    data: XOR<MedicationUpdateWithoutStockMovementsInput, MedicationUncheckedUpdateWithoutStockMovementsInput>
  }

  export type MedicationUpdateWithoutStockMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUpdateManyWithoutMedicationNestedInput
    medicalEventMedications?: MedicalEventMedicationUpdateManyWithoutMedicationNestedInput
  }

  export type MedicationUncheckedUpdateWithoutStockMovementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    dosage?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stockQuantity?: IntFieldUpdateOperationsInput | number
    minStockLevel?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentMedications?: StudentMedicationUncheckedUpdateManyWithoutMedicationNestedInput
    medicalEventMedications?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicationNestedInput
  }

  export type VaccinationCreateWithoutCampaignInput = {
    id?: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutVaccinationsInput
    nurse?: SchoolNurseCreateNestedOneWithoutVaccinationsInput
  }

  export type VaccinationUncheckedCreateWithoutCampaignInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCreateOrConnectWithoutCampaignInput = {
    where: VaccinationWhereUniqueInput
    create: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput>
  }

  export type VaccinationCreateManyCampaignInputEnvelope = {
    data: VaccinationCreateManyCampaignInput | VaccinationCreateManyCampaignInput[]
  }

  export type NotificationCreateWithoutVaccinationCampaignInput = {
    id?: string
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutNotificationsInput
    medicalCheckCampaign?: MedicalCheckCampaignCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutVaccinationCampaignInput = {
    id?: string
    userId: string
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutVaccinationCampaignInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput>
  }

  export type NotificationCreateManyVaccinationCampaignInputEnvelope = {
    data: NotificationCreateManyVaccinationCampaignInput | NotificationCreateManyVaccinationCampaignInput[]
  }

  export type VaccinationUpsertWithWhereUniqueWithoutCampaignInput = {
    where: VaccinationWhereUniqueInput
    update: XOR<VaccinationUpdateWithoutCampaignInput, VaccinationUncheckedUpdateWithoutCampaignInput>
    create: XOR<VaccinationCreateWithoutCampaignInput, VaccinationUncheckedCreateWithoutCampaignInput>
  }

  export type VaccinationUpdateWithWhereUniqueWithoutCampaignInput = {
    where: VaccinationWhereUniqueInput
    data: XOR<VaccinationUpdateWithoutCampaignInput, VaccinationUncheckedUpdateWithoutCampaignInput>
  }

  export type VaccinationUpdateManyWithWhereWithoutCampaignInput = {
    where: VaccinationScalarWhereInput
    data: XOR<VaccinationUpdateManyMutationInput, VaccinationUncheckedUpdateManyWithoutCampaignInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutVaccinationCampaignInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutVaccinationCampaignInput, NotificationUncheckedUpdateWithoutVaccinationCampaignInput>
    create: XOR<NotificationCreateWithoutVaccinationCampaignInput, NotificationUncheckedCreateWithoutVaccinationCampaignInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutVaccinationCampaignInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutVaccinationCampaignInput, NotificationUncheckedUpdateWithoutVaccinationCampaignInput>
  }

  export type NotificationUpdateManyWithWhereWithoutVaccinationCampaignInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutVaccinationCampaignInput>
  }

  export type StudentCreateWithoutVaccinationsInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutVaccinationsInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutVaccinationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutVaccinationsInput, StudentUncheckedCreateWithoutVaccinationsInput>
  }

  export type VaccinationCampaignCreateWithoutVaccinationsInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutVaccinationCampaignInput
  }

  export type VaccinationCampaignUncheckedCreateWithoutVaccinationsInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutVaccinationCampaignInput
  }

  export type VaccinationCampaignCreateOrConnectWithoutVaccinationsInput = {
    where: VaccinationCampaignWhereUniqueInput
    create: XOR<VaccinationCampaignCreateWithoutVaccinationsInput, VaccinationCampaignUncheckedCreateWithoutVaccinationsInput>
  }

  export type SchoolNurseCreateWithoutVaccinationsInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutNurseProfileInput
    handledEvents?: MedicalEventCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUncheckedCreateWithoutVaccinationsInput = {
    id?: string
    userId: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    handledEvents?: MedicalEventUncheckedCreateNestedManyWithoutNurseInput
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseCreateOrConnectWithoutVaccinationsInput = {
    where: SchoolNurseWhereUniqueInput
    create: XOR<SchoolNurseCreateWithoutVaccinationsInput, SchoolNurseUncheckedCreateWithoutVaccinationsInput>
  }

  export type StudentUpsertWithoutVaccinationsInput = {
    update: XOR<StudentUpdateWithoutVaccinationsInput, StudentUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<StudentCreateWithoutVaccinationsInput, StudentUncheckedCreateWithoutVaccinationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutVaccinationsInput, StudentUncheckedUpdateWithoutVaccinationsInput>
  }

  export type StudentUpdateWithoutVaccinationsInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutVaccinationsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type VaccinationCampaignUpsertWithoutVaccinationsInput = {
    update: XOR<VaccinationCampaignUpdateWithoutVaccinationsInput, VaccinationCampaignUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<VaccinationCampaignCreateWithoutVaccinationsInput, VaccinationCampaignUncheckedCreateWithoutVaccinationsInput>
    where?: VaccinationCampaignWhereInput
  }

  export type VaccinationCampaignUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: VaccinationCampaignWhereInput
    data: XOR<VaccinationCampaignUpdateWithoutVaccinationsInput, VaccinationCampaignUncheckedUpdateWithoutVaccinationsInput>
  }

  export type VaccinationCampaignUpdateWithoutVaccinationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutVaccinationCampaignNestedInput
  }

  export type VaccinationCampaignUncheckedUpdateWithoutVaccinationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutVaccinationCampaignNestedInput
  }

  export type SchoolNurseUpsertWithoutVaccinationsInput = {
    update: XOR<SchoolNurseUpdateWithoutVaccinationsInput, SchoolNurseUncheckedUpdateWithoutVaccinationsInput>
    create: XOR<SchoolNurseCreateWithoutVaccinationsInput, SchoolNurseUncheckedCreateWithoutVaccinationsInput>
    where?: SchoolNurseWhereInput
  }

  export type SchoolNurseUpdateToOneWithWhereWithoutVaccinationsInput = {
    where?: SchoolNurseWhereInput
    data: XOR<SchoolNurseUpdateWithoutVaccinationsInput, SchoolNurseUncheckedUpdateWithoutVaccinationsInput>
  }

  export type SchoolNurseUpdateWithoutVaccinationsInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNurseProfileNestedInput
    handledEvents?: MedicalEventUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseUncheckedUpdateWithoutVaccinationsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledEvents?: MedicalEventUncheckedUpdateManyWithoutNurseNestedInput
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type MedicalCheckCreateWithoutCampaignInput = {
    id?: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalChecksInput
    nurse?: SchoolNurseCreateNestedOneWithoutMedicalChecksInput
  }

  export type MedicalCheckUncheckedCreateWithoutCampaignInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCreateOrConnectWithoutCampaignInput = {
    where: MedicalCheckWhereUniqueInput
    create: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput>
  }

  export type MedicalCheckCreateManyCampaignInputEnvelope = {
    data: MedicalCheckCreateManyCampaignInput | MedicalCheckCreateManyCampaignInput[]
  }

  export type NotificationCreateWithoutMedicalCheckCampaignInput = {
    id?: string
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutNotificationsInput
    vaccinationCampaign?: VaccinationCampaignCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutMedicalCheckCampaignInput = {
    id?: string
    userId: string
    vaccinationCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutMedicalCheckCampaignInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput>
  }

  export type NotificationCreateManyMedicalCheckCampaignInputEnvelope = {
    data: NotificationCreateManyMedicalCheckCampaignInput | NotificationCreateManyMedicalCheckCampaignInput[]
  }

  export type MedicalCheckUpsertWithWhereUniqueWithoutCampaignInput = {
    where: MedicalCheckWhereUniqueInput
    update: XOR<MedicalCheckUpdateWithoutCampaignInput, MedicalCheckUncheckedUpdateWithoutCampaignInput>
    create: XOR<MedicalCheckCreateWithoutCampaignInput, MedicalCheckUncheckedCreateWithoutCampaignInput>
  }

  export type MedicalCheckUpdateWithWhereUniqueWithoutCampaignInput = {
    where: MedicalCheckWhereUniqueInput
    data: XOR<MedicalCheckUpdateWithoutCampaignInput, MedicalCheckUncheckedUpdateWithoutCampaignInput>
  }

  export type MedicalCheckUpdateManyWithWhereWithoutCampaignInput = {
    where: MedicalCheckScalarWhereInput
    data: XOR<MedicalCheckUpdateManyMutationInput, MedicalCheckUncheckedUpdateManyWithoutCampaignInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutMedicalCheckCampaignInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMedicalCheckCampaignInput, NotificationUncheckedUpdateWithoutMedicalCheckCampaignInput>
    create: XOR<NotificationCreateWithoutMedicalCheckCampaignInput, NotificationUncheckedCreateWithoutMedicalCheckCampaignInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMedicalCheckCampaignInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMedicalCheckCampaignInput, NotificationUncheckedUpdateWithoutMedicalCheckCampaignInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMedicalCheckCampaignInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutMedicalCheckCampaignInput>
  }

  export type StudentCreateWithoutMedicalChecksInput = {
    id?: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutStudentProfileInput
    parents?: StudentParentCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMedicalChecksInput = {
    id?: string
    userId: string
    studentCode: string
    dateOfBirth: Date | string
    gender: string
    class: string
    grade: string
    bloodType?: string | null
    emergencyContact: string
    emergencyPhone: string
    createdAt?: Date | string
    updatedAt?: Date | string
    parents?: StudentParentUncheckedCreateNestedManyWithoutStudentInput
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutStudentInput
    medicalEvents?: MedicalEventUncheckedCreateNestedManyWithoutStudentInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutStudentInput
    medications?: StudentMedicationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMedicalChecksInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMedicalChecksInput, StudentUncheckedCreateWithoutMedicalChecksInput>
  }

  export type MedicalCheckCampaignCreateWithoutMedicalChecksInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationCreateNestedManyWithoutMedicalCheckCampaignInput
  }

  export type MedicalCheckCampaignUncheckedCreateWithoutMedicalChecksInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutMedicalCheckCampaignInput
  }

  export type MedicalCheckCampaignCreateOrConnectWithoutMedicalChecksInput = {
    where: MedicalCheckCampaignWhereUniqueInput
    create: XOR<MedicalCheckCampaignCreateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedCreateWithoutMedicalChecksInput>
  }

  export type SchoolNurseCreateWithoutMedicalChecksInput = {
    id?: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutNurseProfileInput
    handledEvents?: MedicalEventCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseUncheckedCreateWithoutMedicalChecksInput = {
    id?: string
    userId: string
    licenseNumber: string
    specialization?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    handledEvents?: MedicalEventUncheckedCreateNestedManyWithoutNurseInput
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutNurseInput
  }

  export type SchoolNurseCreateOrConnectWithoutMedicalChecksInput = {
    where: SchoolNurseWhereUniqueInput
    create: XOR<SchoolNurseCreateWithoutMedicalChecksInput, SchoolNurseUncheckedCreateWithoutMedicalChecksInput>
  }

  export type StudentUpsertWithoutMedicalChecksInput = {
    update: XOR<StudentUpdateWithoutMedicalChecksInput, StudentUncheckedUpdateWithoutMedicalChecksInput>
    create: XOR<StudentCreateWithoutMedicalChecksInput, StudentUncheckedCreateWithoutMedicalChecksInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMedicalChecksInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMedicalChecksInput, StudentUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type StudentUpdateWithoutMedicalChecksInput = {
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutStudentProfileNestedInput
    parents?: StudentParentUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMedicalChecksInput = {
    userId?: StringFieldUpdateOperationsInput | string
    studentCode?: StringFieldUpdateOperationsInput | string
    dateOfBirth?: DateTimeFieldUpdateOperationsInput | Date | string
    gender?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    grade?: StringFieldUpdateOperationsInput | string
    bloodType?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: StringFieldUpdateOperationsInput | string
    emergencyPhone?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parents?: StudentParentUncheckedUpdateManyWithoutStudentNestedInput
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutStudentNestedInput
    medicalEvents?: MedicalEventUncheckedUpdateManyWithoutStudentNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutStudentNestedInput
    medications?: StudentMedicationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type MedicalCheckCampaignUpsertWithoutMedicalChecksInput = {
    update: XOR<MedicalCheckCampaignUpdateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedUpdateWithoutMedicalChecksInput>
    create: XOR<MedicalCheckCampaignCreateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedCreateWithoutMedicalChecksInput>
    where?: MedicalCheckCampaignWhereInput
  }

  export type MedicalCheckCampaignUpdateToOneWithWhereWithoutMedicalChecksInput = {
    where?: MedicalCheckCampaignWhereInput
    data: XOR<MedicalCheckCampaignUpdateWithoutMedicalChecksInput, MedicalCheckCampaignUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type MedicalCheckCampaignUpdateWithoutMedicalChecksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUpdateManyWithoutMedicalCheckCampaignNestedInput
  }

  export type MedicalCheckCampaignUncheckedUpdateWithoutMedicalChecksInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutMedicalCheckCampaignNestedInput
  }

  export type SchoolNurseUpsertWithoutMedicalChecksInput = {
    update: XOR<SchoolNurseUpdateWithoutMedicalChecksInput, SchoolNurseUncheckedUpdateWithoutMedicalChecksInput>
    create: XOR<SchoolNurseCreateWithoutMedicalChecksInput, SchoolNurseUncheckedCreateWithoutMedicalChecksInput>
    where?: SchoolNurseWhereInput
  }

  export type SchoolNurseUpdateToOneWithWhereWithoutMedicalChecksInput = {
    where?: SchoolNurseWhereInput
    data: XOR<SchoolNurseUpdateWithoutMedicalChecksInput, SchoolNurseUncheckedUpdateWithoutMedicalChecksInput>
  }

  export type SchoolNurseUpdateWithoutMedicalChecksInput = {
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNurseProfileNestedInput
    handledEvents?: MedicalEventUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUpdateManyWithoutNurseNestedInput
  }

  export type SchoolNurseUncheckedUpdateWithoutMedicalChecksInput = {
    userId?: StringFieldUpdateOperationsInput | string
    licenseNumber?: StringFieldUpdateOperationsInput | string
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    handledEvents?: MedicalEventUncheckedUpdateManyWithoutNurseNestedInput
    vaccinations?: VaccinationUncheckedUpdateManyWithoutNurseNestedInput
  }

  export type MedicalEventCreateWithoutDocumentsInput = {
    id?: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutMedicalEventsInput
    nurse?: SchoolNurseCreateNestedOneWithoutHandledEventsInput
    createdBy: usersCreateNestedOneWithoutCreatedEventsInput
    medicationsUsed?: MedicalEventMedicationCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventUncheckedCreateWithoutDocumentsInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedCreateNestedManyWithoutMedicalEventInput
  }

  export type MedicalEventCreateOrConnectWithoutDocumentsInput = {
    where: MedicalEventWhereUniqueInput
    create: XOR<MedicalEventCreateWithoutDocumentsInput, MedicalEventUncheckedCreateWithoutDocumentsInput>
  }

  export type MedicalEventUpsertWithoutDocumentsInput = {
    update: XOR<MedicalEventUpdateWithoutDocumentsInput, MedicalEventUncheckedUpdateWithoutDocumentsInput>
    create: XOR<MedicalEventCreateWithoutDocumentsInput, MedicalEventUncheckedCreateWithoutDocumentsInput>
    where?: MedicalEventWhereInput
  }

  export type MedicalEventUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: MedicalEventWhereInput
    data: XOR<MedicalEventUpdateWithoutDocumentsInput, MedicalEventUncheckedUpdateWithoutDocumentsInput>
  }

  export type MedicalEventUpdateWithoutDocumentsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalEventsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutHandledEventsNestedInput
    createdBy?: usersUpdateOneRequiredWithoutCreatedEventsNestedInput
    medicationsUsed?: MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateWithoutDocumentsInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type usersCreateWithoutCreatedPostsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutCreatedPostsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutCreatedPostsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCreatedPostsInput, usersUncheckedCreateWithoutCreatedPostsInput>
  }

  export type usersUpsertWithoutCreatedPostsInput = {
    update: XOR<usersUpdateWithoutCreatedPostsInput, usersUncheckedUpdateWithoutCreatedPostsInput>
    create: XOR<usersCreateWithoutCreatedPostsInput, usersUncheckedCreateWithoutCreatedPostsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCreatedPostsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCreatedPostsInput, usersUncheckedUpdateWithoutCreatedPostsInput>
  }

  export type usersUpdateWithoutCreatedPostsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutCreatedPostsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutNotificationsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutNotificationsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
  }

  export type VaccinationCampaignCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccinations?: VaccinationCreateNestedManyWithoutCampaignInput
  }

  export type VaccinationCampaignUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    vaccineName: string
    targetGrades?: VaccinationCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vaccinations?: VaccinationUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type VaccinationCampaignCreateOrConnectWithoutNotificationsInput = {
    where: VaccinationCampaignWhereUniqueInput
    create: XOR<VaccinationCampaignCreateWithoutNotificationsInput, VaccinationCampaignUncheckedCreateWithoutNotificationsInput>
  }

  export type MedicalCheckCampaignCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalChecks?: MedicalCheckCreateNestedManyWithoutCampaignInput
  }

  export type MedicalCheckCampaignUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    checkTypes?: MedicalCheckCampaignCreatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignCreatetargetGradesInput | string[]
    scheduledDate: Date | string
    deadline: Date | string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    medicalChecks?: MedicalCheckUncheckedCreateNestedManyWithoutCampaignInput
  }

  export type MedicalCheckCampaignCreateOrConnectWithoutNotificationsInput = {
    where: MedicalCheckCampaignWhereUniqueInput
    create: XOR<MedicalCheckCampaignCreateWithoutNotificationsInput, MedicalCheckCampaignUncheckedCreateWithoutNotificationsInput>
  }

  export type usersUpsertWithoutNotificationsInput = {
    update: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
    create: XOR<usersCreateWithoutNotificationsInput, usersUncheckedCreateWithoutNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutNotificationsInput, usersUncheckedUpdateWithoutNotificationsInput>
  }

  export type usersUpdateWithoutNotificationsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutNotificationsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VaccinationCampaignUpsertWithoutNotificationsInput = {
    update: XOR<VaccinationCampaignUpdateWithoutNotificationsInput, VaccinationCampaignUncheckedUpdateWithoutNotificationsInput>
    create: XOR<VaccinationCampaignCreateWithoutNotificationsInput, VaccinationCampaignUncheckedCreateWithoutNotificationsInput>
    where?: VaccinationCampaignWhereInput
  }

  export type VaccinationCampaignUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: VaccinationCampaignWhereInput
    data: XOR<VaccinationCampaignUpdateWithoutNotificationsInput, VaccinationCampaignUncheckedUpdateWithoutNotificationsInput>
  }

  export type VaccinationCampaignUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUpdateManyWithoutCampaignNestedInput
  }

  export type VaccinationCampaignUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    vaccineName?: StringFieldUpdateOperationsInput | string
    targetGrades?: VaccinationCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinations?: VaccinationUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type MedicalCheckCampaignUpsertWithoutNotificationsInput = {
    update: XOR<MedicalCheckCampaignUpdateWithoutNotificationsInput, MedicalCheckCampaignUncheckedUpdateWithoutNotificationsInput>
    create: XOR<MedicalCheckCampaignCreateWithoutNotificationsInput, MedicalCheckCampaignUncheckedCreateWithoutNotificationsInput>
    where?: MedicalCheckCampaignWhereInput
  }

  export type MedicalCheckCampaignUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: MedicalCheckCampaignWhereInput
    data: XOR<MedicalCheckCampaignUpdateWithoutNotificationsInput, MedicalCheckCampaignUncheckedUpdateWithoutNotificationsInput>
  }

  export type MedicalCheckCampaignUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalChecks?: MedicalCheckUpdateManyWithoutCampaignNestedInput
  }

  export type MedicalCheckCampaignUncheckedUpdateWithoutNotificationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    checkTypes?: MedicalCheckCampaignUpdatecheckTypesInput | string[]
    targetGrades?: MedicalCheckCampaignUpdatetargetGradesInput | string[]
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deadline?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicalChecks?: MedicalCheckUncheckedUpdateManyWithoutCampaignNestedInput
  }

  export type usersCreateWithoutAuditLogsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentCreateNestedOneWithoutUserInput
    parentProfile?: ParentCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseCreateNestedOneWithoutUserInput
    managerProfile?: ManagerCreateNestedOneWithoutUserInput
    adminProfile?: AdminCreateNestedOneWithoutUserInput
    createdPosts?: PostCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    fullName: string
    password: string
    email: string
    role?: $Enums.UserRole
    phone?: string | null
    address?: string | null
    avatar?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    studentProfile?: StudentUncheckedCreateNestedOneWithoutUserInput
    parentProfile?: ParentUncheckedCreateNestedOneWithoutUserInput
    nurseProfile?: SchoolNurseUncheckedCreateNestedOneWithoutUserInput
    managerProfile?: ManagerUncheckedCreateNestedOneWithoutUserInput
    adminProfile?: AdminUncheckedCreateNestedOneWithoutUserInput
    createdPosts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    createdEvents?: MedicalEventUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAuditLogsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAuditLogsInput, usersUncheckedCreateWithoutAuditLogsInput>
  }

  export type usersUpsertWithoutAuditLogsInput = {
    update: XOR<usersUpdateWithoutAuditLogsInput, usersUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<usersCreateWithoutAuditLogsInput, usersUncheckedCreateWithoutAuditLogsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAuditLogsInput, usersUncheckedUpdateWithoutAuditLogsInput>
  }

  export type usersUpdateWithoutAuditLogsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUpdateOneWithoutUserNestedInput
    createdPosts?: PostUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAuditLogsInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentProfile?: StudentUncheckedUpdateOneWithoutUserNestedInput
    parentProfile?: ParentUncheckedUpdateOneWithoutUserNestedInput
    nurseProfile?: SchoolNurseUncheckedUpdateOneWithoutUserNestedInput
    managerProfile?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    adminProfile?: AdminUncheckedUpdateOneWithoutUserNestedInput
    createdPosts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    createdEvents?: MedicalEventUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    excerpt?: string | null
    coverImage?: string | null
    category?: string | null
    tags?: PostCreatetagsInput | string[]
    isPublished?: boolean
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalEventCreateManyCreatedByInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    vaccinationCampaignId?: string | null
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: InputJsonValue | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    excerpt?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: PostUpdatetagsInput | string[]
    isPublished?: BoolFieldUpdateOperationsInput | boolean
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalEventsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutHandledEventsNestedInput
    medicationsUsed?: MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateWithoutCreatedByInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateManyWithoutCreatedByInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vaccinationCampaign?: VaccinationCampaignUpdateOneWithoutNotificationsNestedInput
    medicalCheckCampaign?: MedicalCheckCampaignUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: InputJsonValue | InputJsonValue | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyStudentInput = {
    id?: string
    parentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type MedicalEventCreateManyStudentInput = {
    id?: string
    nurseId?: string | null
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCreateManyStudentInput = {
    id?: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCreateManyStudentInput = {
    id?: string
    campaignId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentMedicationCreateManyStudentInput = {
    id?: string
    parentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateWithoutStudentInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    parent?: ParentUpdateOneRequiredWithoutChildrenNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentUncheckedUpdateManyWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MedicalEventUpdateWithoutStudentInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nurse?: SchoolNurseUpdateOneWithoutHandledEventsNestedInput
    createdBy?: usersUpdateOneRequiredWithoutCreatedEventsNestedInput
    medicationsUsed?: MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateWithoutStudentInput = {
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateManyWithoutStudentInput = {
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUpdateWithoutStudentInput = {
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: VaccinationCampaignUpdateOneRequiredWithoutVaccinationsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateWithoutStudentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutStudentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUpdateWithoutStudentInput = {
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    campaign?: MedicalCheckCampaignUpdateOneRequiredWithoutMedicalChecksNestedInput
    nurse?: SchoolNurseUpdateOneWithoutMedicalChecksNestedInput
  }

  export type MedicalCheckUncheckedUpdateWithoutStudentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUncheckedUpdateManyWithoutStudentInput = {
    campaignId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationUpdateWithoutStudentInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: ParentUpdateOneRequiredWithoutMedicationsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutStudentMedicationsNestedInput
  }

  export type StudentMedicationUncheckedUpdateWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationUncheckedUpdateManyWithoutStudentInput = {
    parentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentParentCreateManyParentInput = {
    id?: string
    studentId: string
    relationship: string
    isPrimary?: boolean
  }

  export type StudentMedicationCreateManyParentInput = {
    id?: string
    studentId: string
    medicationId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentParentUpdateWithoutParentInput = {
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentUpdateOneRequiredWithoutParentsNestedInput
  }

  export type StudentParentUncheckedUpdateWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentParentUncheckedUpdateManyWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    relationship?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type StudentMedicationUpdateWithoutParentInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicationsNestedInput
    medication?: MedicationUpdateOneRequiredWithoutStudentMedicationsNestedInput
  }

  export type StudentMedicationUncheckedUpdateWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationUncheckedUpdateManyWithoutParentInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    medicationId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventCreateManyNurseInput = {
    id?: string
    studentId: string
    createdById: string
    title: string
    description: string
    type: $Enums.MedicalEventType
    status?: $Enums.MedicalEventStatus
    severity: string
    location?: string | null
    symptoms?: MedicalEventCreatesymptomsInput | string[]
    treatment?: string | null
    outcome?: string | null
    occurredAt: Date | string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VaccinationCreateManyNurseInput = {
    id?: string
    studentId: string
    campaignId: string
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalCheckCreateManyNurseInput = {
    id?: string
    studentId: string
    campaignId: string
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalEventUpdateWithoutNurseInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalEventsNestedInput
    createdBy?: usersUpdateOneRequiredWithoutCreatedEventsNestedInput
    medicationsUsed?: MedicalEventMedicationUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medicationsUsed?: MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventNestedInput
    documents?: MedicalDocumentUncheckedUpdateManyWithoutMedicalEventNestedInput
  }

  export type MedicalEventUncheckedUpdateManyWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    createdById?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: EnumMedicalEventTypeFieldUpdateOperationsInput | $Enums.MedicalEventType
    status?: EnumMedicalEventStatusFieldUpdateOperationsInput | $Enums.MedicalEventStatus
    severity?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    symptoms?: MedicalEventUpdatesymptomsInput | string[]
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    outcome?: NullableStringFieldUpdateOperationsInput | string | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUpdateWithoutNurseInput = {
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutVaccinationsNestedInput
    campaign?: VaccinationCampaignUpdateOneRequiredWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUpdateWithoutNurseInput = {
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalChecksNestedInput
    campaign?: MedicalCheckCampaignUpdateOneRequiredWithoutMedicalChecksNestedInput
  }

  export type MedicalCheckUncheckedUpdateWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUncheckedUpdateManyWithoutNurseInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    campaignId?: StringFieldUpdateOperationsInput | string
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventMedicationCreateManyMedicalEventInput = {
    id?: string
    medicationId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type MedicalDocumentCreateManyMedicalEventInput = {
    id?: string
    title: string
    description?: string | null
    fileName: string
    filePath: string
    fileSize: number
    mimeType: string
    createdAt?: Date | string
  }

  export type MedicalEventMedicationUpdateWithoutMedicalEventInput = {
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medication?: MedicationUpdateOneRequiredWithoutMedicalEventMedicationsNestedInput
  }

  export type MedicalEventMedicationUncheckedUpdateWithoutMedicalEventInput = {
    medicationId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalEventMedicationUncheckedUpdateManyWithoutMedicalEventInput = {
    medicationId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalDocumentUpdateWithoutMedicalEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalDocumentUncheckedUpdateWithoutMedicalEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalDocumentUncheckedUpdateManyWithoutMedicalEventInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationCreateManyMedicationInput = {
    id?: string
    studentId: string
    parentId: string
    dosage: string
    frequency: string
    duration?: string | null
    instructions?: string | null
    status?: $Enums.MedicationStatus
    startDate: Date | string
    endDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicalEventMedicationCreateManyMedicationInput = {
    id?: string
    medicalEventId: string
    quantityUsed: number
    dosageGiven: string
    administeredAt: Date | string
    notes?: string | null
  }

  export type StockMovementCreateManyMedicationInput = {
    id?: string
    type: string
    quantity: number
    reason?: string | null
    reference?: string | null
    createdAt?: Date | string
  }

  export type StudentMedicationUpdateWithoutMedicationInput = {
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicationsNestedInput
    parent?: ParentUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type StudentMedicationUncheckedUpdateWithoutMedicationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentMedicationUncheckedUpdateManyWithoutMedicationInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    parentId?: StringFieldUpdateOperationsInput | string
    dosage?: StringFieldUpdateOperationsInput | string
    frequency?: StringFieldUpdateOperationsInput | string
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicationStatusFieldUpdateOperationsInput | $Enums.MedicationStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalEventMedicationUpdateWithoutMedicationInput = {
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    medicalEvent?: MedicalEventUpdateOneRequiredWithoutMedicationsUsedNestedInput
  }

  export type MedicalEventMedicationUncheckedUpdateWithoutMedicationInput = {
    medicalEventId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MedicalEventMedicationUncheckedUpdateManyWithoutMedicationInput = {
    medicalEventId?: StringFieldUpdateOperationsInput | string
    quantityUsed?: IntFieldUpdateOperationsInput | number
    dosageGiven?: StringFieldUpdateOperationsInput | string
    administeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StockMovementUpdateWithoutMedicationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateWithoutMedicationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StockMovementUncheckedUpdateManyWithoutMedicationInput = {
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationCreateManyCampaignInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    status?: $Enums.VaccinationStatus
    scheduledDate: Date | string
    administeredDate?: Date | string | null
    dose?: string | null
    batch?: string | null
    sideEffects?: string | null
    notes?: string | null
    parentConsent?: boolean
    consentDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyVaccinationCampaignInput = {
    id?: string
    userId: string
    medicalCheckCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type VaccinationUpdateWithoutCampaignInput = {
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutVaccinationsNestedInput
    nurse?: SchoolNurseUpdateOneWithoutVaccinationsNestedInput
  }

  export type VaccinationUncheckedUpdateWithoutCampaignInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VaccinationUncheckedUpdateManyWithoutCampaignInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumVaccinationStatusFieldUpdateOperationsInput | $Enums.VaccinationStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    administeredDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dose?: NullableStringFieldUpdateOperationsInput | string | null
    batch?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentConsent?: BoolFieldUpdateOperationsInput | boolean
    consentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutVaccinationCampaignInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNotificationsNestedInput
    medicalCheckCampaign?: MedicalCheckCampaignUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutVaccinationCampaignInput = {
    userId?: StringFieldUpdateOperationsInput | string
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutVaccinationCampaignInput = {
    userId?: StringFieldUpdateOperationsInput | string
    medicalCheckCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckCreateManyCampaignInput = {
    id?: string
    studentId: string
    nurseId?: string | null
    status?: $Enums.MedicalCheckStatus
    scheduledDate: Date | string
    completedDate?: Date | string | null
    visionResult?: string | null
    hearingResult?: string | null
    dentalResult?: string | null
    heightWeight?: InputJsonValue | null
    generalHealth?: string | null
    recommendations?: string | null
    requiresFollowUp?: boolean
    followUpDate?: Date | string | null
    notes?: string | null
    parentNotified?: boolean
    parentResponse?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyMedicalCheckCampaignInput = {
    id?: string
    userId: string
    vaccinationCampaignId?: string | null
    title: string
    message: string
    type: string
    status?: $Enums.NotificationStatus
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    readAt?: Date | string | null
    createdAt?: Date | string
  }

  export type MedicalCheckUpdateWithoutCampaignInput = {
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMedicalChecksNestedInput
    nurse?: SchoolNurseUpdateOneWithoutMedicalChecksNestedInput
  }

  export type MedicalCheckUncheckedUpdateWithoutCampaignInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicalCheckUncheckedUpdateManyWithoutCampaignInput = {
    studentId?: StringFieldUpdateOperationsInput | string
    nurseId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMedicalCheckStatusFieldUpdateOperationsInput | $Enums.MedicalCheckStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    visionResult?: NullableStringFieldUpdateOperationsInput | string | null
    hearingResult?: NullableStringFieldUpdateOperationsInput | string | null
    dentalResult?: NullableStringFieldUpdateOperationsInput | string | null
    heightWeight?: InputJsonValue | InputJsonValue | null
    generalHealth?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    requiresFollowUp?: BoolFieldUpdateOperationsInput | boolean
    followUpDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    parentNotified?: BoolFieldUpdateOperationsInput | boolean
    parentResponse?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutMedicalCheckCampaignInput = {
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutNotificationsNestedInput
    vaccinationCampaign?: VaccinationCampaignUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMedicalCheckCampaignInput = {
    userId?: StringFieldUpdateOperationsInput | string
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutMedicalCheckCampaignInput = {
    userId?: StringFieldUpdateOperationsInput | string
    vaccinationCampaignId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}